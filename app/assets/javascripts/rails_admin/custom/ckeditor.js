(function (t) { const e = t["pt-br"] = t["pt-br"] || {}; e.dictionary = Object.assign(e.dictionary || {}, { "%0 of %1": "%0 de %1", "Align center": "Centralizar", "Align left": "Alinhar à esquerda", "Align right": "Alinhar à direita", Aquamarine: "Água-marinha", Black: "Preto", "Block quote": "Bloco de citação", Blue: "Azul", Bold: "Negrito", "Break text": "Quebrar texto", "Bulleted List": "Lista com marcadores", "Bulleted list styles toolbar": "Barra de ferramentas de estilos de lista com marcador", Cancel: "Cancelar", "Caption for image: %0": "Legenda da imagem: %0", "Caption for the image": "Legenda para a imagem", "Centered image": "Imagem centralizada", "Change image text alternative": "Alterar texto alternativo da imagem", "Choose heading": "Escolha o título", "Choose language": "Escolher idioma", Circle: "Círculo", Decimal: "Decimal", "Decimal with leading zero": "Decimal com zero à esquerda", "Decrease indent": "Diminuir indentação", "Dim grey": "Cinza escuro", Disc: "Disco", Downloadable: "Pode ser baixado", "Dropdown toolbar": "Barra de Ferramentas da Lista Suspensa", "Edit block": "Editor de bloco", "Edit link": "Editar link", "Editor block content toolbar": "Barra de ferramentas de bloco do Editor", "Editor contextual toolbar": "Barra de ferramentas contextuais do Editor", "Editor editing area: %0": "Área de edição do editor: %0", "Editor toolbar": "Ferramentas do Editor", "Enter image caption": "Inserir legenda da imagem", Find: "Pesquisar", "Find and replace": "Pesquisar e substituir", "Find in text…": "Pesquisar no texto", "Full size image": "Imagem completa", Green: "Verde", Grey: "Cinza", Heading: "Titulo", "Heading 1": "Título 1", "Heading 2": "Título 2", "Heading 3": "Título 3", "Heading 4": "Título 4", "Heading 5": "Título 5", "Heading 6": "Título 6", "Horizontal line": "Linha horizontal", "Image resize list": "Lista de redimensionamento de imagem", "Image toolbar": "Ferramentas de Imagem", "image widget": "Ferramenta de imagem", "In line": "Na linha", "Increase indent": "Aumentar indentação", Insert: "Inserir", "Insert image": "Inserir imagem", "Insert image via URL": "Inserir imagem via URL", "Insert media": "Inserir mídia", "Insert paragraph after block": "Inserir parágrafo após o bloco", "Insert paragraph before block": "Inserir parágrafo antes do bloco", Italic: "Itálico", Justify: "Justificar", Language: "Idioma", "Left aligned image": "Imagem alinhada à esquerda", "Light blue": "Azul claro", "Light green": "Verde claro", "Light grey": "Cinza claro", Link: "Link", "Link image": "Link da imagem", "Link URL": "URL", "List properties": "Propriedades da lista", "Lower-latin": "Latim inferior", "Lower–roman": "Romano inferior", "Match case": "Diferenciar maiúsculas de minúsculas", "Media toolbar": "Ferramentas de Mídia", "Media URL": "URL da mídia", "media widget": "Ferramenta de mídia", Next: "Próximo", "Next result": "Próxima ocorrência", "Numbered List": "Lista numerada", "Numbered list styles toolbar": "Barra de ferramentas de estilos de lista numerada", "Open in a new tab": "Abrir em nova aba", "Open link in new tab": "Abrir link em nova aba", "Open media in new tab": "Abrir mídia em nova aba", Orange: "Laranja", Original: "Original", Paragraph: "Parágrafo", "Paste the media URL in the input.": "Cole o endereço da mídia no campo.", "Press Enter to type after or press Shift + Enter to type before the widget": "Pressione Enter para digitar depois ou pressione Shift + Enter para digitar antes do widget", Previous: "Anterior", "Previous result": "Ocorrência anterior", Purple: "Púrpura", Red: "Vermelho", Redo: "Refazer", "Remove Format": "Remover Formatação", "Remove language": "Remover idioma", Replace: "Substituir", "Replace all": "Substituir tudo", "Replace with…": "Substituir por...", "Resize image": "Redimensionar imagem", "Resize image to %0": "Redimensionar a imagem para %0", "Resize image to the original size": "Redimensionar a imagem para o tamanho original", "Reversed order": "Ordem reversa", "Rich Text Editor": "Editor de Formatação", "Right aligned image": "Imagem alinhada à direita", Save: "Salvar", "Select all": "Selecionar tudo", "Show more items": "Exibir mais itens", "Show options": "Mostrar opções", "Side image": "Imagem lateral", Square: "Quadrado", "Start at": "Iniciar em", "Start index must be greater than 0.": "O índice inicial deve ser maior que 0.", "Text alignment": "Alinhamento do texto", "Text alignment toolbar": "Ferramentas de alinhamento de texto", "Text alternative": "Texto alternativo", "Text to find must not be empty.": "Texto a ser pesquisado não pode ser vazio.", "The URL must not be empty.": "A URL não pode ficar em branco.", "This link has no URL": "Este link não possui uma URL", "This media URL is not supported.": "A URL desta mídia não é suportada.", "Tip: Find some text first in order to replace it.": "Dica: Pesquise por algum texto antes para poder substituí-la.", "Tip: Paste the URL into the content to embed faster.": "Cole o endereço dentro do conteúdo para embutir mais rapidamente.", "Toggle the circle list style": "Alternar o estilo da lista de círculo", "Toggle the decimal list style": "Alternar o estilo de lista decimal", "Toggle the decimal with leading zero list style": "Alternar o decimal com estilo de lista zero à esquerda", "Toggle the disc list style": "Alternar o estilo da lista de disco", "Toggle the lower–latin list style": "Alternar o estilo de lista latina inferior", "Toggle the lower–roman list style": "Alternar o estilo de lista romana inferior", "Toggle the square list style": "Alternar o estilo de lista quadrada", "Toggle the upper–latin list style": "Alternar o estilo de lista latino superior", "Toggle the upper–roman list style": "Alternar o estilo de lista romana superior", Turquoise: "Turquesa", Undo: "Desfazer", Unlink: "Remover link", Update: "Atualizar", "Update image URL": "Atualizar URL da imagem", "Upload failed": "Falha ao subir arquivo", "Upload in progress": "Enviando dados", "Upper-latin": "Latim superior", "Upper-roman": "Romano superior", White: "Branco", "Whole words only": "Apenas palavras inteiras", "Widget toolbar": "Ferramentas de Widgets", "Wrap text": "Texto ao redor", Yellow: "Amarelo" }); e.getPluralForm = function (t) { return t == 0 || t == 1 ? 0 : t != 0 && t % 1e6 == 0 ? 1 : 2 } })(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */(function t(e, n) { if (typeof exports === "object" && typeof module === "object") module.exports = n(); else if (typeof define === "function" && define.amd) define([], n); else if (typeof exports === "object") exports["ClassicEditor"] = n(); else e["ClassicEditor"] = n() })(self, (() => (() => { "use strict"; var t = { 636: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n'], sourceRoot: "" }]); const c = a }, 390: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 3638: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 8894: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4401: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n"], sourceRoot: "" }]); const c = a }, 5436: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-find-result{background:var(--ck-color-highlight-background);color:var(--ck-color-text)}.ck-find-result_selected{background:#ff9633}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplace.css"], names: [], mappings: "AAKA,gBACC,+CAAgD,CAChD,0BACD,CAEA,yBACC,kBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-find-result {\n\tbackground: var(--ck-color-highlight-background);\n\tcolor: var(--ck-color-text);\n}\n\n.ck-find-result_selected {\n\tbackground: hsl(29, 100%, 60%);\n}\n"], sourceRoot: "" }]); const c = a }, 9289: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-find-and-replace-form{max-width:100%}.ck.ck-find-and-replace-form fieldset{display:flex}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{position:absolute}.ck.ck-find-and-replace-form{width:400px}.ck.ck-find-and-replace-form:focus{outline:none}.ck.ck-find-and-replace-form fieldset{align-content:stretch;align-items:center;border:0;flex-direction:row;flex-wrap:nowrap;margin:0;padding:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset>.ck-button{flex:0 0 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset>*+*{margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset>*+*{margin-right:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view{flex:1 1 auto}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view .ck-input{min-width:50px;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find{align-items:flex-start}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find{font-weight:700}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find .ck-button__label{padding-left:var(--ck-spacing-large);padding-right:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-prev>.ck-icon{transform:rotate(90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-next>.ck-icon{transform:rotate(-90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{left:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{color:var(--ck-color-base-border)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace{flex-wrap:wrap;justify-content:flex-end;margin-top:calc(var(--ck-spacing-large)*-1)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view{margin-bottom:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-options-dropdown{margin-left:0;margin-right:auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view,.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view .ck-input{width:100%}@media screen and (max-width:600px){.ck.ck-find-and-replace-form{width:300px}.ck.ck-find-and-replace-form fieldset{flex-wrap:wrap}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-labeled-field-view{flex:1 0 auto;margin-bottom:var(--ck-spacing-standard);width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button{text-align:center}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{flex:1 1 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-left:0}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-right:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type .ck-button__label{text-align:center;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>:not(.ck-labeled-field-view){flex:1 1 auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-dropdown:not(.ck-labeled-field-view){flex-grow:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-button:not(.ck-labeled-field-view)>.ck-button__label{text-align:center;width:100%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplaceform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-find-and-replace/findandreplaceform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAKA,6BACC,cAUD,CARC,sCACC,YAMD,CAHC,yFACC,iBACD,CCNF,6BACC,WAyGD,CAnGC,mCACC,YACD,CAEA,sCAIC,qBAAsB,CADtB,kBAAmB,CAInB,QAAS,CANT,kBAAmB,CACnB,gBAAiB,CAMjB,QAAS,CAFT,+BAwFD,CApFC,iDACC,aACD,CAGC,oDACC,sCACD,CAIA,oDACC,uCACD,CAGD,6DACC,aAMD,CAJC,uEAEC,cAAe,CADf,UAED,CAID,qEAEC,sBAkCD,CAhCC,qFACC,eAOD,CAJC,uGACC,oCAAqC,CACrC,qCACD,CAGD,8FACC,uBACD,CAEA,8FACC,wBACD,CAEA,yFACC,OAAQ,CACR,0BAWD,CAbA,mGAKE,gCAQF,CAbA,mGASE,+BAIF,CAbA,yFAYC,iCACD,CAID,wEACC,cAAe,CACf,wBAAyB,CACzB,2CAeD,CAbC,+FACC,qCACD,CAEA,6FAEC,aAAc,CADd,iBAED,CAEA,wMAEC,UACD,CCzGF,oCD+GA,6BACC,WAiDD,CA/CC,sCACC,cA6CD,CAzCE,4FACC,aAAc,CAEd,wCAAyC,CADzC,UAED,CAEA,gFACC,iBAkBD,CAhBC,8FACC,aAcD,CAfA,wGAIE,aAWF,CAfA,wGAQE,cAOF,CAJC,gHAEC,iBAAkB,CADlB,UAED,CAMH,qGACC,aAUD,CARC,iHACC,WACD,CAEA,iIAEC,iBAAkB,CADlB,UAED,CC5JH", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-find-and-replace-form {\n\tmax-width: 100%;\n\n\t& fieldset {\n\t\tdisplay: flex;\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find .ck-results-counter {\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-find-and-replace-form {\n\twidth: 400px;\n\n\t/*\n\t * The <form> needs tabindex="-1" for proper Esc handling after being clicked\n\t * but the side effect is that this creates a nasty focus outline in some browsers.\n\t */\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t& fieldset {\n\t\tflex-direction: row;\n\t\tflex-wrap: nowrap;\n\t\talign-items: center;\n\t\talign-content: stretch;\n\n\t\tpadding: var(--ck-spacing-large);\n\t\tborder: 0;\n\t\tmargin: 0;\n\n\t\t& > .ck-button {\n\t\t\tflex: 0 0 auto;\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\t& > * + * {\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t& > * + * {\n\t\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex: 1 1 auto;\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t\tmin-width: 50px;\n\t\t\t}\n\t\t}\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find {\n\t\t\t/* To display all controls in line when there\'s an error under the input */\n\t\t\talign-items: flex-start;\n\n\t\t\t& > .ck-button-find {\n\t\t\t\tfont-weight: bold;\n\n\t\t\t\t/* Beef the find button up a little. It\'s the main action button in the form */\n\t\t\t\t& .ck-button__label {\n\t\t\t\t\tpadding-left: var(--ck-spacing-large);\n\t\t\t\t\tpadding-right: var(--ck-spacing-large);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& > .ck-button-prev > .ck-icon {\n\t\t\t\ttransform: rotate(90deg);\n\t\t\t}\n\n\t\t\t& > .ck-button-next > .ck-icon {\n\t\t\t\ttransform: rotate(-90deg);\n\t\t\t}\n\n\t\t\t& .ck-results-counter {\n\t\t\t\ttop: 50%;\n\t\t\t\ttransform: translateY(-50%);\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tright: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tleft: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\tcolor: var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t/* The replace fieldset */\n\t\t&.ck-find-and-replace-form__replace {\n\t\t\tflex-wrap: wrap;\n\t\t\tjustify-content: flex-end;\n\t\t\tmargin-top: calc( -1 * var(--ck-spacing-large) );\n\n\t\t\t& > .ck-labeled-field-view {\n\t\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t& > .ck-options-dropdown {\n\t\t\t\tmargin-right: auto;\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t& > .ck-labeled-field-view,\n\t\t\t& > .ck-labeled-field-view .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n\n@mixin ck-media-phone {\n\t.ck.ck-find-and-replace-form {\n\t\twidth: 300px;\n\n\t\t& fieldset {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t/* The find fieldset */\n\t\t\t&.ck-find-and-replace-form__find {\n\t\t\t\t& .ck-labeled-field-view {\n\t\t\t\t\tflex: 1 0 auto;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmargin-bottom: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t& > .ck-button {\n\t\t\t\t\ttext-align: center;\n\n\t\t\t\t\t&:first-of-type {\n\t\t\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\t\t\tmargin-left: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\t\t\tmargin-right: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t& .ck-button__label {\n\t\t\t\t\t\t\twidth: 100%;\n\t\t\t\t\t\t\ttext-align: center;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The replace fieldset */\n\t\t\t&.ck-find-and-replace-form__replace > :not(.ck-labeled-field-view) {\n\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t&.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\n\t\t\t\t&.ck-button > .ck-button__label {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 3230: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 2536: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css"], names: [], mappings: "AAMA,yCAEC,iBACD,CAEA,eAGC,kBAA2B,CAC3B,QAAS,CAFT,UAAW,CADX,aAID", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n\t/* Necessary to render properly next to floated objects, e.g. side image case. */\n\tdisplay: flow-root;\n}\n\n.ck-content hr {\n\tmargin: 15px 0;\n\theight: 4px;\n\tbackground: hsl(0, 0%, 87%);\n\tborder: 0;\n}\n"], sourceRoot: "" }]); const c = a }, 9048: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 8662: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9292: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css"], names: [], mappings: "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n\tpadding: var(--ck-spacing-large);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n\tdisplay: block;\n\twidth: 100%;\n\tmargin: var(--ck-spacing-standard) auto;\n\tborder: 1px solid hsl(0, 0%, 80%);\n\tborder-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n}\n"], sourceRoot: "" }]); const c = a }, 5150: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css"], names: [], mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n}\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-image-insert-form__action-row {\n\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 1043: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css"], names: [], mappings: "AAKA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/* The resized inline image nested in the table should respect its parent size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline.image_resized img {\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n'], sourceRoot: "" }]); const c = a }, 4622: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9899: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 9825: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5870: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"], sourceRoot: "" }]); const c = a }, 6831: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 399: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'], sourceRoot: "" }]); const c = a }, 9465: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 4827: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& > .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\twidth: 50%;\n\t\tborder-radius: 0;\n\n\t\t&:not(:focus) {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 3858: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"], names: [], mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Match the icon size with the upload indicator brought by the image upload feature. */\n\t--ck-link-image-indicator-icon-size: 20;\n\t--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck.ck-editor__editable {\n\t/* Linked image indicator */\n\t& figure.image > a,\n\t& a span.image-inline {\n\t\t&::after {\n\t\t\tcontent: "";\n\n\t\t\t/*\n\t\t\t * Smaller images should have the icon closer to the border.\n\t\t\t * Match the icon position with the upload indicator brought by the image upload feature.\n\t\t\t */\n\t\t\ttop: min(var(--ck-spacing-medium), 6%);\n\t\t\tright: min(var(--ck-spacing-medium), 6%);\n\n\t\t\tbackground-color: hsla(0, 0%, 0%, .4);\n\t\t\tbackground-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");\n\t\t\tbackground-size: 14px;\n\t\t\tbackground-repeat: no-repeat;\n\t\t\tbackground-position: center;\n\t\t\tborder-radius: 100%;\n\n\t\t\t/*\n\t\t\t* Use CSS math to simulate container queries.\n\t\t\t* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t\t\t*/\n\t\t\toverflow: hidden;\n\t\t\twidth: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t\theight: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n\t\t}\n\t}\n}\n\n'], sourceRoot: "" }]); const c = a }, 3195: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/collapsible.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"], names: [], mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n\t& > .ck-collapsible__children {\n\t\tdisplay: none;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n\t& > .ck.ck-button {\n\t\twidth: 100%;\n\t\tfont-weight: bold;\n\t\tpadding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\t\tborder-radius: 0;\n\t\tcolor: inherit;\n\n\t\t&:focus {\n\t\t\tbackground: transparent;\n\t\t}\n\n\t\t&:active, &:not(:focus), &:hover:not(:focus) {\n\t\t\tbackground: transparent;\n\t\t\tborder-color: transparent;\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t& > .ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-medium);\n\t\t\twidth: var(--ck-collapsible-arrow-size);\n\t\t}\n\t}\n\n\t& > .ck-collapsible__children {\n\t\tpadding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n\t}\n\n\t&.ck-collapsible_collapsed {\n\t\t& > .ck.ck-button .ck-icon {\n\t\t\ttransform: rotate(-90deg);\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9989: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/list.css"], names: [], mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content ol {\n\tlist-style-type: decimal;\n\n\t& ol {\n\t\tlist-style-type: lower-latin;\n\n\t\t& ol {\n\t\t\tlist-style-type: lower-roman;\n\n\t\t\t& ol {\n\t\t\t\tlist-style-type: upper-latin;\n\n\t\t\t\t& ol {\n\t\t\t\t\tlist-style-type: upper-roman;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck-content ul {\n\tlist-style-type: disc;\n\n\t& ul {\n\t\tlist-style-type: circle;\n\n\t\t& ul {\n\t\t\tlist-style-type: square;\n\n\t\t\t& ul {\n\t\t\t\tlist-style-type: square;\n\t\t\t}\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 7133: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"], names: [], mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n\t/* When there are no list styles and there is no collapsible. */\n\t&.ck-list-properties_without-styles {\n\t\tpadding: var(--ck-spacing-large);\n\n\t\t& > * {\n\t\t\tmin-width: 14em;\n\n\t\t\t& + * {\n\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * When the numbered list property fields (start at, reversed) should be displayed,\n\t * more horizontal space is needed. Reconfigure the style grid to create that space.\n\t */\n\t&.ck-list-properties_with-numbered-properties {\n\t\t& > .ck-list-styles-list {\n\t\t\tgrid-template-columns: repeat( 4, auto );\n\t\t}\n\n\t\t/* When list styles are rendered and property fields are in a collapsible. */\n\t\t& > .ck-collapsible {\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t& > .ck-collapsible__children {\n\t\t\t\t& > * {\n\t\t\t\t\twidth: 100%;\n\n\t\t\t\t\t& + * {\n\t\t\t\t\t\tmargin-top: var(--ck-spacing-standard);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-numbered-list-properties__start-index .ck-input {\n\t\tmin-width: auto;\n\t\twidth: 100%;\n\t}\n\n\t& .ck.ck-numbered-list-properties__reversed-order {\n\t\tbackground: transparent;\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\t\tmargin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n\t\t&:active, &:hover {\n\t\t\tbox-shadow: none;\n\t\t\tborder-color: transparent;\n\t\t\tbackground: none;\n\t\t}\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4553: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"], names: [], mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n\tgrid-template-columns: repeat( 3, auto );\n\trow-gap: var(--ck-spacing-medium);\n\tcolumn-gap: var(--ck-spacing-medium);\n\tpadding: var(--ck-spacing-large);\n\n\t& .ck-button {\n\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\twidth: var(--ck-list-style-button-size);\n\t\theight: var(--ck-list-style-button-size);\n\t\tpadding: 0;\n\n\t\t/*\n\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t * gaps in the grid.\n\t\t */\n\t\tmargin: 0;\n\n\t\t/*\n\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t * (which becomes blurry as it scales down).\n\t\t */\n\t\tbox-sizing: content-box;\n\n\t\t& .ck-icon {\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 5777: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css"], names: [], mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n'], sourceRoot: "" }]); const c = a }, 952: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"], names: [], mappings: "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="goo.gl/maps"],\n\t&[data-oembed-url*="maps.google.com"],\n\t&[data-oembed-url*="maps.app.goo.gl"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 3525: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 4499: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\n\t\tcolor: var(--ck-color-button-on-color);\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]); const c = a }, 9681: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2px /* Border */\n\t);\n\t--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t/* Unlike a regular button, the switch button text color and background should never change.\n\t * Changing toggle switch (background, outline) is enough to carry the information about the\n\t * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n\t */\n\t&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n\t\tcolor: inherit;\n\t\tbackground: transparent;\n\t}\n\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Apply some smooth transition to the box-shadow and border. */\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n\t\tborder: 1px solid transparent;\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: var(--ck-switch-button-inner-hover-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t/* Overriding default .ck-button:focus styles + an outline around the toogle */\n\t&:focus {\n\t\tborder-color: transparent;\n\t\toutline: none;\n\t\tbox-shadow: none;\n\n\t\t& .ck-button__toggle {\n\t\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n\t\t\toutline-offset: 1px;\n\t\t\toutline: var(--ck-focus-ring);\n\t\t}\n\t}\n\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-on {\n\t\t& .ck-button__toggle {\n\t\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t\t&:hover {\n\t\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t\t}\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\t/*\n\t\t\t\t* Move the toggle switch to the right. It will be animated.\n\t\t\t\t*/\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]); const c = a }, 4923: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'], sourceRoot: "" }]); const c = a }, 3488: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\t}\n\n\t& .ck-dropdown__panel {\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 6875: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 66: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* Make sure the divider stretches 100% height of the button\n\thttps://github.com/ckeditor/ckeditor5/issues/10936 */\n\t& > .ck-splitbutton__arrow:not(:focus) {\n\t\tborder-top-width: 0px;\n\t\tborder-bottom-width: 0px;\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t/* Make sure the divider between the buttons looks fine when the button is focused */\n\t\t& > .ck-splitbutton__arrow:focus::after {\n\t\t\t--ck-color-split-button-hover-border: var(--ck-color-focus-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5075: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"], sourceRoot: "" }]); const c = a }, 4547: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 5523: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 1174: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\t}\n\n\t/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n\t&.ck-icon_inherit-color {\n\t\tcolor: inherit;\n\n\t\t& * {\n\t\t\tcolor: inherit;\n\n\t\t\t&:not([fill]) {\n\t\t\t\t/* Needed by FF. */\n\t\t\t\tfill: currentColor;\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 6985: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 2751: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"], sourceRoot: "" }]); const c = a }, 8111: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);\n\t--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 1162: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-switchbutton):not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 8245: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-border-width: 1px;\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t\tmargin-top: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t\tmargin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_e"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-border);\n\t\t\tmargin-right: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent transparent var(--ck-color-panel-background);\n\t\t\tmargin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&[class*="arrow_w"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent var(--ck-color-panel-border) transparent transparent;\n\t\t\tmargin-left: calc( -1 * var(--ck-balloon-border-width) );\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent var(--ck-color-panel-background) transparent transparent;\n\t\t\tmargin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_e {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_w {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t\tmargin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 1757: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 3553: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 3609: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 1590: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n\t&::after {\n\t\tcontent: "";\n\t\twidth: 0;\n\t\tposition: absolute;\n\t\tright: -1px;\n\t\ttop: -1px;\n\t\tbottom: -1px;\n\t\tz-index: 1;\n\t}\n\n\t&:focus::after {\n\t\tdisplay: none;\n\t}\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button {\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: -1px;\n\t\t\t\ttop: -1px;\n\t\t\t\tbottom: -1px;\n\t\t\t\tz-index: 1;\n\t\t\t}\n\n\t\t\t&:focus::after {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\t\t\tborder-radius: 0;\n\n\t\t\t&:not(:focus) {\n\t\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 6706: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n"], sourceRoot: "" }]); const c = a }, 5571: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDoGD,CAvGA,qECOE,qCDgGF,CAvGA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAmGD,CAhGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAjGF,qCAqGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t/* A drop-down containing the nested toolbar with configured items. */\n\t& .ck-toolbar__nested-toolbar-dropdown {\n\t\t/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */\n\t\t& > .ck-dropdown__panel {\n\t\t\tmin-width: auto;\n\t\t}\n\n\t\t& > .ck-button > .ck-button__label {\n\t\t\tmax-width: 7em;\n\t\t\twidth: auto;\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 9948: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"], names: [], mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDPnC,mBAAoB,CAEpB,qCACD,CCMC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAbD,gCAgBC,eAMD,CAHC,uCACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t/* Keep tooltips transparent for any interactions. */\n\tpointer-events: none;\n\n\tz-index: calc( var(--ck-z-modal) + 100 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n\t--ck-balloon-border-width: 0px;\n\t--ck-balloon-arrow-offset: 0px;\n\t--ck-balloon-arrow-half-width: 4px;\n\t--ck-balloon-arrow-height: 4px;\n\t--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n\tpadding: 0 var(--ck-spacing-medium);\n\n\t& .ck-tooltip__text {\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t}\n\n\t/* Reset balloon panel styles */\n\tbox-shadow: none;\n\n\t/* Hide the default shadow of the .ck-balloon-panel tip */\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 6150: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(220, 6%, 81%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 50.2%, 42.5%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(218.2, 100%, 52.5%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t218, 81.8%, 56.9%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(212.4, 89.3%, 89%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 94.1%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(212, 100%, 97.1%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(211.7, 100%, 92.9%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(211, 15%, 95%);\n\t--ck-color-button-on-color:\t\t\t\t\t\t\t\t\thsl(218.1, 100%, 58%);\n\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 57.6%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 49%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 53.2%, 40.2%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-button-on-color);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n\n\t/* -- Search result highlight ---------------------------------------------------------------- */\n\n\t--ck-color-highlight-background:\t\t\t\t\t\t\thsl(60, 100%, 50%)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"], sourceRoot: "" }]); const c = a }, 6507: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]); const c = a }, 2263: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n"], sourceRoot: "" }]); const c = a }, 5137: (t, e, n) => { n.d(e, { Z: () => c }); var i = n(4015); var o = n.n(i); var r = n(3645); var s = n.n(r); var a = s()(o()); a.push([t.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'], sourceRoot: "" }]); const c = a }, 3645: t => { t.exports = function (t) { var e = []; e.toString = function e() { return this.map((function (e) { var n = t(e); if (e[2]) { return "@media ".concat(e[2], " {").concat(n, "}") } return n })).join("") }; e.i = function (t, n, i) { if (typeof t === "string") { t = [[null, t, ""]] } var o = {}; if (i) { for (var r = 0; r < this.length; r++) { var s = this[r][0]; if (s != null) { o[s] = true } } } for (var a = 0; a < t.length; a++) { var c = [].concat(t[a]); if (i && o[c[0]]) { continue } if (n) { if (!c[2]) { c[2] = n } else { c[2] = "".concat(n, " and ").concat(c[2]) } } e.push(c) } }; return e } }, 4015: t => { function e(t, e) { return s(t) || r(t, e) || i(t, e) || n() } function n() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function i(t, e) { if (!t) return; if (typeof t === "string") return o(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); if (n === "Object" && t.constructor) n = t.constructor.name; if (n === "Map" || n === "Set") return Array.from(t); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return o(t, e) } function o(t, e) { if (e == null || e > t.length) e = t.length; for (var n = 0, i = new Array(e); n < e; n++) { i[n] = t[n] } return i } function r(t, e) { var n = t && (typeof Symbol !== "undefined" && t[Symbol.iterator] || t["@@iterator"]); if (n == null) return; var i = []; var o = true; var r = false; var s, a; try { for (n = n.call(t); !(o = (s = n.next()).done); o = true) { i.push(s.value); if (e && i.length === e) break } } catch (t) { r = true; a = t } finally { try { if (!o && n["return"] != null) n["return"]() } finally { if (r) throw a } } return i } function s(t) { if (Array.isArray(t)) return t } t.exports = function t(n) { var i = e(n, 4), o = i[1], r = i[3]; if (!r) { return o } if (typeof btoa === "function") { var s = btoa(unescape(encodeURIComponent(JSON.stringify(r)))); var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s); var c = "/*# ".concat(a, " */"); var l = r.sources.map((function (t) { return "/*# sourceURL=".concat(r.sourceRoot || "").concat(t, " */") })); return [o].concat(l).concat([c]).join("\n") } return [o].join("\n") } }, 3379: (t, e, n) => { var i = function t() { var e; return function t() { if (typeof e === "undefined") { e = Boolean(window && document && document.all && !window.atob) } return e } }(); var o = function t() { var e = {}; return function t(n) { if (typeof e[n] === "undefined") { var i = document.querySelector(n); if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) { try { i = i.contentDocument.head } catch (t) { i = null } } e[n] = i } return e[n] } }(); var r = []; function s(t) { var e = -1; for (var n = 0; n < r.length; n++) { if (r[n].identifier === t) { e = n; break } } return e } function a(t, e) { var n = {}; var i = []; for (var o = 0; o < t.length; o++) { var a = t[o]; var c = e.base ? a[0] + e.base : a[0]; var l = n[c] || 0; var d = "".concat(c, " ").concat(l); n[c] = l + 1; var u = s(d); var h = { css: a[1], media: a[2], sourceMap: a[3] }; if (u !== -1) { r[u].references++; r[u].updater(h) } else { r.push({ identifier: d, updater: m(h, e), references: 1 }) } i.push(d) } return i } function c(t) { var e = document.createElement("style"); var i = t.attributes || {}; if (typeof i.nonce === "undefined") { var r = true ? n.nc : 0; if (r) { i.nonce = r } } Object.keys(i).forEach((function (t) { e.setAttribute(t, i[t]) })); if (typeof t.insert === "function") { t.insert(e) } else { var s = o(t.insert || "head"); if (!s) { throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.") } s.appendChild(e) } return e } function l(t) { if (t.parentNode === null) { return false } t.parentNode.removeChild(t) } var d = function t() { var e = []; return function t(n, i) { e[n] = i; return e.filter(Boolean).join("\n") } }(); function u(t, e, n, i) { var o = n ? "" : i.media ? "@media ".concat(i.media, " {").concat(i.css, "}") : i.css; if (t.styleSheet) { t.styleSheet.cssText = d(e, o) } else { var r = document.createTextNode(o); var s = t.childNodes; if (s[e]) { t.removeChild(s[e]) } if (s.length) { t.insertBefore(r, s[e]) } else { t.appendChild(r) } } } function h(t, e, n) { var i = n.css; var o = n.media; var r = n.sourceMap; if (o) { t.setAttribute("media", o) } else { t.removeAttribute("media") } if (r && typeof btoa !== "undefined") { i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */") } if (t.styleSheet) { t.styleSheet.cssText = i } else { while (t.firstChild) { t.removeChild(t.firstChild) } t.appendChild(document.createTextNode(i)) } } var f = null; var g = 0; function m(t, e) { var n; var i; var o; if (e.singleton) { var r = g++; n = f || (f = c(e)); i = u.bind(null, n, r, false); o = u.bind(null, n, r, true) } else { n = c(e); i = h.bind(null, n, e); o = function t() { l(n) } } i(t); return function e(n) { if (n) { if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) { return } i(t = n) } else { o() } } } t.exports = function (t, e) { e = e || {}; if (!e.singleton && typeof e.singleton !== "boolean") { e.singleton = i() } t = t || []; var n = a(t, e); return function t(i) { i = i || []; if (Object.prototype.toString.call(i) !== "[object Array]") { return } for (var o = 0; o < n.length; o++) { var c = n[o]; var l = s(c); r[l].references-- } var d = a(i, e); for (var u = 0; u < n.length; u++) { var h = n[u]; var f = s(h); if (r[f].references === 0) { r[f].updater(); r.splice(f, 1) } } n = d } } } }; var e = {}; function n(i) { var o = e[i]; if (o !== undefined) { return o.exports } var r = e[i] = { id: i, exports: {} }; t[i](r, r.exports, n); return r.exports } (() => { n.n = t => { var e = t && t.__esModule ? () => t["default"] : () => t; n.d(e, { a: e }); return e } })(); (() => { n.d = (t, e) => { for (var i in e) { if (n.o(e, i) && !n.o(t, i)) { Object.defineProperty(t, i, { enumerable: true, get: e[i] }) } } } })(); (() => { n.g = function () { if (typeof globalThis === "object") return globalThis; try { return this || new Function("return this")() } catch (t) { if (typeof window === "object") return window } }() })(); (() => { n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e) })(); (() => { n.nc = undefined })(); var i = {}; (() => { n.d(i, { default: () => yR }); function t({ emitter: t, activator: e, callback: n, contextElements: i }) { t.listenTo(document, "mousedown", ((t, o) => { if (!e()) { return } const r = typeof o.composedPath == "function" ? o.composedPath() : []; const s = typeof i == "function" ? i() : i; for (const t of s) { if (t.contains(o.target) || r.includes(t)) { return } } n() })) } function e(t) { class e extends t { disableCssTransitions() { this._isCssTransitionsDisabled = true } enableCssTransitions() { this._isCssTransitionsDisabled = false } constructor(...t) { super(...t); this.set("_isCssTransitionsDisabled", false); this.initializeCssTransitionDisablerMixin() } initializeCssTransitionDisablerMixin() { this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } }) } } return e } function o({ view: t }) { t.listenTo(t.element, "submit", ((e, n) => { n.preventDefault(); t.fire("submit") }), { useCapture: true }) } function r({ keystrokeHandler: t, focusTracker: e, gridItems: n, numberOfColumns: i, uiLanguageDirection: o }) { const r = typeof i === "number" ? () => i : i; t.set("arrowright", s(((t, e) => o === "rtl" ? c(t, e.length) : a(t, e.length)))); t.set("arrowleft", s(((t, e) => o === "rtl" ? a(t, e.length) : c(t, e.length)))); t.set("arrowup", s(((t, e) => { let n = t - r(); if (n < 0) { n = t + r() * Math.floor(e.length / r()); if (n > e.length - 1) { n -= r() } } return n }))); t.set("arrowdown", s(((t, e) => { let n = t + r(); if (n > e.length - 1) { n = t % r() } return n }))); function s(t) { return i => { const o = n.find((t => t.element === e.focusedElement)); const r = n.getIndex(o); const s = t(r, n); n.get(s).focus(); i.stopPropagation(); i.preventDefault() } } function a(t, e) { if (t === e - 1) { return 0 } else { return t + 1 } } function c(t, e) { if (t === 0) { return e - 1 } else { return t - 1 } } } function s() { try { return navigator.userAgent.toLowerCase() } catch (t) { return "" } } const a = s(); const c = { isMac: d(a), isWindows: u(a), isGecko: h(a), isSafari: f(a), isiOS: g(a), isAndroid: m(a), isBlink: p(a), features: { isRegExpUnicodePropertySupported: k() } }; const l = c; function d(t) { return t.indexOf("macintosh") > -1 } function u(t) { return t.indexOf("windows") > -1 } function h(t) { return !!t.match(/gecko\/\d+/) } function f(t) { return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1 } function g(t) { return !!t.match(/iphone|ipad/i) || d(t) && navigator.maxTouchPoints > 0 } function m(t) { return t.indexOf("android") > -1 } function p(t) { return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0 } function k() { let t = false; try { t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0 } catch (t) { } return t } function b(t, e, n, i) { n = n || function (t, e) { return t === e }; const o = Array.isArray(t) ? t : Array.prototype.slice.call(t); const r = Array.isArray(e) ? e : Array.prototype.slice.call(e); const s = w(o, r, n); const a = i ? v(s, r.length) : C(r, s); return a } function w(t, e, n) { const i = _(t, e, n); if (i === -1) { return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 } } const o = A(t, i); const r = A(e, i); const s = _(o, r, n); const a = t.length - s; const c = e.length - s; return { firstIndex: i, lastIndexOld: a, lastIndexNew: c } } function _(t, e, n) { for (let i = 0; i < Math.max(t.length, e.length); i++) { if (t[i] === undefined || e[i] === undefined || !n(t[i], e[i])) { return i } } return -1 } function A(t, e) { return t.slice(e).reverse() } function C(t, e) { const n = []; const { firstIndex: i, lastIndexOld: o, lastIndexNew: r } = e; if (r - i > 0) { n.push({ index: i, type: "insert", values: t.slice(i, r) }) } if (o - i > 0) { n.push({ index: i + (r - i), type: "delete", howMany: o - i }) } return n } function v(t, e) { const { firstIndex: n, lastIndexOld: i, lastIndexNew: o } = t; if (n === -1) { return Array(e).fill("equal") } let r = []; if (n > 0) { r = r.concat(Array(n).fill("equal")) } if (o - n > 0) { r = r.concat(Array(o - n).fill("insert")) } if (i - n > 0) { r = r.concat(Array(i - n).fill("delete")) } if (o < e) { r = r.concat(Array(e - o).fill("equal")) } return r } function y(t, e, n) { n = n || function (t, e) { return t === e }; const i = t.length; const o = e.length; if (i > 200 || o > 200 || i + o > 300) { return y.fastDiff(t, e, n, true) } let r, s; if (o < i) { const n = t; t = e; e = n; r = "delete"; s = "insert" } else { r = "insert"; s = "delete" } const a = t.length; const c = e.length; const l = c - a; const d = {}; const u = {}; function h(i) { const o = (u[i - 1] !== undefined ? u[i - 1] : -1) + 1; const l = u[i + 1] !== undefined ? u[i + 1] : -1; const h = o > l ? -1 : 1; if (d[i + h]) { d[i] = d[i + h].slice(0) } if (!d[i]) { d[i] = [] } d[i].push(o > l ? r : s); let f = Math.max(o, l); let g = f - i; while (g < a && f < c && n(t[g], e[f])) { g++; f++; d[i].push("equal") } return f } let f = 0; let g; do { for (g = -f; g < l; g++) { u[g] = h(g) } for (g = l + f; g > l; g--) { u[g] = h(g) } u[l] = h(l); f++ } while (u[l] !== c); return d[l].slice(1) } y.fastDiff = b; function x() { return function t() { t.called = true } } const E = x; class D { constructor(t, e) { this.source = t; this.name = e; this.path = []; this.stop = E(); this.off = E() } } const I = new Array(256).fill("").map(((t, e) => ("0" + e.toString(16)).slice(-2))); function T() { const t = Math.random() * 4294967296 >>> 0; const e = Math.random() * 4294967296 >>> 0; const n = Math.random() * 4294967296 >>> 0; const i = Math.random() * 4294967296 >>> 0; return "e" + I[t >> 0 & 255] + I[t >> 8 & 255] + I[t >> 16 & 255] + I[t >> 24 & 255] + I[e >> 0 & 255] + I[e >> 8 & 255] + I[e >> 16 & 255] + I[e >> 24 & 255] + I[n >> 0 & 255] + I[n >> 8 & 255] + I[n >> 16 & 255] + I[n >> 24 & 255] + I[i >> 0 & 255] + I[i >> 8 & 255] + I[i >> 16 & 255] + I[i >> 24 & 255] } const M = { get(t = "normal") { if (typeof t != "number") { return this[t] || this.normal } else { return t } }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 }; const S = M; function N(t, e) { const n = S.get(e.priority); for (let i = 0; i < t.length; i++) { if (S.get(t[i].priority) < n) { t.splice(i, 0, e); return } } t.push(e) } const B = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html"; class z extends Error { constructor(t, e, n) { super(R(t, n)); this.name = "CKEditorError"; this.context = e; this.data = n } is(t) { return t === "CKEditorError" } static rethrowUnexpectedError(t, e) { if (t.is && t.is("CKEditorError")) { throw t } const n = new z(t.message, e); n.stack = t.stack; throw n } } function P(t, e) { console.warn(...j(t, e)) } function L(t, e) { console.error(...j(t, e)) } function O(t) { return `\nRead more: ${B}#error-${t}` } function R(t, e) { const n = new WeakSet; const i = (t, e) => { if (typeof e === "object" && e !== null) { if (n.has(e)) { return `[object ${e.constructor.name}]` } n.add(e) } return e }; const o = e ? ` ${JSON.stringify(e, i)}` : ""; const r = O(t); return t + o + r } function j(t, e) { const n = O(t); return e ? [t, e, n] : [t, n] } const V = "37.1.0"; const F = null && V; const H = typeof window === "object" ? window : n.g; if (H.CKEDITOR_VERSION) { throw new z("ckeditor-duplicated-modules", null) } else { H.CKEDITOR_VERSION = V } const U = Symbol("listeningTo"); const W = Symbol("emitterId"); const G = Symbol("delegations"); const q = Y(Object); function Y(t) { if (!t) { return q } class e extends t { on(t, e, n) { this.listenTo(this, t, e, n) } once(t, e, n) { let i = false; const o = (t, ...n) => { if (!i) { i = true; t.off(); e.call(this, t, ...n) } }; this.listenTo(this, t, o, n) } off(t, e) { this.stopListening(this, t, e) } listenTo(t, e, n, i = {}) { let o, r; if (!this[U]) { this[U] = {} } const s = this[U]; if (!K(t)) { Q(t) } const a = K(t); if (!(o = s[a])) { o = s[a] = { emitter: t, callbacks: {} } } if (!(r = o.callbacks[e])) { r = o.callbacks[e] = [] } r.push(n); it(this, t, e, n, i) } stopListening(t, e, n) { const i = this[U]; let o = t && K(t); const r = i && o ? i[o] : undefined; const s = r && e ? r.callbacks[e] : undefined; if (!i || t && !r || e && !s) { return } if (n) { ot(this, t, e, n); const i = s.indexOf(n); if (i !== -1) { if (s.length === 1) { delete r.callbacks[e] } else { ot(this, t, e, n) } } } else if (s) { while (n = s.pop()) { ot(this, t, e, n) } delete r.callbacks[e] } else if (r) { for (e in r.callbacks) { this.stopListening(t, e) } delete i[o] } else { for (o in i) { this.stopListening(i[o].emitter) } delete this[U] } } fire(t, ...e) { try { const n = t instanceof D ? t : new D(this, t); const i = n.name; let o = et(this, i); n.path.push(this); if (o) { const t = [n, ...e]; o = Array.from(o); for (let e = 0; e < o.length; e++) { o[e].callback.apply(this, t); if (n.off.called) { delete n.off.called; this._removeEventListener(i, o[e].callback) } if (n.stop.called) { break } } } const r = this[G]; if (r) { const t = r.get(i); const o = r.get("*"); if (t) { nt(t, n, e) } if (o) { nt(o, n, e) } } return n.return } catch (t) { z.rethrowUnexpectedError(t, this) } } delegate(...t) { return { to: (e, n) => { if (!this[G]) { this[G] = new Map } t.forEach((t => { const i = this[G].get(t); if (!i) { this[G].set(t, new Map([[e, n]])) } else { i.set(e, n) } })) } } } stopDelegating(t, e) { if (!this[G]) { return } if (!t) { this[G].clear() } else if (!e) { this[G].delete(t) } else { const n = this[G].get(t); if (n) { n.delete(e) } } } _addEventListener(t, e, n) { X(this, t); const i = tt(this, t); const o = S.get(n.priority); const r = { callback: e, priority: o }; for (const t of i) { N(t, r) } } _removeEventListener(t, e) { const n = tt(this, t); for (const t of n) { for (let n = 0; n < t.length; n++) { if (t[n].callback == e) { t.splice(n, 1); n-- } } } } } return e } ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => { Y[t] = q.prototype[t] })); function $(t, e) { const n = t[U]; if (n && n[e]) { return n[e].emitter } return null } function Q(t, e) { if (!t[W]) { t[W] = e || T() } } function K(t) { return t[W] } function Z(t) { if (!t._events) { Object.defineProperty(t, "_events", { value: {} }) } return t._events } function J() { return { callbacks: [], childEvents: [] } } function X(t, e) { const n = Z(t); if (n[e]) { return } let i = e; let o = null; const r = []; while (i !== "") { if (n[i]) { break } n[i] = J(); r.push(n[i]); if (o) { n[i].childEvents.push(o) } o = i; i = i.substr(0, i.lastIndexOf(":")) } if (i !== "") { for (const t of r) { t.callbacks = n[i].callbacks.slice() } n[i].childEvents.push(o) } } function tt(t, e) { const n = Z(t)[e]; if (!n) { return [] } let i = [n.callbacks]; for (let e = 0; e < n.childEvents.length; e++) { const o = tt(t, n.childEvents[e]); i = i.concat(o) } return i } function et(t, e) { let n; if (!t._events || !(n = t._events[e]) || !n.callbacks.length) { if (e.indexOf(":") > -1) { return et(t, e.substr(0, e.lastIndexOf(":"))) } else { return null } } return n.callbacks } function nt(t, e, n) { for (let [i, o] of t) { if (!o) { o = e.name } else if (typeof o == "function") { o = o(e.name) } const t = new D(e.source, o); t.path = [...e.path]; i.fire(t, ...n) } } function it(t, e, n, i, o) { if (e._addEventListener) { e._addEventListener(n, i, o) } else { t._addEventListener.call(e, n, i, o) } } function ot(t, e, n, i) { if (e._removeEventListener) { e._removeEventListener(n, i) } else { t._removeEventListener.call(e, n, i) } } function rt(t) { var e = typeof t; return t != null && (e == "object" || e == "function") } const st = rt; const at = Symbol("observableProperties"); const ct = Symbol("boundObservables"); const lt = Symbol("boundProperties"); const dt = Symbol("decoratedMethods"); const ut = Symbol("decoratedOriginal"); const ht = ft(Y()); function ft(t) { if (!t) { return ht } class e extends t { set(t, e) { if (st(t)) { Object.keys(t).forEach((e => { this.set(e, t[e]) }), this); return } gt(this); const n = this[at]; if (t in this && !n.has(t)) { throw new z("observable-set-cannot-override", this) } Object.defineProperty(this, t, { enumerable: true, configurable: true, get() { return n.get(t) }, set(e) { const i = n.get(t); let o = this.fire(`set:${t}`, t, e, i); if (o === undefined) { o = e } if (i !== o || !n.has(t)) { n.set(t, o); this.fire(`change:${t}`, t, o, i) } } }); this[t] = e } bind(...t) { if (!t.length || !bt(t)) { throw new z("observable-bind-wrong-properties", this) } if (new Set(t).size !== t.length) { throw new z("observable-bind-duplicate-properties", this) } gt(this); const e = this[lt]; t.forEach((t => { if (e.has(t)) { throw new z("observable-bind-rebind", this) } })); const n = new Map; t.forEach((t => { const i = { property: t, to: [] }; e.set(t, i); n.set(t, i) })); return { to: mt, toMany: pt, _observable: this, _bindProperties: t, _to: [], _bindings: n } } unbind(...t) { if (!this[at]) { return } const e = this[lt]; const n = this[ct]; if (t.length) { if (!bt(t)) { throw new z("observable-unbind-wrong-properties", this) } t.forEach((t => { const i = e.get(t); if (!i) { return } i.to.forEach((([t, e]) => { const o = n.get(t); const r = o[e]; r.delete(i); if (!r.size) { delete o[e] } if (!Object.keys(o).length) { n.delete(t); this.stopListening(t, "change") } })); e.delete(t) })) } else { n.forEach(((t, e) => { this.stopListening(e, "change") })); n.clear(); e.clear() } } decorate(t) { gt(this); const e = this[t]; if (!e) { throw new z("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: t }) } this.on(t, ((t, n) => { t.return = e.apply(this, n) })); this[t] = function (...e) { return this.fire(t, e) }; this[t][ut] = e; if (!this[dt]) { this[dt] = [] } this[dt].push(t) } stopListening(t, e, n) { if (!t && this[dt]) { for (const t of this[dt]) { this[t] = this[t][ut] } delete this[dt] } super.stopListening(t, e, n) } } return e } ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => { ft[t] = ht.prototype[t] })); function gt(t) { if (t[at]) { return } Object.defineProperty(t, at, { value: new Map }); Object.defineProperty(t, ct, { value: new Map }); Object.defineProperty(t, lt, { value: new Map }) } function mt(...t) { const e = wt(...t); const n = Array.from(this._bindings.keys()); const i = n.length; if (!e.callback && e.to.length > 1) { throw new z("observable-bind-to-no-callback", this) } if (i > 1 && e.callback) { throw new z("observable-bind-to-extra-callback", this) } e.to.forEach((t => { if (t.properties.length && t.properties.length !== i) { throw new z("observable-bind-to-properties-length", this) } if (!t.properties.length) { t.properties = this._bindProperties } })); this._to = e.to; if (e.callback) { this._bindings.get(n[0]).callback = e.callback } vt(this._observable, this._to); At(this); this._bindProperties.forEach((t => { Ct(this._observable, t) })) } function pt(t, e, n) { if (this._bindings.size > 1) { throw new z("observable-bind-to-many-not-one-binding", this) } this.to(...kt(t, e), n) } function kt(t, e) { const n = t.map((t => [t, e])); return Array.prototype.concat.apply([], n) } function bt(t) { return t.every((t => typeof t == "string")) } function wt(...t) { if (!t.length) { throw new z("observable-bind-to-parse-error", null) } const e = { to: [] }; let n; if (typeof t[t.length - 1] == "function") { e.callback = t.pop() } t.forEach((t => { if (typeof t == "string") { n.properties.push(t) } else if (typeof t == "object") { n = { observable: t, properties: [] }; e.to.push(n) } else { throw new z("observable-bind-to-parse-error", null) } })); return e } function _t(t, e, n, i) { const o = t[ct]; const r = o.get(n); const s = r || {}; if (!s[i]) { s[i] = new Set } s[i].add(e); if (!r) { o.set(n, s) } } function At(t) { let e; t._bindings.forEach(((n, i) => { t._to.forEach((o => { e = o.properties[n.callback ? 0 : t._bindProperties.indexOf(i)]; n.to.push([o.observable, e]); _t(t._observable, n, o.observable, e) })) })) } function Ct(t, e) { const n = t[lt]; const i = n.get(e); let o; if (i.callback) { o = i.callback.apply(t, i.to.map((t => t[0][t[1]]))) } else { o = i.to[0]; o = o[0][o[1]] } if (Object.prototype.hasOwnProperty.call(t, e)) { t[e] = o } else { t.set(e, o) } } function vt(t, e) { e.forEach((e => { const n = t[ct]; let i; if (!n.get(e.observable)) { t.listenTo(e.observable, "change", ((o, r) => { i = n.get(e.observable)[r]; if (i) { i.forEach((e => { Ct(t, e.property) })) } })) } })) } class yt { constructor() { this._replacedElements = [] } replace(t, e) { this._replacedElements.push({ element: t, newElement: e }); t.style.display = "none"; if (e) { t.parentNode.insertBefore(e, t.nextSibling) } } restore() { this._replacedElements.forEach((({ element: t, newElement: e }) => { t.style.display = ""; if (e) { e.remove() } })); this._replacedElements = [] } } function xt(t) { let e = 0; for (const n of t) { e++ } return e } function Et(t, e) { const n = Math.min(t.length, e.length); for (let i = 0; i < n; i++) { if (t[i] != e[i]) { return i } } if (t.length == e.length) { return "same" } else if (t.length < e.length) { return "prefix" } else { return "extension" } } function Dt(t) { return !!(t && t[Symbol.iterator]) } var It = typeof global == "object" && global && global.Object === Object && global; const Tt = It; var Mt = typeof self == "object" && self && self.Object === Object && self; var St = Tt || Mt || Function("return this")(); const Nt = St; var Bt = Nt.Symbol; const zt = Bt; var Pt = Object.prototype; var Lt = Pt.hasOwnProperty; var Ot = Pt.toString; var Rt = zt ? zt.toStringTag : undefined; function jt(t) { var e = Lt.call(t, Rt), n = t[Rt]; try { t[Rt] = undefined; var i = true } catch (t) { } var o = Ot.call(t); if (i) { if (e) { t[Rt] = n } else { delete t[Rt] } } return o } const Vt = jt; var Ft = Object.prototype; var Ht = Ft.toString; function Ut(t) { return Ht.call(t) } const Wt = Ut; var Gt = "[object Null]", qt = "[object Undefined]"; var Yt = zt ? zt.toStringTag : undefined; function $t(t) { if (t == null) { return t === undefined ? qt : Gt } return Yt && Yt in Object(t) ? Vt(t) : Wt(t) } const Qt = $t; var Kt = Array.isArray; const Zt = Kt; function Jt(t) { return t != null && typeof t == "object" } const Xt = Jt; var te = "[object String]"; function ee(t) { return typeof t == "string" || !Zt(t) && Xt(t) && Qt(t) == te } const ne = ee; function ie(t, e, n = {}, i = []) { const o = n && n.xmlns; const r = o ? t.createElementNS(o, e) : t.createElement(e); for (const t in n) { r.setAttribute(t, n[t]) } if (ne(i) || !Dt(i)) { i = [i] } for (let e of i) { if (ne(e)) { e = t.createTextNode(e) } r.appendChild(e) } return r } function oe(t, e) { return function (n) { return t(e(n)) } } const re = oe; var se = re(Object.getPrototypeOf, Object); const ae = se; var ce = "[object Object]"; var le = Function.prototype, de = Object.prototype; var ue = le.toString; var he = de.hasOwnProperty; var fe = ue.call(Object); function ge(t) { if (!Xt(t) || Qt(t) != ce) { return false } var e = ae(t); if (e === null) { return true } var n = he.call(e, "constructor") && e.constructor; return typeof n == "function" && n instanceof n && ue.call(n) == fe } const me = ge; function pe() { this.__data__ = []; this.size = 0 } const ke = pe; function be(t, e) { return t === e || t !== t && e !== e } const we = be; function _e(t, e) { var n = t.length; while (n--) { if (we(t[n][0], e)) { return n } } return -1 } const Ae = _e; var Ce = Array.prototype; var ve = Ce.splice; function ye(t) { var e = this.__data__, n = Ae(e, t); if (n < 0) { return false } var i = e.length - 1; if (n == i) { e.pop() } else { ve.call(e, n, 1) } --this.size; return true } const xe = ye; function Ee(t) { var e = this.__data__, n = Ae(e, t); return n < 0 ? undefined : e[n][1] } const De = Ee; function Ie(t) { return Ae(this.__data__, t) > -1 } const Te = Ie; function Me(t, e) { var n = this.__data__, i = Ae(n, t); if (i < 0) { ++this.size; n.push([t, e]) } else { n[i][1] = e } return this } const Se = Me; function Ne(t) { var e = -1, n = t == null ? 0 : t.length; this.clear(); while (++e < n) { var i = t[e]; this.set(i[0], i[1]) } } Ne.prototype.clear = ke; Ne.prototype["delete"] = xe; Ne.prototype.get = De; Ne.prototype.has = Te; Ne.prototype.set = Se; const Be = Ne; function ze() { this.__data__ = new Be; this.size = 0 } const Pe = ze; function Le(t) { var e = this.__data__, n = e["delete"](t); this.size = e.size; return n } const Oe = Le; function Re(t) { return this.__data__.get(t) } const je = Re; function Ve(t) { return this.__data__.has(t) } const Fe = Ve; var He = "[object AsyncFunction]", Ue = "[object Function]", We = "[object GeneratorFunction]", Ge = "[object Proxy]"; function qe(t) { if (!st(t)) { return false } var e = Qt(t); return e == Ue || e == We || e == He || e == Ge } const Ye = qe; var $e = Nt["__core-js_shared__"]; const Qe = $e; var Ke = function () { var t = /[^.]+$/.exec(Qe && Qe.keys && Qe.keys.IE_PROTO || ""); return t ? "Symbol(src)_1." + t : "" }(); function Ze(t) { return !!Ke && Ke in t } const Je = Ze; var Xe = Function.prototype; var tn = Xe.toString; function en(t) { if (t != null) { try { return tn.call(t) } catch (t) { } try { return t + "" } catch (t) { } } return "" } const nn = en; var on = /[\\^$.*+?()[\]{}|]/g; var rn = /^\[object .+?Constructor\]$/; var sn = Function.prototype, an = Object.prototype; var cn = sn.toString; var ln = an.hasOwnProperty; var dn = RegExp("^" + cn.call(ln).replace(on, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function un(t) { if (!st(t) || Je(t)) { return false } var e = Ye(t) ? dn : rn; return e.test(nn(t)) } const hn = un; function fn(t, e) { return t == null ? undefined : t[e] } const gn = fn; function mn(t, e) { var n = gn(t, e); return hn(n) ? n : undefined } const pn = mn; var kn = pn(Nt, "Map"); const bn = kn; var wn = pn(Object, "create"); const _n = wn; function An() { this.__data__ = _n ? _n(null) : {}; this.size = 0 } const Cn = An; function vn(t) { var e = this.has(t) && delete this.__data__[t]; this.size -= e ? 1 : 0; return e } const yn = vn; var xn = "__lodash_hash_undefined__"; var En = Object.prototype; var Dn = En.hasOwnProperty; function In(t) { var e = this.__data__; if (_n) { var n = e[t]; return n === xn ? undefined : n } return Dn.call(e, t) ? e[t] : undefined } const Tn = In; var Mn = Object.prototype; var Sn = Mn.hasOwnProperty; function Nn(t) { var e = this.__data__; return _n ? e[t] !== undefined : Sn.call(e, t) } const Bn = Nn; var zn = "__lodash_hash_undefined__"; function Pn(t, e) { var n = this.__data__; this.size += this.has(t) ? 0 : 1; n[t] = _n && e === undefined ? zn : e; return this } const Ln = Pn; function On(t) { var e = -1, n = t == null ? 0 : t.length; this.clear(); while (++e < n) { var i = t[e]; this.set(i[0], i[1]) } } On.prototype.clear = Cn; On.prototype["delete"] = yn; On.prototype.get = Tn; On.prototype.has = Bn; On.prototype.set = Ln; const Rn = On; function jn() { this.size = 0; this.__data__ = { hash: new Rn, map: new (bn || Be), string: new Rn } } const Vn = jn; function Fn(t) { var e = typeof t; return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null } const Hn = Fn; function Un(t, e) { var n = t.__data__; return Hn(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map } const Wn = Un; function Gn(t) { var e = Wn(this, t)["delete"](t); this.size -= e ? 1 : 0; return e } const qn = Gn; function Yn(t) { return Wn(this, t).get(t) } const $n = Yn; function Qn(t) { return Wn(this, t).has(t) } const Kn = Qn; function Zn(t, e) { var n = Wn(this, t), i = n.size; n.set(t, e); this.size += n.size == i ? 0 : 1; return this } const Jn = Zn; function Xn(t) { var e = -1, n = t == null ? 0 : t.length; this.clear(); while (++e < n) { var i = t[e]; this.set(i[0], i[1]) } } Xn.prototype.clear = Vn; Xn.prototype["delete"] = qn; Xn.prototype.get = $n; Xn.prototype.has = Kn; Xn.prototype.set = Jn; const ti = Xn; var ei = 200; function ni(t, e) { var n = this.__data__; if (n instanceof Be) { var i = n.__data__; if (!bn || i.length < ei - 1) { i.push([t, e]); this.size = ++n.size; return this } n = this.__data__ = new ti(i) } n.set(t, e); this.size = n.size; return this } const ii = ni; function oi(t) { var e = this.__data__ = new Be(t); this.size = e.size } oi.prototype.clear = Pe; oi.prototype["delete"] = Oe; oi.prototype.get = je; oi.prototype.has = Fe; oi.prototype.set = ii; const ri = oi; function si(t, e) { var n = -1, i = t == null ? 0 : t.length; while (++n < i) { if (e(t[n], n, t) === false) { break } } return t } const ai = si; var ci = function () { try { var t = pn(Object, "defineProperty"); t({}, "", {}); return t } catch (t) { } }(); const li = ci; function di(t, e, n) { if (e == "__proto__" && li) { li(t, e, { configurable: true, enumerable: true, value: n, writable: true }) } else { t[e] = n } } const ui = di; var hi = Object.prototype; var fi = hi.hasOwnProperty; function gi(t, e, n) { var i = t[e]; if (!(fi.call(t, e) && we(i, n)) || n === undefined && !(e in t)) { ui(t, e, n) } } const mi = gi; function pi(t, e, n, i) { var o = !n; n || (n = {}); var r = -1, s = e.length; while (++r < s) { var a = e[r]; var c = i ? i(n[a], t[a], a, n, t) : undefined; if (c === undefined) { c = t[a] } if (o) { ui(n, a, c) } else { mi(n, a, c) } } return n } const ki = pi; function bi(t, e) { var n = -1, i = Array(t); while (++n < t) { i[n] = e(n) } return i } const wi = bi; var _i = "[object Arguments]"; function Ai(t) { return Xt(t) && Qt(t) == _i } const Ci = Ai; var vi = Object.prototype; var yi = vi.hasOwnProperty; var xi = vi.propertyIsEnumerable; var Ei = Ci(function () { return arguments }()) ? Ci : function (t) { return Xt(t) && yi.call(t, "callee") && !xi.call(t, "callee") }; const Di = Ei; function Ii() { return false } const Ti = Ii; var Mi = typeof exports == "object" && exports && !exports.nodeType && exports; var Si = Mi && typeof module == "object" && module && !module.nodeType && module; var Ni = Si && Si.exports === Mi; var Bi = Ni ? Nt.Buffer : undefined; var zi = Bi ? Bi.isBuffer : undefined; var Pi = zi || Ti; const Li = Pi; var Oi = 9007199254740991; var Ri = /^(?:0|[1-9]\d*)$/; function ji(t, e) { var n = typeof t; e = e == null ? Oi : e; return !!e && (n == "number" || n != "symbol" && Ri.test(t)) && (t > -1 && t % 1 == 0 && t < e) } const Vi = ji; var Fi = 9007199254740991; function Hi(t) { return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Fi } const Ui = Hi; var Wi = "[object Arguments]", Gi = "[object Array]", qi = "[object Boolean]", Yi = "[object Date]", $i = "[object Error]", Qi = "[object Function]", Ki = "[object Map]", Zi = "[object Number]", Ji = "[object Object]", Xi = "[object RegExp]", to = "[object Set]", eo = "[object String]", no = "[object WeakMap]"; var io = "[object ArrayBuffer]", oo = "[object DataView]", ro = "[object Float32Array]", so = "[object Float64Array]", ao = "[object Int8Array]", co = "[object Int16Array]", lo = "[object Int32Array]", uo = "[object Uint8Array]", ho = "[object Uint8ClampedArray]", fo = "[object Uint16Array]", go = "[object Uint32Array]"; var mo = {}; mo[ro] = mo[so] = mo[ao] = mo[co] = mo[lo] = mo[uo] = mo[ho] = mo[fo] = mo[go] = true; mo[Wi] = mo[Gi] = mo[io] = mo[qi] = mo[oo] = mo[Yi] = mo[$i] = mo[Qi] = mo[Ki] = mo[Zi] = mo[Ji] = mo[Xi] = mo[to] = mo[eo] = mo[no] = false; function po(t) { return Xt(t) && Ui(t.length) && !!mo[Qt(t)] } const ko = po; function bo(t) { return function (e) { return t(e) } } const wo = bo; var _o = typeof exports == "object" && exports && !exports.nodeType && exports; var Ao = _o && typeof module == "object" && module && !module.nodeType && module; var Co = Ao && Ao.exports === _o; var vo = Co && Tt.process; var yo = function () { try { var t = Ao && Ao.require && Ao.require("util").types; if (t) { return t } return vo && vo.binding && vo.binding("util") } catch (t) { } }(); const xo = yo; var Eo = xo && xo.isTypedArray; var Do = Eo ? wo(Eo) : ko; const Io = Do; var To = Object.prototype; var Mo = To.hasOwnProperty; function So(t, e) { var n = Zt(t), i = !n && Di(t), o = !n && !i && Li(t), r = !n && !i && !o && Io(t), s = n || i || o || r, a = s ? wi(t.length, String) : [], c = a.length; for (var l in t) { if ((e || Mo.call(t, l)) && !(s && (l == "length" || o && (l == "offset" || l == "parent") || r && (l == "buffer" || l == "byteLength" || l == "byteOffset") || Vi(l, c)))) { a.push(l) } } return a } const No = So; var Bo = Object.prototype; function zo(t) { var e = t && t.constructor, n = typeof e == "function" && e.prototype || Bo; return t === n } const Po = zo; var Lo = re(Object.keys, Object); const Oo = Lo; var Ro = Object.prototype; var jo = Ro.hasOwnProperty; function Vo(t) { if (!Po(t)) { return Oo(t) } var e = []; for (var n in Object(t)) { if (jo.call(t, n) && n != "constructor") { e.push(n) } } return e } const Fo = Vo; function Ho(t) { return t != null && Ui(t.length) && !Ye(t) } const Uo = Ho; function Wo(t) { return Uo(t) ? No(t) : Fo(t) } const Go = Wo; function qo(t, e) { return t && ki(e, Go(e), t) } const Yo = qo; function $o(t) { var e = []; if (t != null) { for (var n in Object(t)) { e.push(n) } } return e } const Qo = $o; var Ko = Object.prototype; var Zo = Ko.hasOwnProperty; function Jo(t) { if (!st(t)) { return Qo(t) } var e = Po(t), n = []; for (var i in t) { if (!(i == "constructor" && (e || !Zo.call(t, i)))) { n.push(i) } } return n } const Xo = Jo; function tr(t) { return Uo(t) ? No(t, true) : Xo(t) } const er = tr; function nr(t, e) { return t && ki(e, er(e), t) } const ir = nr; var or = typeof exports == "object" && exports && !exports.nodeType && exports; var rr = or && typeof module == "object" && module && !module.nodeType && module; var sr = rr && rr.exports === or; var ar = sr ? Nt.Buffer : undefined, cr = ar ? ar.allocUnsafe : undefined; function lr(t, e) { if (e) { return t.slice() } var n = t.length, i = cr ? cr(n) : new t.constructor(n); t.copy(i); return i } const dr = lr; function ur(t, e) { var n = -1, i = t.length; e || (e = Array(i)); while (++n < i) { e[n] = t[n] } return e } const hr = ur; function fr(t, e) { var n = -1, i = t == null ? 0 : t.length, o = 0, r = []; while (++n < i) { var s = t[n]; if (e(s, n, t)) { r[o++] = s } } return r } const gr = fr; function mr() { return [] } const pr = mr; var kr = Object.prototype; var br = kr.propertyIsEnumerable; var wr = Object.getOwnPropertySymbols; var _r = !wr ? pr : function (t) { if (t == null) { return [] } t = Object(t); return gr(wr(t), (function (e) { return br.call(t, e) })) }; const Ar = _r; function Cr(t, e) { return ki(t, Ar(t), e) } const vr = Cr; function yr(t, e) { var n = -1, i = e.length, o = t.length; while (++n < i) { t[o + n] = e[n] } return t } const xr = yr; var Er = Object.getOwnPropertySymbols; var Dr = !Er ? pr : function (t) { var e = []; while (t) { xr(e, Ar(t)); t = ae(t) } return e }; const Ir = Dr; function Tr(t, e) { return ki(t, Ir(t), e) } const Mr = Tr; function Sr(t, e, n) { var i = e(t); return Zt(t) ? i : xr(i, n(t)) } const Nr = Sr; function Br(t) { return Nr(t, Go, Ar) } const zr = Br; function Pr(t) { return Nr(t, er, Ir) } const Lr = Pr; var Or = pn(Nt, "DataView"); const Rr = Or; var jr = pn(Nt, "Promise"); const Vr = jr; var Fr = pn(Nt, "Set"); const Hr = Fr; var Ur = pn(Nt, "WeakMap"); const Wr = Ur; var Gr = "[object Map]", qr = "[object Object]", Yr = "[object Promise]", $r = "[object Set]", Qr = "[object WeakMap]"; var Kr = "[object DataView]"; var Zr = nn(Rr), Jr = nn(bn), Xr = nn(Vr), ts = nn(Hr), es = nn(Wr); var ns = Qt; if (Rr && ns(new Rr(new ArrayBuffer(1))) != Kr || bn && ns(new bn) != Gr || Vr && ns(Vr.resolve()) != Yr || Hr && ns(new Hr) != $r || Wr && ns(new Wr) != Qr) { ns = function (t) { var e = Qt(t), n = e == qr ? t.constructor : undefined, i = n ? nn(n) : ""; if (i) { switch (i) { case Zr: return Kr; case Jr: return Gr; case Xr: return Yr; case ts: return $r; case es: return Qr } } return e } } const is = ns; var os = Object.prototype; var rs = os.hasOwnProperty; function ss(t) { var e = t.length, n = new t.constructor(e); if (e && typeof t[0] == "string" && rs.call(t, "index")) { n.index = t.index; n.input = t.input } return n } const as = ss; var cs = Nt.Uint8Array; const ls = cs; function ds(t) { var e = new t.constructor(t.byteLength); new ls(e).set(new ls(t)); return e } const us = ds; function hs(t, e) { var n = e ? us(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.byteLength) } const fs = hs; var gs = /\w*$/; function ms(t) { var e = new t.constructor(t.source, gs.exec(t)); e.lastIndex = t.lastIndex; return e } const ps = ms; var ks = zt ? zt.prototype : undefined, bs = ks ? ks.valueOf : undefined; function ws(t) { return bs ? Object(bs.call(t)) : {} } const _s = ws; function As(t, e) { var n = e ? us(t.buffer) : t.buffer; return new t.constructor(n, t.byteOffset, t.length) } const Cs = As; var vs = "[object Boolean]", ys = "[object Date]", xs = "[object Map]", Es = "[object Number]", Ds = "[object RegExp]", Is = "[object Set]", Ts = "[object String]", Ms = "[object Symbol]"; var Ss = "[object ArrayBuffer]", Ns = "[object DataView]", Bs = "[object Float32Array]", zs = "[object Float64Array]", Ps = "[object Int8Array]", Ls = "[object Int16Array]", Os = "[object Int32Array]", Rs = "[object Uint8Array]", js = "[object Uint8ClampedArray]", Vs = "[object Uint16Array]", Fs = "[object Uint32Array]"; function Hs(t, e, n) { var i = t.constructor; switch (e) { case Ss: return us(t); case vs: case ys: return new i(+t); case Ns: return fs(t, n); case Bs: case zs: case Ps: case Ls: case Os: case Rs: case js: case Vs: case Fs: return Cs(t, n); case xs: return new i; case Es: case Ts: return new i(t); case Ds: return ps(t); case Is: return new i; case Ms: return _s(t) } } const Us = Hs; var Ws = Object.create; var Gs = function () { function t() { } return function (e) { if (!st(e)) { return {} } if (Ws) { return Ws(e) } t.prototype = e; var n = new t; t.prototype = undefined; return n } }(); const qs = Gs; function Ys(t) { return typeof t.constructor == "function" && !Po(t) ? qs(ae(t)) : {} } const $s = Ys; var Qs = "[object Map]"; function Ks(t) { return Xt(t) && is(t) == Qs } const Zs = Ks; var Js = xo && xo.isMap; var Xs = Js ? wo(Js) : Zs; const ta = Xs; var ea = "[object Set]"; function na(t) { return Xt(t) && is(t) == ea } const ia = na; var oa = xo && xo.isSet; var ra = oa ? wo(oa) : ia; const sa = ra; var aa = 1, ca = 2, la = 4; var da = "[object Arguments]", ua = "[object Array]", ha = "[object Boolean]", fa = "[object Date]", ga = "[object Error]", ma = "[object Function]", pa = "[object GeneratorFunction]", ka = "[object Map]", ba = "[object Number]", wa = "[object Object]", _a = "[object RegExp]", Aa = "[object Set]", Ca = "[object String]", va = "[object Symbol]", ya = "[object WeakMap]"; var xa = "[object ArrayBuffer]", Ea = "[object DataView]", Da = "[object Float32Array]", Ia = "[object Float64Array]", Ta = "[object Int8Array]", Ma = "[object Int16Array]", Sa = "[object Int32Array]", Na = "[object Uint8Array]", Ba = "[object Uint8ClampedArray]", za = "[object Uint16Array]", Pa = "[object Uint32Array]"; var La = {}; La[da] = La[ua] = La[xa] = La[Ea] = La[ha] = La[fa] = La[Da] = La[Ia] = La[Ta] = La[Ma] = La[Sa] = La[ka] = La[ba] = La[wa] = La[_a] = La[Aa] = La[Ca] = La[va] = La[Na] = La[Ba] = La[za] = La[Pa] = true; La[ga] = La[ma] = La[ya] = false; function Oa(t, e, n, i, o, r) { var s, a = e & aa, c = e & ca, l = e & la; if (n) { s = o ? n(t, i, o, r) : n(t) } if (s !== undefined) { return s } if (!st(t)) { return t } var d = Zt(t); if (d) { s = as(t); if (!a) { return hr(t, s) } } else { var u = is(t), h = u == ma || u == pa; if (Li(t)) { return dr(t, a) } if (u == wa || u == da || h && !o) { s = c || h ? {} : $s(t); if (!a) { return c ? Mr(t, ir(s, t)) : vr(t, Yo(s, t)) } } else { if (!La[u]) { return o ? t : {} } s = Us(t, u, a) } } r || (r = new ri); var f = r.get(t); if (f) { return f } r.set(t, s); if (sa(t)) { t.forEach((function (i) { s.add(Oa(i, e, n, i, t, r)) })) } else if (ta(t)) { t.forEach((function (i, o) { s.set(o, Oa(i, e, n, o, t, r)) })) } var g = l ? c ? Lr : zr : c ? er : Go; var m = d ? undefined : g(t); ai(m || t, (function (i, o) { if (m) { o = i; i = t[o] } mi(s, o, Oa(i, e, n, o, t, r)) })); return s } const Ra = Oa; var ja = 1, Va = 4; function Fa(t, e) { e = typeof e == "function" ? e : undefined; return Ra(t, ja | Va, e) } const Ha = Fa; function Ua(t) { return Xt(t) && t.nodeType === 1 && !me(t) } const Wa = Ua; class Ga { constructor(t, e) { this._config = {}; if (e) { this.define(qa(e)) } if (t) { this._setObjectToTarget(this._config, t) } } set(t, e) { this._setToTarget(this._config, t, e) } define(t, e) { const n = true; this._setToTarget(this._config, t, e, n) } get(t) { return this._getFromSource(this._config, t) } *names() { for (const t of Object.keys(this._config)) { yield t } } _setToTarget(t, e, n, i = false) { if (me(e)) { this._setObjectToTarget(t, e, i); return } const o = e.split("."); e = o.pop(); for (const e of o) { if (!me(t[e])) { t[e] = {} } t = t[e] } if (me(n)) { if (!me(t[e])) { t[e] = {} } t = t[e]; this._setObjectToTarget(t, n, i); return } if (i && typeof t[e] != "undefined") { return } t[e] = n } _getFromSource(t, e) { const n = e.split("."); e = n.pop(); for (const e of n) { if (!me(t[e])) { t = null; break } t = t[e] } return t ? qa(t[e]) : undefined } _setObjectToTarget(t, e, n) { Object.keys(e).forEach((i => { this._setToTarget(t, i, e[i], n) })) } } function qa(t) { return Ha(t, Ya) } function Ya(t) { return Wa(t) ? t : undefined } function $a(t) { if (t) { if (t.defaultView) { return t instanceof t.defaultView.Document } else if (t.ownerDocument && t.ownerDocument.defaultView) { return t instanceof t.ownerDocument.defaultView.Node } } return false } function Qa(t) { const e = Object.prototype.toString.apply(t); if (e == "[object Window]") { return true } if (e == "[object global]") { return true } return false } const Ka = Za(Y()); function Za(t) { if (!t) { return Ka } class e extends t { listenTo(t, e, n, i = {}) { if ($a(t) || Qa(t)) { const o = { capture: !!i.useCapture, passive: !!i.usePassive }; const r = this._getProxyEmitter(t, o) || new Ja(t, o); this.listenTo(r, e, n, i) } else { super.listenTo(t, e, n, i) } } stopListening(t, e, n) { if ($a(t) || Qa(t)) { const i = this._getAllProxyEmitters(t); for (const t of i) { this.stopListening(t, e, n) } } else { super.stopListening(t, e, n) } } _getProxyEmitter(t, e) { return $(this, tc(t, e)) } _getAllProxyEmitters(t) { return [{ capture: false, passive: false }, { capture: false, passive: true }, { capture: true, passive: false }, { capture: true, passive: true }].map((e => this._getProxyEmitter(t, e))).filter((t => !!t)) } } return e } ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t => { Za[t] = Ka.prototype[t] })); class Ja extends (Y()) { constructor(t, e) { super(); Q(this, tc(t, e)); this._domNode = t; this._options = e } attach(t) { if (this._domListeners && this._domListeners[t]) { return } const e = this._createDomListener(t); this._domNode.addEventListener(t, e, this._options); if (!this._domListeners) { this._domListeners = {} } this._domListeners[t] = e } detach(t) { let e; if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) { this._domListeners[t].removeListener() } } _addEventListener(t, e, n) { this.attach(t); Y().prototype._addEventListener.call(this, t, e, n) } _removeEventListener(t, e) { Y().prototype._removeEventListener.call(this, t, e); this.detach(t) } _createDomListener(t) { const e = e => { this.fire(t, e) }; e.removeListener = () => { this._domNode.removeEventListener(t, e, this._options); delete this._domListeners[t] }; return e } } function Xa(t) { return t["data-ck-expando"] || (t["data-ck-expando"] = T()) } function tc(t, e) { let n = Xa(t); for (const t of Object.keys(e).sort()) { if (e[t]) { n += "-" + t } } return n } let ec; try { ec = { window, document } } catch (t) { ec = { window: {}, document: {} } } const nc = ec; function ic(t) { const e = []; let n = t; while (n && n.nodeType != Node.DOCUMENT_NODE) { e.unshift(n); n = n.parentNode } return e } function oc(t) { if (t instanceof HTMLTextAreaElement) { return t.value } return t.innerHTML } function rc(t) { return Object.prototype.toString.call(t) == "[object Text]" } function sc(t) { return Object.prototype.toString.apply(t) == "[object Range]" } function ac(t) { const e = t.ownerDocument.defaultView.getComputedStyle(t); return { top: parseInt(e.borderTopWidth, 10), right: parseInt(e.borderRightWidth, 10), bottom: parseInt(e.borderBottomWidth, 10), left: parseInt(e.borderLeftWidth, 10) } } const cc = ["top", "right", "bottom", "left", "width", "height"]; class lc { constructor(t) { const e = sc(t); Object.defineProperty(this, "_source", { value: t._source || t, writable: true, enumerable: false }); if (hc(t) || e) { if (e) { const e = lc.getDomRangeRects(t); dc(this, lc.getBoundingRect(e)) } else { dc(this, t.getBoundingClientRect()) } } else if (Qa(t)) { const { innerWidth: e, innerHeight: n } = t; dc(this, { top: 0, right: e, bottom: n, left: 0, width: e, height: n }) } else { dc(this, t) } } clone() { return new lc(this) } moveTo(t, e) { this.top = e; this.right = t + this.width; this.bottom = e + this.height; this.left = t; return this } moveBy(t, e) { this.top += e; this.right += t; this.left += t; this.bottom += e; return this } getIntersection(t) { const e = { top: Math.max(this.top, t.top), right: Math.min(this.right, t.right), bottom: Math.min(this.bottom, t.bottom), left: Math.max(this.left, t.left), width: 0, height: 0 }; e.width = e.right - e.left; e.height = e.bottom - e.top; if (e.width < 0 || e.height < 0) { return null } else { return new lc(e) } } getIntersectionArea(t) { const e = this.getIntersection(t); if (e) { return e.getArea() } else { return 0 } } getArea() { return this.width * this.height } getVisible() { const t = this._source; let e = this.clone(); if (!uc(t)) { let n = t.parentNode || t.commonAncestorContainer; while (n && !uc(n)) { const t = new lc(n); const i = e.getIntersection(t); if (i) { if (i.getArea() < e.getArea()) { e = i } } else { return null } n = n.parentNode } } return e } isEqual(t) { for (const e of cc) { if (this[e] !== t[e]) { return false } } return true } contains(t) { const e = this.getIntersection(t); return !!(e && e.isEqual(t)) } excludeScrollbarsAndBorders() { const t = this._source; let e, n, i; if (Qa(t)) { e = t.innerWidth - t.document.documentElement.clientWidth; n = t.innerHeight - t.document.documentElement.clientHeight; i = t.getComputedStyle(t.document.documentElement).direction } else { const o = ac(t); e = t.offsetWidth - t.clientWidth - o.left - o.right; n = t.offsetHeight - t.clientHeight - o.top - o.bottom; i = t.ownerDocument.defaultView.getComputedStyle(t).direction; this.left += o.left; this.top += o.top; this.right -= o.right; this.bottom -= o.bottom; this.width = this.right - this.left; this.height = this.bottom - this.top } this.width -= e; if (i === "ltr") { this.right -= e } else { this.left += e } this.height -= n; this.bottom -= n; return this } static getDomRangeRects(t) { const e = []; const n = Array.from(t.getClientRects()); if (n.length) { for (const t of n) { e.push(new lc(t)) } } else { let n = t.startContainer; if (rc(n)) { n = n.parentNode } const i = new lc(n.getBoundingClientRect()); i.right = i.left; i.width = 0; e.push(i) } return e } static getBoundingRect(t) { const e = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 }; let n = 0; for (const i of t) { n++; e.left = Math.min(e.left, i.left); e.top = Math.min(e.top, i.top); e.right = Math.max(e.right, i.right); e.bottom = Math.max(e.bottom, i.bottom) } if (n == 0) { return null } e.width = e.right - e.left; e.height = e.bottom - e.top; return new lc(e) } } function dc(t, e) { for (const n of cc) { t[n] = e[n] } } function uc(t) { if (!hc(t)) { return false } return t === t.ownerDocument.body } function hc(t) { return t !== null && typeof t === "object" && t.nodeType === 1 && typeof t.getBoundingClientRect === "function" } class fc { constructor(t, e) { if (!fc._observerInstance) { fc._createObserver() } this._element = t; this._callback = e; fc._addElementCallback(t, e); fc._observerInstance.observe(t) } destroy() { fc._deleteElementCallback(this._element, this._callback) } static _addElementCallback(t, e) { if (!fc._elementCallbacks) { fc._elementCallbacks = new Map } let n = fc._elementCallbacks.get(t); if (!n) { n = new Set; fc._elementCallbacks.set(t, n) } n.add(e) } static _deleteElementCallback(t, e) { const n = fc._getElementCallbacks(t); if (n) { n.delete(e); if (!n.size) { fc._elementCallbacks.delete(t); fc._observerInstance.unobserve(t) } } if (fc._elementCallbacks && !fc._elementCallbacks.size) { fc._observerInstance = null; fc._elementCallbacks = null } } static _getElementCallbacks(t) { if (!fc._elementCallbacks) { return null } return fc._elementCallbacks.get(t) } static _createObserver() { fc._observerInstance = new nc.window.ResizeObserver((t => { for (const e of t) { const t = fc._getElementCallbacks(e.target); if (t) { for (const n of t) { n(e) } } } })) } } fc._observerInstance = null; fc._elementCallbacks = null; function gc(t, e) { if (t instanceof HTMLTextAreaElement) { t.value = e } t.innerHTML = e } function mc(t) { return e => e + t } function pc(t) { let e = 0; while (t.previousSibling) { t = t.previousSibling; e++ } return e } function kc(t, e, n) { t.insertBefore(n, t.childNodes[e] || null) } function bc(t) { return t && t.nodeType === Node.COMMENT_NODE } function wc(t) { return !!(t && t.getClientRects && t.getClientRects().length) } function _c(t) { if (!t || !t.parentNode) { return null } if (t.offsetParent === nc.document.body) { return null } return t.offsetParent } function Ac({ element: t, target: e, positions: n, limiter: i, fitInViewport: o, viewportOffsetConfig: r }) { if (Ye(e)) { e = e() } if (Ye(i)) { i = i() } const s = _c(t); const a = new lc(t); const c = new lc(e); let l; const d = o && Cc(r) || null; const u = { targetRect: c, elementRect: a, positionedElementAncestor: s, viewportRect: d }; if (!i && !o) { l = new Ec(n[0], u) } else { const t = i && new lc(i).getVisible(); Object.assign(u, { limiterRect: t, viewportRect: d }); l = vc(n, u) || new Ec(n[0], u) } return l } function Cc(t) { t = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t); const e = new lc(nc.window); e.top += t.top; e.height -= t.top; e.bottom -= t.bottom; e.height -= t.bottom; return e } function vc(t, e) { const { elementRect: n } = e; const i = n.getArea(); const o = t.map((t => new Ec(t, e))).filter((t => !!t.name)); let r = 0; let s = null; for (const t of o) { const { limiterIntersectionArea: e, viewportIntersectionArea: n } = t; if (e === i) { return t } const o = n ** 2 + e ** 2; if (o > r) { r = o; s = t } } return s } function yc(t, e) { const n = xc(new lc(e)); const i = ac(e); let o = 0; let r = 0; o -= n.left; r -= n.top; o += e.scrollLeft; r += e.scrollTop; o -= i.left; r -= i.top; t.moveBy(o, r) } function xc(t) { const { scrollX: e, scrollY: n } = nc.window; return t.clone().moveBy(e, n) } class Ec { constructor(t, e) { const n = t(e.targetRect, e.elementRect, e.viewportRect); if (!n) { return } const { left: i, top: o, name: r, config: s } = n; this.name = r; this.config = s; this._positioningFunctionCorrdinates = { left: i, top: o }; this._options = e } get left() { return this._absoluteRect.left } get top() { return this._absoluteRect.top } get limiterIntersectionArea() { const t = this._options.limiterRect; if (t) { const e = this._options.viewportRect; if (e) { const n = t.getIntersection(e); if (n) { return n.getIntersectionArea(this._rect) } } else { return t.getIntersectionArea(this._rect) } } return 0 } get viewportIntersectionArea() { const t = this._options.viewportRect; if (t) { return t.getIntersectionArea(this._rect) } return 0 } get _rect() { if (this._cachedRect) { return this._cachedRect } this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCorrdinates.left, this._positioningFunctionCorrdinates.top); return this._cachedRect } get _absoluteRect() { if (this._cachedAbsoluteRect) { return this._cachedAbsoluteRect } this._cachedAbsoluteRect = xc(this._rect); if (this._options.positionedElementAncestor) { yc(this._cachedAbsoluteRect, this._options.positionedElementAncestor) } return this._cachedAbsoluteRect } } function Dc(t) { const e = t.parentNode; if (e) { e.removeChild(t) } } function Ic({ target: t, viewportOffset: e = 0, ancestorOffset: n = 0, alignToTop: i, forceScroll: o }) { const r = Lc(t); let s = r; let a = null; while (s) { let c; if (s == r) { c = Oc(t) } else { c = Oc(a) } Sc({ parent: c, getRect: () => Rc(t, s), alignToTop: i, ancestorOffset: n, forceScroll: o }); const l = Rc(t, s); Mc({ window: s, rect: l, viewportOffset: e, alignToTop: i, forceScroll: o }); if (s.parent != s) { a = s.frameElement; s = s.parent; if (!a) { return } } else { s = null } } } function Tc(t, e) { const n = Oc(t); Sc({ parent: n, getRect: () => new Rect(t), ancestorOffset: e }) } function Mc({ window: t, rect: e, alignToTop: n, forceScroll: i, viewportOffset: o }) { const r = e.clone().moveBy(0, o); const s = e.clone().moveBy(0, -o); const a = new lc(t).excludeScrollbarsAndBorders(); const c = [s, r]; const l = n && i; const d = c.every((t => a.contains(t))); let { scrollX: u, scrollY: h } = t; const f = u; const g = h; if (l) { h -= a.top - e.top + o } else if (!d) { if (Bc(s, a)) { h -= a.top - e.top + o } else if (Nc(r, a)) { if (n) { h += e.top - a.top - o } else { h += e.bottom - a.bottom + o } } } if (!d) { if (zc(e, a)) { u -= a.left - e.left + o } else if (Pc(e, a)) { u += e.right - a.right + o } } if (u != f || h !== g) { t.scrollTo(u, h) } } function Sc({ parent: t, getRect: e, alignToTop: n, forceScroll: i, ancestorOffset: o = 0 }) { const r = Lc(t); const s = n && i; let a, c, l; while (t != r.document.body) { c = e(); a = new lc(t).excludeScrollbarsAndBorders(); l = a.contains(c); if (s) { t.scrollTop -= a.top - c.top + o } else if (!l) { if (Bc(c, a)) { t.scrollTop -= a.top - c.top + o } else if (Nc(c, a)) { if (n) { t.scrollTop += c.top - a.top - o } else { t.scrollTop += c.bottom - a.bottom + o } } } if (!l) { if (zc(c, a)) { t.scrollLeft -= a.left - c.left + o } else if (Pc(c, a)) { t.scrollLeft += c.right - a.right + o } } t = t.parentNode } } function Nc(t, e) { return t.bottom > e.bottom } function Bc(t, e) { return t.top < e.top } function zc(t, e) { return t.left < e.left } function Pc(t, e) { return t.right > e.right } function Lc(t) { if (sc(t)) { return t.startContainer.ownerDocument.defaultView } else { return t.ownerDocument.defaultView } } function Oc(t) { if (sc(t)) { let e = t.commonAncestorContainer; if (rc(e)) { e = e.parentNode } return e } else { return t.parentNode } } function Rc(t, e) { const n = Lc(t); const i = new lc(t); if (n === e) { return i } else { let t = n; while (t != e) { const e = t.frameElement; const n = new lc(e).excludeScrollbarsAndBorders(); i.moveBy(n.left, n.top); t = t.parent } } return i } const jc = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" }; const Vc = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }; const Fc = Kc(); const Hc = Object.fromEntries(Object.entries(Fc).map((([t, e]) => [e, t.charAt(0).toUpperCase() + t.slice(1)]))); function Uc(t) { let e; if (typeof t == "string") { e = Fc[t.toLowerCase()]; if (!e) { throw new z("keyboard-unknown-key", null, { key: t }) } } else { e = t.keyCode + (t.altKey ? Fc.alt : 0) + (t.ctrlKey ? Fc.ctrl : 0) + (t.shiftKey ? Fc.shift : 0) + (t.metaKey ? Fc.cmd : 0) } return e } function Wc(t) { if (typeof t == "string") { t = Zc(t) } return t.map((t => typeof t == "string" ? $c(t) : t)).reduce(((t, e) => e + t), 0) } function Gc(t) { let e = Wc(t); const n = Object.entries(l.isMac ? jc : Vc); const i = n.reduce(((t, [n, i]) => { if ((e & Fc[n]) != 0) { e &= ~Fc[n]; t += i } return t }), ""); return i + (e ? Hc[e] : "") } function qc(t) { return t == Fc.arrowright || t == Fc.arrowleft || t == Fc.arrowup || t == Fc.arrowdown } function Yc(t, e) { const n = e === "ltr"; switch (t) { case Fc.arrowleft: return n ? "left" : "right"; case Fc.arrowright: return n ? "right" : "left"; case Fc.arrowup: return "up"; case Fc.arrowdown: return "down" } } function $c(t) { if (t.endsWith("!")) { return Uc(t.slice(0, -1)) } const e = Uc(t); return l.isMac && e == Fc.ctrl ? Fc.cmd : e } function Qc(t, e) { const n = Yc(t, e); return n === "down" || n === "right" } function Kc() { const t = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 }; for (let e = 65; e <= 90; e++) { const n = String.fromCharCode(e); t[n.toLowerCase()] = e } for (let e = 48; e <= 57; e++) { t[e - 48] = e } for (let e = 112; e <= 123; e++) { t["f" + (e - 111)] = e } for (const e of "`-=[];',./\\") { t[e] = e.charCodeAt(0) } return t } function Zc(t) { return t.split("+").map((t => t.trim())) } const Jc = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"]; function Xc(t) { return Jc.includes(t) ? "rtl" : "ltr" } function tl(t) { return Array.isArray(t) ? t : [t] } if (!nc.window.CKEDITOR_TRANSLATIONS) { nc.window.CKEDITOR_TRANSLATIONS = {} } function el(t, e, n) { if (!global.window.CKEDITOR_TRANSLATIONS[t]) { global.window.CKEDITOR_TRANSLATIONS[t] = {} } const i = global.window.CKEDITOR_TRANSLATIONS[t]; i.dictionary = i.dictionary || {}; i.getPluralForm = n || i.getPluralForm; Object.assign(i.dictionary, e) } function nl(t, e, n = 1) { if (typeof n !== "number") { throw new z("translation-service-quantity-not-a-number", null, { quantity: n }) } const i = rl(); if (i === 1) { t = Object.keys(nc.window.CKEDITOR_TRANSLATIONS)[0] } const o = e.id || e.string; if (i === 0 || !ol(t, o)) { if (n !== 1) { return e.plural } return e.string } const r = nc.window.CKEDITOR_TRANSLATIONS[t].dictionary; const s = nc.window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => t === 1 ? 0 : 1); const a = r[o]; if (typeof a === "string") { return a } const c = Number(s(n)); return a[c] } function il() { global.window.CKEDITOR_TRANSLATIONS = {} } function ol(t, e) { return !!nc.window.CKEDITOR_TRANSLATIONS[t] && !!nc.window.CKEDITOR_TRANSLATIONS[t].dictionary[e] } function rl() { return Object.keys(nc.window.CKEDITOR_TRANSLATIONS).length } class sl { constructor({ uiLanguage: t = "en", contentLanguage: e } = {}) { this.uiLanguage = t; this.contentLanguage = e || this.uiLanguage; this.uiLanguageDirection = Xc(this.uiLanguage); this.contentLanguageDirection = Xc(this.contentLanguage); this.t = (t, e) => this._t(t, e) } get language() { console.warn("locale-deprecated-language-property: " + "The Locale#language property has been deprecated and will be removed in the near future. " + "Please use #uiLanguage and #contentLanguage properties instead."); return this.uiLanguage } _t(t, e = []) { e = tl(e); if (typeof t === "string") { t = { string: t } } const n = !!t.plural; const i = n ? e[0] : 1; const o = nl(this.uiLanguage, t, i); return al(o, e) } } function al(t, e) { return t.replace(/%(\d+)/g, ((t, n) => n < e.length ? e[n] : t)) } class cl extends (Y()) { constructor(t = {}, e = {}) { super(); const n = Dt(t); if (!n) { e = t } this._items = []; this._itemMap = new Map; this._idProperty = e.idProperty || "id"; this._bindToExternalToInternalMap = new WeakMap; this._bindToInternalToExternalMap = new WeakMap; this._skippedIndexesFromExternal = []; if (n) { for (const e of t) { this._items.push(e); this._itemMap.set(this._getItemIdBeforeAdding(e), e) } } } get length() { return this._items.length } get first() { return this._items[0] || null } get last() { return this._items[this.length - 1] || null } add(t, e) { return this.addMany([t], e) } addMany(t, e) { if (e === undefined) { e = this._items.length } else if (e > this._items.length || e < 0) { throw new z("collection-add-item-invalid-index", this) } let n = 0; for (const i of t) { const t = this._getItemIdBeforeAdding(i); const o = e + n; this._items.splice(o, 0, i); this._itemMap.set(t, i); this.fire("add", i, o); n++ } this.fire("change", { added: t, removed: [], index: e }); return this } get(t) { let e; if (typeof t == "string") { e = this._itemMap.get(t) } else if (typeof t == "number") { e = this._items[t] } else { throw new z("collection-get-invalid-arg", this) } return e || null } has(t) { if (typeof t == "string") { return this._itemMap.has(t) } else { const e = this._idProperty; const n = t[e]; return n && this._itemMap.has(n) } } getIndex(t) { let e; if (typeof t == "string") { e = this._itemMap.get(t) } else { e = t } return e ? this._items.indexOf(e) : -1 } remove(t) { const [e, n] = this._remove(t); this.fire("change", { added: [], removed: [e], index: n }); return e } map(t, e) { return this._items.map(t, e) } find(t, e) { return this._items.find(t, e) } filter(t, e) { return this._items.filter(t, e) } clear() { if (this._bindToCollection) { this.stopListening(this._bindToCollection); this._bindToCollection = null } const t = Array.from(this._items); while (this.length) { this._remove(0) } this.fire("change", { added: [], removed: t, index: 0 }) } bindTo(t) { if (this._bindToCollection) { throw new z("collection-bind-to-rebind", this) } this._bindToCollection = t; return { as: t => { this._setUpBindToBinding((e => new t(e))) }, using: t => { if (typeof t == "function") { this._setUpBindToBinding(t) } else { this._setUpBindToBinding((e => e[t])) } } } } _setUpBindToBinding(t) { const e = this._bindToCollection; const n = (n, i, o) => { const r = e._bindToCollection == this; const s = e._bindToInternalToExternalMap.get(i); if (r && s) { this._bindToExternalToInternalMap.set(i, s); this._bindToInternalToExternalMap.set(s, i) } else { const n = t(i); if (!n) { this._skippedIndexesFromExternal.push(o); return } let r = o; for (const t of this._skippedIndexesFromExternal) { if (o > t) { r-- } } for (const t of e._skippedIndexesFromExternal) { if (r >= t) { r++ } } this._bindToExternalToInternalMap.set(i, n); this._bindToInternalToExternalMap.set(n, i); this.add(n, r); for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) { if (r <= e._skippedIndexesFromExternal[t]) { e._skippedIndexesFromExternal[t]++ } } } }; for (const t of e) { n(null, t, e.getIndex(t)) } this.listenTo(e, "add", n); this.listenTo(e, "remove", ((t, e, n) => { const i = this._bindToExternalToInternalMap.get(e); if (i) { this.remove(i) } this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(((t, e) => { if (n < e) { t.push(e - 1) } if (n > e) { t.push(e) } return t }), []) })) } _getItemIdBeforeAdding(t) { const e = this._idProperty; let n; if (e in t) { n = t[e]; if (typeof n != "string") { throw new z("collection-add-invalid-id", this) } if (this.get(n)) { throw new z("collection-add-item-already-exists", this) } } else { t[e] = n = T() } return n } _remove(t) { let e, n, i; let o = false; const r = this._idProperty; if (typeof t == "string") { n = t; i = this._itemMap.get(n); o = !i; if (i) { e = this._items.indexOf(i) } } else if (typeof t == "number") { e = t; i = this._items[e]; o = !i; if (i) { n = i[r] } } else { i = t; n = i[r]; e = this._items.indexOf(i); o = e == -1 || !this._itemMap.get(n) } if (o) { throw new z("collection-remove-404", this) } this._items.splice(e, 1); this._itemMap.delete(n); const s = this._bindToInternalToExternalMap.get(i); this._bindToInternalToExternalMap.delete(i); this._bindToExternalToInternalMap.delete(s); this.fire("remove", i, e); return [i, e] } [Symbol.iterator]() { return this._items[Symbol.iterator]() } } function ll(t) { const e = t.next(); if (e.done) { return null } return e.value } class dl extends (Za(ft())) { constructor() { super(); this._elements = new Set; this._nextEventLoopTimeout = null; this.set("isFocused", false); this.set("focusedElement", null) } add(t) { if (this._elements.has(t)) { throw new z("focustracker-add-element-already-exist", this) } this.listenTo(t, "focus", (() => this._focus(t)), { useCapture: true }); this.listenTo(t, "blur", (() => this._blur()), { useCapture: true }); this._elements.add(t) } remove(t) { if (t === this.focusedElement) { this._blur() } if (this._elements.has(t)) { this.stopListening(t); this._elements.delete(t) } } destroy() { this.stopListening() } _focus(t) { clearTimeout(this._nextEventLoopTimeout); this.focusedElement = t; this.isFocused = true } _blur() { clearTimeout(this._nextEventLoopTimeout); this._nextEventLoopTimeout = setTimeout((() => { this.focusedElement = null; this.isFocused = false }), 0) } } class ul { constructor() { this._listener = new (Za()) } listenTo(t) { this._listener.listenTo(t, "keydown", ((t, e) => { this._listener.fire("_keydown:" + Uc(e), e) })) } set(t, e, n = {}) { const i = Wc(t); const o = n.priority; this._listener.listenTo(this._listener, "_keydown:" + i, ((t, n) => { e(n, (() => { n.preventDefault(); n.stopPropagation(); t.stop() })); t.return = true }), { priority: o }) } press(t) { return !!this._listener.fire("_keydown:" + Uc(t), t) } stopListening(t) { this._listener.stopListening(t) } destroy() { this.stopListening() } } function hl(t) { const e = new Map; for (const n in t) { e.set(n, t[n]) } return e } function fl(t) { if (Dt(t)) { return new Map(t) } else { return hl(t) } } const gl = 1e4; function ml(t, e, n, i) { if (Math.max(e.length, t.length) > gl) { return t.slice(0, n).concat(e).concat(t.slice(n + i, t.length)) } else { const o = Array.from(t); o.splice(n, i, ...e); return o } } function pl(t) { return !!t && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t) } function kl(t) { return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t) } function bl(t) { return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t) } function wl(t, e) { return kl(t.charAt(e - 1)) && bl(t.charAt(e)) } function _l(t, e) { return pl(t.charAt(e)) } const Al = vl(); function Cl(t, e) { const n = String(t).matchAll(Al); return Array.from(n).some((t => t.index < e && e < t.index + t[0].length)) } function vl() { const t = [/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u, /\p{Emoji}\u{FE0F}?\u{20E3}/u, /\p{Emoji}\u{FE0F}/u, /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u]; const e = /\p{Regional_Indicator}{2}/u.source; const n = "(?:" + t.map((t => t.source)).join("|") + ")"; const i = `${e}|${n}(?:‍${n})*`; return new RegExp(i, "ug") } class yl extends cl { constructor(t = []) { super(t, { idProperty: "viewUid" }); this.on("add", ((t, e, n) => { this._renderViewIntoCollectionParent(e, n) })); this.on("remove", ((t, e) => { if (e.element && this._parentElement) { e.element.remove() } })); this._parentElement = null } destroy() { this.map((t => t.destroy())) } setParent(t) { this._parentElement = t; for (const t of this) { this._renderViewIntoCollectionParent(t) } } delegate(...t) { if (!t.length || !xl(t)) { throw new z("ui-viewcollection-delegate-wrong-events", this) } return { to: e => { for (const n of this) { for (const i of t) { n.delegate(i).to(e) } } this.on("add", ((n, i) => { for (const n of t) { i.delegate(n).to(e) } })); this.on("remove", ((n, i) => { for (const n of t) { i.stopDelegating(n, e) } })) } } } _renderViewIntoCollectionParent(t, e) { if (!t.isRendered) { t.render() } if (t.element && this._parentElement) { this._parentElement.insertBefore(t.element, this._parentElement.children[e]) } } remove(t) { return super.remove(t) } } function xl(t) { return t.every((t => typeof t == "string")) } var El = n(3379); var Dl = n.n(El); var Il = n(6150); var Tl = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Tl.insert = "head"; Tl.singleton = true; var Ml = Dl()(Il.Z, Tl); const Sl = Il.Z.locals || {}; class Nl extends (Za(ft())) { constructor(t) { super(); this.element = null; this.isRendered = false; this.locale = t; this.t = t && t.t; this._viewCollections = new cl; this._unboundChildren = this.createCollection(); this._viewCollections.on("add", ((e, n) => { n.locale = t; n.t = t && t.t })); this.decorate("render") } get bindTemplate() { if (this._bindTemplate) { return this._bindTemplate } return this._bindTemplate = zl.bind(this, this) } createCollection(t) { const e = new yl(t); this._viewCollections.add(e); return e } registerChild(t) { if (!Dt(t)) { t = [t] } for (const e of t) { this._unboundChildren.add(e) } } deregisterChild(t) { if (!Dt(t)) { t = [t] } for (const e of t) { this._unboundChildren.remove(e) } } setTemplate(t) { this.template = new zl(t) } extendTemplate(t) { zl.extend(this.template, t) } render() { if (this.isRendered) { throw new z("ui-view-render-already-rendered", this) } if (this.template) { this.element = this.template.render(); this.registerChild(this.template.getViews()) } this.isRendered = true } destroy() { this.stopListening(); this._viewCollections.map((t => t.destroy())); if (this.template && this.template._revertData) { this.template.revert(this.element) } } } const Bl = "http://www.w3.org/1999/xhtml"; class zl extends (Y()) { constructor(t) { super(); Object.assign(this, Gl(Wl(t))); this._isRendered = false; this._revertData = null } render() { const t = this._renderNode({ intoFragment: true }); this._isRendered = true; return t } apply(t) { this._revertData = rd(); this._renderNode({ node: t, intoFragment: false, isApplying: true, revertData: this._revertData }); return t } revert(t) { if (!this._revertData) { throw new z("ui-template-revert-not-applied", [this, t]) } this._revertTemplateFromNode(t, this._revertData) } *getViews() { function* t(e) { if (e.children) { for (const n of e.children) { if (ed(n)) { yield n } else if (nd(n)) { yield* t(n) } } } } yield* t(this) } static bind(t, e) { return { to(n, i) { return new Ll({ eventNameOrFunction: n, attribute: n, observable: t, emitter: e, callback: i }) }, if(n, i, o) { return new Ol({ observable: t, emitter: e, attribute: n, valueIfTrue: i, callback: o }) } } } static extend(t, e) { if (t._isRendered) { throw new z("template-extend-render", [this, t]) } Xl(t, Gl(Wl(e))) } _renderNode(t) { let e; if (t.node) { e = this.tag && this.text } else { e = this.tag ? this.text : !this.text } if (e) { throw new z("ui-template-wrong-syntax", this) } if (this.text) { return this._renderText(t) } else { return this._renderElement(t) } } _renderElement(t) { let e = t.node; if (!e) { e = t.node = document.createElementNS(this.ns || Bl, this.tag) } this._renderAttributes(t); this._renderElementChildren(t); this._setUpListeners(t); return e } _renderText(t) { let e = t.node; if (e) { t.revertData.text = e.textContent } else { e = t.node = document.createTextNode("") } if (Rl(this.text)) { this._bindToObservable({ schema: this.text, updater: Fl(e), data: t }) } else { e.textContent = this.text.join("") } return e } _renderAttributes(t) { if (!this.attributes) { return } const e = t.node; const n = t.revertData; for (const i in this.attributes) { const o = e.getAttribute(i); const r = this.attributes[i]; if (n) { n.attributes[i] = o } const s = od(r) ? r[0].ns : null; if (Rl(r)) { const a = od(r) ? r[0].value : r; if (n && sd(i)) { a.unshift(o) } this._bindToObservable({ schema: a, updater: Hl(e, i, s), data: t }) } else if (i == "style" && typeof r[0] !== "string") { this._renderStyleAttribute(r[0], t) } else { if (n && o && sd(i)) { r.unshift(o) } const t = r.map((t => t ? t.value || t : t)).reduce(((t, e) => t.concat(e)), []).reduce(Zl, ""); if (!td(t)) { e.setAttributeNS(s, i, t) } } } } _renderStyleAttribute(t, e) { const n = e.node; for (const i in t) { const o = t[i]; if (Rl(o)) { this._bindToObservable({ schema: [o], updater: Ul(n, i), data: e }) } else { n.style[i] = o } } } _renderElementChildren(t) { const e = t.node; const n = t.intoFragment ? document.createDocumentFragment() : e; const i = t.isApplying; let o = 0; for (const r of this.children) { if (id(r)) { if (!i) { r.setParent(e); for (const t of r) { n.appendChild(t.element) } } } else if (ed(r)) { if (!i) { if (!r.isRendered) { r.render() } n.appendChild(r.element) } } else if ($a(r)) { n.appendChild(r) } else { if (i) { const e = t.revertData; const i = rd(); e.children.push(i); r._renderNode({ intoFragment: false, node: n.childNodes[o++], isApplying: true, revertData: i }) } else { n.appendChild(r.render()) } } } if (t.intoFragment) { e.appendChild(n) } } _setUpListeners(t) { if (!this.eventListeners) { return } for (const e in this.eventListeners) { const n = this.eventListeners[e].map((n => { const [i, o] = e.split("@"); return n.activateDomEventListener(i, o, t) })); if (t.revertData) { t.revertData.bindings.push(n) } } } _bindToObservable({ schema: t, updater: e, data: n }) { const i = n.revertData; Vl(t, e, n); const o = t.filter((t => !td(t))).filter((t => t.observable)).map((i => i.activateAttributeListener(t, e, n))); if (i) { i.bindings.push(o) } } _revertTemplateFromNode(t, e) { for (const t of e.bindings) { for (const e of t) { e() } } if (e.text) { t.textContent = e.text; return } const n = t; for (const t in e.attributes) { const i = e.attributes[t]; if (i === null) { n.removeAttribute(t) } else { n.setAttribute(t, i) } } for (let t = 0; t < e.children.length; ++t) { this._revertTemplateFromNode(n.childNodes[t], e.children[t]) } } } class Pl { constructor(t) { this.attribute = t.attribute; this.observable = t.observable; this.emitter = t.emitter; this.callback = t.callback } getValue(t) { const e = this.observable[this.attribute]; return this.callback ? this.callback(e, t) : e } activateAttributeListener(t, e, n) { const i = () => Vl(t, e, n); this.emitter.listenTo(this.observable, `change:${this.attribute}`, i); return () => { this.emitter.stopListening(this.observable, `change:${this.attribute}`, i) } } } class Ll extends Pl { constructor(t) { super(t); this.eventNameOrFunction = t.eventNameOrFunction } activateDomEventListener(t, e, n) { const i = (t, n) => { if (!e || n.target.matches(e)) { if (typeof this.eventNameOrFunction == "function") { this.eventNameOrFunction(n) } else { this.observable.fire(this.eventNameOrFunction, n) } } }; this.emitter.listenTo(n.node, t, i); return () => { this.emitter.stopListening(n.node, t, i) } } } class Ol extends Pl { constructor(t) { super(t); this.valueIfTrue = t.valueIfTrue } getValue(t) { const e = super.getValue(t); return td(e) ? false : this.valueIfTrue || true } } function Rl(t) { if (!t) { return false } if (t.value) { t = t.value } if (Array.isArray(t)) { return t.some(Rl) } else if (t instanceof Pl) { return true } return false } function jl(t, e) { return t.map((t => { if (t instanceof Pl) { return t.getValue(e) } return t })) } function Vl(t, e, { node: n }) { const i = jl(t, n); let o; if (t.length == 1 && t[0] instanceof Ol) { o = i[0] } else { o = i.reduce(Zl, "") } if (td(o)) { e.remove() } else { e.set(o) } } function Fl(t) { return { set(e) { t.textContent = e }, remove() { t.textContent = "" } } } function Hl(t, e, n) { return { set(i) { t.setAttributeNS(n, e, i) }, remove() { t.removeAttributeNS(n, e) } } } function Ul(t, e) { return { set(n) { t.style[e] = n }, remove() { t.style[e] = null } } } function Wl(t) { const e = Ha(t, (t => { if (t && (t instanceof Pl || nd(t) || ed(t) || id(t))) { return t } })); return e } function Gl(t) { if (typeof t == "string") { t = $l(t) } else if (t.text) { Ql(t) } if (t.on) { t.eventListeners = Yl(t.on); delete t.on } if (!t.text) { if (t.attributes) { ql(t.attributes) } const e = []; if (t.children) { if (id(t.children)) { e.push(t.children) } else { for (const n of t.children) { if (nd(n) || ed(n) || $a(n)) { e.push(n) } else { e.push(new zl(n)) } } } } t.children = e } return t } function ql(t) { for (const e in t) { if (t[e].value) { t[e].value = tl(t[e].value) } Kl(t, e) } } function Yl(t) { for (const e in t) { Kl(t, e) } return t } function $l(t) { return { text: [t] } } function Ql(t) { t.text = tl(t.text) } function Kl(t, e) { t[e] = tl(t[e]) } function Zl(t, e) { if (td(e)) { return t } else if (td(t)) { return e } else { return `${t} ${e}` } } function Jl(t, e) { for (const n in e) { if (t[n]) { t[n].push(...e[n]) } else { t[n] = e[n] } } } function Xl(t, e) { if (e.attributes) { if (!t.attributes) { t.attributes = {} } Jl(t.attributes, e.attributes) } if (e.eventListeners) { if (!t.eventListeners) { t.eventListeners = {} } Jl(t.eventListeners, e.eventListeners) } if (e.text) { t.text.push(...e.text) } if (e.children && e.children.length) { if (t.children.length != e.children.length) { throw new z("ui-template-extend-children-mismatch", t) } let n = 0; for (const i of e.children) { Xl(t.children[n++], i) } } } function td(t) { return !t && t !== 0 } function ed(t) { return t instanceof Nl } function nd(t) { return t instanceof zl } function id(t) { return t instanceof yl } function od(t) { return st(t[0]) && t[0].ns } function rd() { return { children: [], bindings: [], attributes: {} } } function sd(t) { return t == "class" || t == "style" } class ad extends yl { constructor(t, e = []) { super(e); this.locale = t } attachToDom() { this._bodyCollectionContainer = new zl({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render(); let t = document.querySelector(".ck-body-wrapper"); if (!t) { t = ie(document, "div", { class: "ck-body-wrapper" }); document.body.appendChild(t) } t.appendChild(this._bodyCollectionContainer) } detachFromDom() { super.destroy(); if (this._bodyCollectionContainer) { this._bodyCollectionContainer.remove() } const t = document.querySelector(".ck-body-wrapper"); if (t && t.childElementCount == 0) { t.remove() } } } var cd = n(1174); var ld = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; ld.insert = "head"; ld.singleton = true; var dd = Dl()(cd.Z, ld); const ud = cd.Z.locals || {}; class hd extends Nl { constructor() { super(); const t = this.bindTemplate; this.set("content", ""); this.set("viewBox", "0 0 20 20"); this.set("fillColor", ""); this.set("isColorInherited", true); this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", "ck-reset_all-excluded", t.if("isColorInherited", "ck-icon_inherit-color")], viewBox: t.to("viewBox") } }) } render() { super.render(); this._updateXMLContent(); this._colorFillPaths(); this.on("change:content", (() => { this._updateXMLContent(); this._colorFillPaths() })); this.on("change:fillColor", (() => { this._colorFillPaths() })) } _updateXMLContent() { if (this.content) { const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml"); const e = t.querySelector("svg"); const n = e.getAttribute("viewBox"); if (n) { this.viewBox = n } for (const { name: t, value: n } of Array.from(e.attributes)) { if (hd.presentationalAttributeNames.includes(t)) { this.element.setAttribute(t, n) } } while (this.element.firstChild) { this.element.removeChild(this.element.firstChild) } while (e.childNodes.length > 0) { this.element.appendChild(e.childNodes[0]) } } } _colorFillPaths() { if (this.fillColor) { this.element.querySelectorAll(".ck-icon__fill").forEach((t => { t.style.fill = this.fillColor })) } } } hd.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"]; var fd = n(4499); var gd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; gd.insert = "head"; gd.singleton = true; var md = Dl()(fd.Z, gd); const pd = fd.Z.locals || {}; class kd extends Nl { constructor(t) { super(t); const e = this.bindTemplate; const n = T(); this.set("class", undefined); this.set("labelStyle", undefined); this.set("icon", undefined); this.set("isEnabled", true); this.set("isOn", false); this.set("isVisible", true); this.set("isToggleable", false); this.set("keystroke", undefined); this.set("label", undefined); this.set("tabindex", -1); this.set("tooltip", false); this.set("tooltipPosition", "s"); this.set("type", "button"); this.set("withText", false); this.set("withKeystroke", false); this.children = this.createCollection(); this.labelView = this._createLabelView(n); this.iconView = new hd; this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }); this.keystrokeView = this._createKeystrokeView(); this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this)); const i = { tag: "button", attributes: { class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", (t => !t)), e.if("isVisible", "ck-hidden", (t => !t)), e.to("isOn", (t => t ? "ck-on" : "ck-off")), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")], type: e.to("type", (t => t ? t : "button")), tabindex: e.to("tabindex"), "aria-labelledby": `ck-editor__aria-label_${n}`, "aria-disabled": e.if("isEnabled", true, (t => !t)), "aria-pressed": e.to("isOn", (t => this.isToggleable ? String(!!t) : false)), "data-cke-tooltip-text": e.to("_tooltipString"), "data-cke-tooltip-position": e.to("tooltipPosition") }, children: this.children, on: { click: e.to((t => { if (this.isEnabled) { this.fire("execute") } else { t.preventDefault() } })) } }; if (l.isSafari) { i.on.mousedown = e.to((t => { this.focus(); t.preventDefault() })) } this.setTemplate(i) } render() { super.render(); if (this.icon) { this.iconView.bind("content").to(this, "icon"); this.children.add(this.iconView) } this.children.add(this.labelView); if (this.withKeystroke && this.keystroke) { this.children.add(this.keystrokeView) } } focus() { this.element.focus() } _createLabelView(t) { const e = new Nl; const n = this.bindTemplate; e.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: n.to("labelStyle"), id: `ck-editor__aria-label_${t}` }, children: [{ text: n.to("label") }] }); return e } _createKeystrokeView() { const t = new Nl; t.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t => Gc(t))) }] }); return t } _getTooltipString(t, e, n) { if (t) { if (typeof t == "string") { return t } else { if (n) { n = Gc(n) } if (t instanceof Function) { return t(e, n) } else { return `${e}${n ? ` (${n})` : ""}` } } } return "" } } var bd = n(9681); var wd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; wd.insert = "head"; wd.singleton = true; var _d = Dl()(bd.Z, wd); const Ad = bd.Z.locals || {}; class Cd extends kd { constructor(t) { super(t); this.isToggleable = true; this.toggleSwitchView = this._createToggleView(); this.extendTemplate({ attributes: { class: "ck-switchbutton" } }) } render() { super.render(); this.children.add(this.toggleSwitchView) } _createToggleView() { const t = new Nl; t.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }); return t } } class vd extends (null && ButtonView) { constructor(t) { super(t); const e = this.bindTemplate; this.set("color", undefined); this.set("hasBorder", false); this.icon = checkIcon; this.extendTemplate({ attributes: { style: { backgroundColor: e.to("color") }, class: ["ck", "ck-color-grid__tile", e.if("hasBorder", "ck-color-table__color-tile_bordered")] } }) } render() { super.render(); this.iconView.fillColor = "hsl(0, 0%, 100%)" } } var yd = n(4923); var xd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; xd.insert = "head"; xd.singleton = true; var Ed = Dl()(yd.Z, xd); const Dd = yd.Z.locals || {}; class Id extends (null && View) { constructor(t, e) { super(t); const n = e && e.colorDefinitions ? e.colorDefinitions : []; this.columns = e && e.columns ? e.columns : 5; const i = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` }; this.set("selectedColor", undefined); this.items = this.createCollection(); this.focusTracker = new FocusTracker; this.keystrokes = new KeystrokeHandler; this.items.on("add", ((t, e) => { e.isOn = e.color === this.selectedColor })); n.forEach((t => { const e = new ColorTileView; e.set({ color: t.color, label: t.label, tooltip: true, hasBorder: t.options.hasBorder }); e.on("execute", (() => { this.fire("execute", { value: t.color, hasBorder: t.options.hasBorder, label: t.label }) })); this.items.add(e) })); this.setTemplate({ tag: "div", children: this.items, attributes: { class: ["ck", "ck-color-grid"], style: i } }); this.on("change:selectedColor", ((t, e, n) => { for (const t of this.items) { t.isOn = t.color === n } })) } focus() { if (this.items.length) { this.items.first.focus() } } focusLast() { if (this.items.length) { this.items.last.focus() } } render() { super.render(); for (const t of this.items) { this.focusTracker.add(t.element) } this.items.on("add", ((t, e) => { this.focusTracker.add(e.element) })); this.items.on("remove", ((t, e) => { this.focusTracker.remove(e.element) })); this.keystrokes.listenTo(this.element); addKeyboardHandlingForGrid({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: this.columns, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection }) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } } class Td { constructor(t) { this._components = new Map; this.editor = t } *names() { for (const t of this._components.values()) { yield t.originalName } } add(t, e) { this._components.set(Md(t), { callback: e, originalName: t }) } create(t) { if (!this.has(t)) { throw new z("componentfactory-item-missing", this, { name: t }) } return this._components.get(Md(t)).callback(this.editor.locale) } has(t) { return this._components.has(Md(t)) } } function Md(t) { return String(t).toLowerCase() } var Sd = n(3488); var Nd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Nd.insert = "head"; Nd.singleton = true; var Bd = Dl()(Sd.Z, Nd); const zd = Sd.Z.locals || {}; class Pd extends Nl { constructor(t, e, n) { super(t); const i = this.bindTemplate; this.buttonView = e; this.panelView = n; this.set("isOpen", false); this.set("isEnabled", true); this.set("class", undefined); this.set("id", undefined); this.set("panelPosition", "auto"); this.keystrokes = new ul; this.focusTracker = new dl; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", i.to("class"), i.if("isEnabled", "ck-disabled", (t => !t))], id: i.to("id"), "aria-describedby": i.to("ariaDescribedById") }, children: [e, n] }); e.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": i.to("isOpen") } }) } render() { super.render(); this.focusTracker.add(this.buttonView.element); this.focusTracker.add(this.panelView.element); this.listenTo(this.buttonView, "open", (() => { this.isOpen = !this.isOpen })); this.panelView.bind("isVisible").to(this, "isOpen"); this.on("change:isOpen", ((t, e, n) => { if (!n) { return } if (this.panelPosition === "auto") { this.panelView.position = Pd._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: true, positions: this._panelPositions }).name } else { this.panelView.position = this.panelPosition } })); this.keystrokes.listenTo(this.element); const t = (t, e) => { if (this.isOpen) { this.isOpen = false; e() } }; this.keystrokes.set("arrowdown", ((t, e) => { if (this.buttonView.isEnabled && !this.isOpen) { this.isOpen = true; e() } })); this.keystrokes.set("arrowright", ((t, e) => { if (this.isOpen) { e() } })); this.keystrokes.set("arrowleft", t); this.keystrokes.set("esc", t) } focus() { this.buttonView.focus() } get _panelPositions() { const { south: t, north: e, southEast: n, southWest: i, northEast: o, northWest: r, southMiddleEast: s, southMiddleWest: a, northMiddleEast: c, northMiddleWest: l } = Pd.defaultPanelPositions; if (this.locale.uiLanguageDirection !== "rtl") { return [n, i, s, a, t, o, r, c, l, e] } else { return [i, n, a, s, t, r, o, l, c, e] } } } Pd.defaultPanelPositions = { south: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 2, name: "s" }), southEast: t => ({ top: t.bottom, left: t.left, name: "se" }), southWest: (t, e) => ({ top: t.bottom, left: t.left - e.width + t.width, name: "sw" }), southMiddleEast: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) / 4, name: "sme" }), southMiddleWest: (t, e) => ({ top: t.bottom, left: t.left - (e.width - t.width) * 3 / 4, name: "smw" }), north: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 2, name: "n" }), northEast: (t, e) => ({ top: t.top - e.height, left: t.left, name: "ne" }), northWest: (t, e) => ({ top: t.top - e.height, left: t.left - e.width + t.width, name: "nw" }), northMiddleEast: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) / 4, name: "nme" }), northMiddleWest: (t, e) => ({ top: t.top - e.height, left: t.left - (e.width - t.width) * 3 / 4, name: "nmw" }) }; Pd._getOptimalPosition = Ac; class Ld extends Nl { constructor(t) { super(t); const e = this.bindTemplate; this.set("isVisible", false); this.set("position", "se"); this.children = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (t => `ck-dropdown__panel_${t}`)), e.if("isVisible", "ck-dropdown__panel-visible")] }, children: this.children, on: { selectstart: e.to((t => t.preventDefault())) } }) } focus() { if (this.children.length) { const t = this.children.first; if (typeof t.focus === "function") { t.focus() } else { P("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this }) } } } focusLast() { if (this.children.length) { const t = this.children.last; if (typeof t.focusLast === "function") { t.focusLast() } else { t.focus() } } } } const Od = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>'; class Rd extends kd { constructor(t) { super(t); this.arrowView = this._createArrowView(); this.extendTemplate({ attributes: { "aria-haspopup": true, "aria-expanded": this.bindTemplate.to("isOn", (t => String(t))) } }); this.delegate("execute").to(this, "open") } render() { super.render(); this.children.add(this.arrowView) } _createArrowView() { const t = new hd; t.content = Od; t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }); return t } } var jd = n(66); var Vd = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Vd.insert = "head"; Vd.singleton = true; var Fd = Dl()(jd.Z, Vd); const Hd = jd.Z.locals || {}; class Ud extends Nl { constructor(t) { super(t); const e = this.bindTemplate; this.set("class", undefined); this.set("labelStyle", undefined); this.set("icon", undefined); this.set("isEnabled", true); this.set("isOn", false); this.set("isToggleable", false); this.set("isVisible", true); this.set("keystroke", undefined); this.set("withKeystroke", false); this.set("label", undefined); this.set("tabindex", -1); this.set("tooltip", false); this.set("tooltipPosition", "s"); this.set("type", "button"); this.set("withText", false); this.children = this.createCollection(); this.actionView = this._createActionView(); this.arrowView = this._createArrowView(); this.keystrokes = new ul; this.focusTracker = new dl; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", e.to("class"), e.if("isVisible", "ck-hidden", (t => !t)), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children }) } render() { super.render(); this.children.add(this.actionView); this.children.add(this.arrowView); this.focusTracker.add(this.actionView.element); this.focusTracker.add(this.arrowView.element); this.keystrokes.listenTo(this.element); this.keystrokes.set("arrowright", ((t, e) => { if (this.focusTracker.focusedElement === this.actionView.element) { this.arrowView.focus(); e() } })); this.keystrokes.set("arrowleft", ((t, e) => { if (this.focusTracker.focusedElement === this.arrowView.element) { this.actionView.focus(); e() } })) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this.actionView.focus() } _createActionView() { const t = new kd; t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this); t.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }); t.delegate("execute").to(this); return t } _createArrowView() { const t = new kd; const e = t.bindTemplate; t.icon = Od; t.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": e.to("isOn"), "aria-haspopup": true, "aria-expanded": e.to("isOn", (t => String(t))) } }); t.bind("isEnabled").to(this); t.bind("label").to(this); t.bind("tooltip").to(this); t.delegate("execute").to(this, "open"); return t } } class Wd { constructor(t) { this.focusables = t.focusables; this.focusTracker = t.focusTracker; this.keystrokeHandler = t.keystrokeHandler; this.actions = t.actions; if (t.actions && t.keystrokeHandler) { for (const e in t.actions) { let n = t.actions[e]; if (typeof n == "string") { n = [n] } for (const i of n) { t.keystrokeHandler.set(i, ((t, n) => { this[e](); n() })) } } } } get first() { return this.focusables.find(Gd) || null } get last() { return this.focusables.filter(Gd).slice(-1)[0] || null } get next() { return this._getFocusableItem(1) } get previous() { return this._getFocusableItem(-1) } get current() { let t = null; if (this.focusTracker.focusedElement === null) { return null } this.focusables.find(((e, n) => { const i = e.element === this.focusTracker.focusedElement; if (i) { t = n } return i })); return t } focusFirst() { this._focus(this.first) } focusLast() { this._focus(this.last) } focusNext() { this._focus(this.next) } focusPrevious() { this._focus(this.previous) } _focus(t) { if (t) { t.focus() } } _getFocusableItem(t) { const e = this.current; const n = this.focusables.length; if (!n) { return null } if (e === null) { return this[t === 1 ? "first" : "last"] } let i = (e + n + t) % n; do { const e = this.focusables.get(i); if (Gd(e)) { return e } i = (i + n + t) % n } while (i !== e); return null } } function Gd(t) { return !!(t.focus && wc(t.element)) } class qd extends Nl { constructor(t) { super(t); this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } }) } } class Yd extends Nl { constructor(t) { super(t); this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } }) } } function $d(t) { return t.bindTemplate.to((e => { if (e.target === t.element) { e.preventDefault() } })) } function Qd(t) { if (Array.isArray(t)) { return { items: t, removeItems: [] } } if (!t) { return { items: [], removeItems: [] } } return Object.assign({ items: [], removeItems: [] }, t) } class Kd extends (ft()) { constructor(t) { super(); this._disableStack = new Set; this.editor = t; this.set("isEnabled", true) } forceDisabled(t) { this._disableStack.add(t); if (this._disableStack.size == 1) { this.on("set:isEnabled", Zd, { priority: "highest" }); this.isEnabled = false } } clearForceDisabled(t) { this._disableStack.delete(t); if (this._disableStack.size == 0) { this.off("set:isEnabled", Zd); this.isEnabled = true } } destroy() { this.stopListening() } static get isContextPlugin() { return false } } function Zd(t) { t.return = false; t.stop() } class Jd extends (ft()) { constructor(t) { super(); this.editor = t; this.set("value", undefined); this.set("isEnabled", false); this._affectsData = true; this._disableStack = new Set; this.decorate("execute"); this.listenTo(this.editor.model.document, "change", (() => { this.refresh() })); this.on("execute", (t => { if (!this.isEnabled) { t.stop() } }), { priority: "high" }); this.listenTo(t, "change:isReadOnly", ((t, e, n) => { if (n && this.affectsData) { this.forceDisabled("readOnlyMode") } else { this.clearForceDisabled("readOnlyMode") } })) } get affectsData() { return this._affectsData } set affectsData(t) { this._affectsData = t } refresh() { this.isEnabled = true } forceDisabled(t) { this._disableStack.add(t); if (this._disableStack.size == 1) { this.on("set:isEnabled", Xd, { priority: "highest" }); this.isEnabled = false } } clearForceDisabled(t) { this._disableStack.delete(t); if (this._disableStack.size == 0) { this.off("set:isEnabled", Xd); this.refresh() } } execute(...t) { return undefined } destroy() { this.stopListening() } } function Xd(t) { t.return = false; t.stop() } class tu extends Jd { constructor() { super(...arguments); this._childCommandsDefinitions = [] } refresh() { } execute(...t) { const e = this._getFirstEnabledCommand(); return !!e && e.execute(t) } registerChildCommand(t, e = {}) { N(this._childCommandsDefinitions, { command: t, priority: e.priority || "normal" }); t.on("change:isEnabled", (() => this._checkEnabled())); this._checkEnabled() } _checkEnabled() { this.isEnabled = !!this._getFirstEnabledCommand() } _getFirstEnabledCommand() { const t = this._childCommandsDefinitions.find((({ command: t }) => t.isEnabled)); return t && t.command } } class eu extends (Y()) { constructor(t, e = [], n = []) { super(); this._plugins = new Map; this._context = t; this._availablePlugins = new Map; for (const t of e) { if (t.pluginName) { this._availablePlugins.set(t.pluginName, t) } } this._contextPlugins = new Map; for (const [t, e] of n) { this._contextPlugins.set(t, e); this._contextPlugins.set(e, t); if (t.pluginName) { this._availablePlugins.set(t.pluginName, t) } } } *[Symbol.iterator]() { for (const t of this._plugins) { if (typeof t[0] == "function") { yield t } } } get(t) { const e = this._plugins.get(t); if (!e) { let e = t; if (typeof t == "function") { e = t.pluginName || t.name } throw new z("plugincollection-plugin-not-loaded", this._context, { plugin: e }) } return e } has(t) { return this._plugins.has(t) } init(t, e = [], n = []) { const i = this; const o = this._context; h(t); g(t); const r = t.filter((t => !d(t, e))); const s = [...f(r)]; _(s, n); const a = b(s); return w(a, "init").then((() => w(a, "afterInit"))).then((() => a)); function c(t) { return typeof t === "function" } function l(t) { return c(t) && !!t.isContextPlugin } function d(t, e) { return e.some((e => { if (e === t) { return true } if (u(t) === e) { return true } if (u(e) === t) { return true } return false })) } function u(t) { return c(t) ? t.pluginName || t.name : t } function h(t, e = new Set) { t.forEach((t => { if (!c(t)) { return } if (e.has(t)) { return } e.add(t); if (t.pluginName && !i._availablePlugins.has(t.pluginName)) { i._availablePlugins.set(t.pluginName, t) } if (t.requires) { h(t.requires, e) } })) } function f(t, e = new Set) { return t.map((t => c(t) ? t : i._availablePlugins.get(t))).reduce(((t, n) => { if (e.has(n)) { return t } e.add(n); if (n.requires) { g(n.requires, n); f(n.requires, e).forEach((e => t.add(e))) } return t.add(n) }), new Set) } function g(t, e = null) { t.map((t => c(t) ? t : i._availablePlugins.get(t) || t)).forEach((t => { m(t, e); p(t, e); k(t, e) })) } function m(t, e) { if (c(t)) { return } if (e) { throw new z("plugincollection-soft-required", o, { missingPlugin: t, requiredBy: u(e) }) } throw new z("plugincollection-plugin-not-found", o, { plugin: t }) } function p(t, e) { if (!l(e)) { return } if (l(t)) { return } throw new z("plugincollection-context-required", o, { plugin: u(t), requiredBy: u(e) }) } function k(t, n) { if (!n) { return } if (!d(t, e)) { return } throw new z("plugincollection-required", o, { plugin: u(t), requiredBy: u(n) }) } function b(t) { return t.map((t => { let e = i._contextPlugins.get(t); e = e || new t(o); i._add(t, e); return e })) } function w(t, e) { return t.reduce(((t, n) => { if (!n[e]) { return t } if (i._contextPlugins.has(n)) { return t } return t.then(n[e].bind(n)) }), Promise.resolve()) } function _(t, e) { for (const n of e) { if (typeof n != "function") { throw new z("plugincollection-replace-plugin-invalid-type", null, { pluginItem: n }) } const e = n.pluginName; if (!e) { throw new z("plugincollection-replace-plugin-missing-name", null, { pluginItem: n }) } if (n.requires && n.requires.length) { throw new z("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: e }) } const o = i._availablePlugins.get(e); if (!o) { throw new z("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: e }) } const r = t.indexOf(o); if (r === -1) { if (i._contextPlugins.has(o)) { return } throw new z("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: e }) } if (o.requires && o.requires.length) { throw new z("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: e }) } t.splice(r, 1, n); i._availablePlugins.set(e, n) } } } destroy() { const t = []; for (const [, e] of this) { if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) { t.push(e.destroy()) } } return Promise.all(t) } _add(t, e) { this._plugins.set(t, e); const n = t.pluginName; if (!n) { return } if (this._plugins.has(n)) { throw new z("plugincollection-plugin-name-conflict", null, { pluginName: n, plugin1: this._plugins.get(n).constructor, plugin2: t }) } this._plugins.set(n, e) } } class nu { constructor(t) { this._contextOwner = null; this.config = new Ga(t, this.constructor.defaultConfig); const e = this.constructor.builtinPlugins; this.config.define("plugins", e); this.plugins = new eu(this, e); const n = this.config.get("language") || {}; this.locale = new sl({ uiLanguage: typeof n === "string" ? n : n.ui, contentLanguage: this.config.get("language.content") }); this.t = this.locale.t; this.editors = new cl } initPlugins() { const t = this.config.get("plugins") || []; const e = this.config.get("substitutePlugins") || []; for (const n of t.concat(e)) { if (typeof n != "function") { throw new z("context-initplugins-constructor-only", null, { Plugin: n }) } if (n.isContextPlugin !== true) { throw new z("context-initplugins-invalid-plugin", null, { Plugin: n }) } } return this.plugins.init(t, [], e) } destroy() { return Promise.all(Array.from(this.editors, (t => t.destroy()))).then((() => this.plugins.destroy())) } _addEditor(t, e) { if (this._contextOwner) { throw new z("context-addeditor-private-context") } this.editors.add(t); if (e) { this._contextOwner = t } } _removeEditor(t) { if (this.editors.has(t)) { this.editors.remove(t) } if (this._contextOwner === t) { return this.destroy() } return Promise.resolve() } _getEditorConfig() { const t = {}; for (const e of this.config.names()) { if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) { t[e] = this.config.get(e) } } return t } static create(t) { return new Promise((e => { const n = new this(t); e(n.initPlugins().then((() => n))) })) } } class iu extends (ft()) { constructor(t) { super(); this.context = t } destroy() { this.stopListening() } static get isContextPlugin() { return true } } var ou = n(8894); var ru = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; ru.insert = "head"; ru.singleton = true; var su = Dl()(ou.Z, ru); const au = ou.Z.locals || {}; const cu = new WeakMap; function lu({ view: t, element: e, text: n, isDirectHost: i = true, keepOnFocus: o = false }) { const r = t.document; if (!cu.has(r)) { cu.set(r, new Map); r.registerPostFixer((t => gu(r, t))); r.on("change:isComposing", (() => { t.change((t => gu(r, t))) }), { priority: "high" }) } cu.get(r).set(e, { text: n, isDirectHost: i, keepOnFocus: o, hostElement: i ? e : null }); t.change((t => gu(r, t))) } function du(t, e) { const n = e.document; if (!cu.has(n)) { return } t.change((t => { const i = cu.get(n); const o = i.get(e); t.removeAttribute("data-placeholder", o.hostElement); hu(t, o.hostElement); i.delete(e) })) } function uu(t, e) { if (!e.hasClass("ck-placeholder")) { t.addClass("ck-placeholder", e); return true } return false } function hu(t, e) { if (e.hasClass("ck-placeholder")) { t.removeClass("ck-placeholder", e); return true } return false } function fu(t, e) { if (!t.isAttached()) { return false } const n = Array.from(t.getChildren()).some((t => !t.is("uiElement"))); if (n) { return false } const i = t.document; const o = i.selection; const r = o.anchor; if (i.isComposing && r && r.parent === t) { return false } if (e) { return true } if (!i.isFocused) { return true } return !!r && r.parent !== t } function gu(t, e) { const n = cu.get(t); const i = []; let o = false; for (const [t, r] of n) { if (r.isDirectHost) { i.push(t); if (mu(e, t, r)) { o = true } } } for (const [t, r] of n) { if (r.isDirectHost) { continue } const n = pu(t); if (!n) { continue } if (i.includes(n)) { continue } r.hostElement = n; if (mu(e, t, r)) { o = true } } return o } function mu(t, e, n) { const { text: i, isDirectHost: o, hostElement: r } = n; let s = false; if (r.getAttribute("data-placeholder") !== i) { t.setAttribute("data-placeholder", i, r); s = true } const a = o || e.childCount == 1; if (a && fu(r, n.keepOnFocus)) { if (uu(t, r)) { s = true } } else if (hu(t, r)) { s = true } return s } function pu(t) { if (t.childCount) { const e = t.getChild(0); if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) { return e } } return null } class ku { is() { throw new Error("is() method is abstract") } } var bu = 4; function wu(t) { return Ra(t, bu) } const _u = wu; class Au extends (Y(ku)) { constructor(t) { super(); this.document = t; this.parent = null } get index() { let t; if (!this.parent) { return null } if ((t = this.parent.getChildIndex(this)) == -1) { throw new z("view-node-not-found-in-parent", this) } return t } get nextSibling() { const t = this.index; return t !== null && this.parent.getChild(t + 1) || null } get previousSibling() { const t = this.index; return t !== null && this.parent.getChild(t - 1) || null } get root() { let t = this; while (t.parent) { t = t.parent } return t } isAttached() { return this.root.is("rootElement") } getPath() { const t = []; let e = this; while (e.parent) { t.unshift(e.index); e = e.parent } return t } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this : this.parent; while (n) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } getCommonAncestor(t, e = {}) { const n = this.getAncestors(e); const i = t.getAncestors(e); let o = 0; while (n[o] == i[o] && n[o]) { o++ } return o === 0 ? null : n[o - 1] } isBefore(t) { if (this == t) { return false } if (this.root !== t.root) { return false } const e = this.getPath(); const n = t.getPath(); const i = Et(e, n); switch (i) { case "prefix": return true; case "extension": return false; default: return e[i] < n[i] } } isAfter(t) { if (this == t) { return false } if (this.root !== t.root) { return false } return !this.isBefore(t) } _remove() { this.parent._removeChildren(this.index) } _fireChange(t, e) { this.fire(`change:${t}`, e); if (this.parent) { this.parent._fireChange(t, e) } } toJSON() { const t = _u(this); delete t.parent; return t } } Au.prototype.is = function (t) { return t === "node" || t === "view:node" }; class Cu extends Au { constructor(t, e) { super(t); this._textData = e } get data() { return this._textData } get _data() { return this.data } set _data(t) { this._fireChange("text", this); this._textData = t } isSimilar(t) { if (!(t instanceof Cu)) { return false } return this === t || this.data === t.data } _clone() { return new Cu(this.document, this.data) } } Cu.prototype.is = function (t) { return t === "$text" || t === "view:$text" || t === "text" || t === "view:text" || t === "node" || t === "view:node" }; class vu extends ku { constructor(t, e, n) { super(); this.textNode = t; if (e < 0 || e > t.data.length) { throw new z("view-textproxy-wrong-offsetintext", this) } if (n < 0 || e + n > t.data.length) { throw new z("view-textproxy-wrong-length", this) } this.data = t.data.substring(e, e + n); this.offsetInText = e } get offsetSize() { return this.data.length } get isPartial() { return this.data.length !== this.textNode.data.length } get parent() { return this.textNode.parent } get root() { return this.textNode.root } get document() { return this.textNode.document } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this.textNode : this.parent; while (n !== null) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } } vu.prototype.is = function (t) { return t === "$textProxy" || t === "view:$textProxy" || t === "textProxy" || t === "view:textProxy" }; class yu { constructor(...t) { this._patterns = []; this.add(...t) } add(...t) { for (let e of t) { if (typeof e == "string" || e instanceof RegExp) { e = { name: e } } this._patterns.push(e) } } match(...t) { for (const e of t) { for (const t of this._patterns) { const n = xu(e, t); if (n) { return { element: e, pattern: t, match: n } } } } return null } matchAll(...t) { const e = []; for (const n of t) { for (const t of this._patterns) { const i = xu(n, t); if (i) { e.push({ element: n, pattern: t, match: i }) } } } return e.length > 0 ? e : null } getElementName() { if (this._patterns.length !== 1) { return null } const t = this._patterns[0]; const e = t.name; return typeof t != "function" && e && !(e instanceof RegExp) ? e : null } } function xu(t, e) { if (typeof e == "function") { return e(t) } const n = {}; if (e.name) { n.name = Eu(e.name, t.name); if (!n.name) { return null } } if (e.attributes) { n.attributes = Su(e.attributes, t); if (!n.attributes) { return null } } if (e.classes) { n.classes = Nu(e.classes, t); if (!n.classes) { return null } } if (e.styles) { n.styles = Bu(e.styles, t); if (!n.styles) { return null } } return n } function Eu(t, e) { if (t instanceof RegExp) { return !!e.match(t) } return t === e } function Du(t, e, n) { const i = Iu(t); const o = Array.from(e); const r = []; i.forEach((([t, e]) => { o.forEach((i => { if (Tu(t, i) && Mu(e, i, n)) { r.push(i) } })) })); if (!i.length || r.length < i.length) { return undefined } return r } function Iu(t) { if (Array.isArray(t)) { return t.map((t => { if (me(t)) { if (t.key === undefined || t.value === undefined) { P("matcher-pattern-missing-key-or-value", t) } return [t.key, t.value] } return [t, true] })) } if (me(t)) { return Object.entries(t) } return [[t, true]] } function Tu(t, e) { return t === true || t === e || t instanceof RegExp && e.match(t) } function Mu(t, e, n) { if (t === true) { return true } const i = n(e); return t === i || t instanceof RegExp && !!String(i).match(t) } function Su(t, e) { const n = new Set(e.getAttributeKeys()); if (me(t)) { if (t.style !== undefined) { P("matcher-pattern-deprecated-attributes-style-key", t) } if (t.class !== undefined) { P("matcher-pattern-deprecated-attributes-class-key", t) } } else { n.delete("style"); n.delete("class") } return Du(t, n, (t => e.getAttribute(t))) } function Nu(t, e) { return Du(t, e.getClassNames(), (() => { })) } function Bu(t, e) { return Du(t, e.getStyleNames(true), (t => e.getStyle(t))) } var zu = "[object Symbol]"; function Pu(t) { return typeof t == "symbol" || Xt(t) && Qt(t) == zu } const Lu = Pu; var Ou = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ru = /^\w*$/; function ju(t, e) { if (Zt(t)) { return false } var n = typeof t; if (n == "number" || n == "symbol" || n == "boolean" || t == null || Lu(t)) { return true } return Ru.test(t) || !Ou.test(t) || e != null && t in Object(e) } const Vu = ju; var Fu = "Expected a function"; function Hu(t, e) { if (typeof t != "function" || e != null && typeof e != "function") { throw new TypeError(Fu) } var n = function () { var i = arguments, o = e ? e.apply(this, i) : i[0], r = n.cache; if (r.has(o)) { return r.get(o) } var s = t.apply(this, i); n.cache = r.set(o, s) || r; return s }; n.cache = new (Hu.Cache || ti); return n } Hu.Cache = ti; const Uu = Hu; var Wu = 500; function Gu(t) { var e = Uu(t, (function (t) { if (n.size === Wu) { n.clear() } return t })); var n = e.cache; return e } const qu = Gu; var Yu = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g; var $u = /\\(\\)?/g; var Qu = qu((function (t) { var e = []; if (t.charCodeAt(0) === 46) { e.push("") } t.replace(Yu, (function (t, n, i, o) { e.push(i ? o.replace($u, "$1") : n || t) })); return e })); const Ku = Qu; function Zu(t, e) { var n = -1, i = t == null ? 0 : t.length, o = Array(i); while (++n < i) { o[n] = e(t[n], n, t) } return o } const Ju = Zu; var Xu = 1 / 0; var th = zt ? zt.prototype : undefined, eh = th ? th.toString : undefined; function nh(t) { if (typeof t == "string") { return t } if (Zt(t)) { return Ju(t, nh) + "" } if (Lu(t)) { return eh ? eh.call(t) : "" } var e = t + ""; return e == "0" && 1 / t == -Xu ? "-0" : e } const ih = nh; function oh(t) { return t == null ? "" : ih(t) } const rh = oh; function sh(t, e) { if (Zt(t)) { return t } return Vu(t, e) ? [t] : Ku(rh(t)) } const ah = sh; function ch(t) { var e = t == null ? 0 : t.length; return e ? t[e - 1] : undefined } const lh = ch; var dh = 1 / 0; function uh(t) { if (typeof t == "string" || Lu(t)) { return t } var e = t + ""; return e == "0" && 1 / t == -dh ? "-0" : e } const hh = uh; function fh(t, e) { e = ah(e, t); var n = 0, i = e.length; while (t != null && n < i) { t = t[hh(e[n++])] } return n && n == i ? t : undefined } const gh = fh; function mh(t, e, n) { var i = -1, o = t.length; if (e < 0) { e = -e > o ? 0 : o + e } n = n > o ? o : n; if (n < 0) { n += o } o = e > n ? 0 : n - e >>> 0; e >>>= 0; var r = Array(o); while (++i < o) { r[i] = t[i + e] } return r } const ph = mh; function kh(t, e) { return e.length < 2 ? t : gh(t, ph(e, 0, -1)) } const bh = kh; function wh(t, e) { e = ah(e, t); t = bh(t, e); return t == null || delete t[hh(lh(e))] } const _h = wh; function Ah(t, e) { return t == null ? true : _h(t, e) } const Ch = Ah; function vh(t, e, n) { var i = t == null ? undefined : gh(t, e); return i === undefined ? n : i } const yh = vh; function xh(t, e, n) { if (n !== undefined && !we(t[e], n) || n === undefined && !(e in t)) { ui(t, e, n) } } const Eh = xh; function Dh(t) { return function (e, n, i) { var o = -1, r = Object(e), s = i(e), a = s.length; while (a--) { var c = s[t ? a : ++o]; if (n(r[c], c, r) === false) { break } } return e } } const Ih = Dh; var Th = Ih(); const Mh = Th; function Sh(t) { return Xt(t) && Uo(t) } const Nh = Sh; function Bh(t, e) { if (e === "constructor" && typeof t[e] === "function") { return } if (e == "__proto__") { return } return t[e] } const zh = Bh; function Ph(t) { return ki(t, er(t)) } const Lh = Ph; function Oh(t, e, n, i, o, r, s) { var a = zh(t, n), c = zh(e, n), l = s.get(c); if (l) { Eh(t, n, l); return } var d = r ? r(a, c, n + "", t, e, s) : undefined; var u = d === undefined; if (u) { var h = Zt(c), f = !h && Li(c), g = !h && !f && Io(c); d = c; if (h || f || g) { if (Zt(a)) { d = a } else if (Nh(a)) { d = hr(a) } else if (f) { u = false; d = dr(c, true) } else if (g) { u = false; d = Cs(c, true) } else { d = [] } } else if (me(c) || Di(c)) { d = a; if (Di(a)) { d = Lh(a) } else if (!st(a) || Ye(a)) { d = $s(c) } } else { u = false } } if (u) { s.set(c, d); o(d, c, i, r, s); s["delete"](c) } Eh(t, n, d) } const Rh = Oh; function jh(t, e, n, i, o) { if (t === e) { return } Mh(e, (function (r, s) { o || (o = new ri); if (st(r)) { Rh(t, e, s, n, jh, i, o) } else { var a = i ? i(zh(t, s), r, s + "", t, e, o) : undefined; if (a === undefined) { a = r } Eh(t, s, a) } }), er) } const Vh = jh; function Fh(t) { return t } const Hh = Fh; function Uh(t, e, n) { switch (n.length) { case 0: return t.call(e); case 1: return t.call(e, n[0]); case 2: return t.call(e, n[0], n[1]); case 3: return t.call(e, n[0], n[1], n[2]) }return t.apply(e, n) } const Wh = Uh; var Gh = Math.max; function qh(t, e, n) { e = Gh(e === undefined ? t.length - 1 : e, 0); return function () { var i = arguments, o = -1, r = Gh(i.length - e, 0), s = Array(r); while (++o < r) { s[o] = i[e + o] } o = -1; var a = Array(e + 1); while (++o < e) { a[o] = i[o] } a[e] = n(s); return Wh(t, this, a) } } const Yh = qh; function $h(t) { return function () { return t } } const Qh = $h; var Kh = !li ? Hh : function (t, e) { return li(t, "toString", { configurable: true, enumerable: false, value: Qh(e), writable: true }) }; const Zh = Kh; var Jh = 800, Xh = 16; var tf = Date.now; function ef(t) { var e = 0, n = 0; return function () { var i = tf(), o = Xh - (i - n); n = i; if (o > 0) { if (++e >= Jh) { return arguments[0] } } else { e = 0 } return t.apply(undefined, arguments) } } const nf = ef; var of = nf(Zh); const rf = of; function sf(t, e) { return rf(Yh(t, e, Hh), t + "") } const af = sf; function cf(t, e, n) { if (!st(n)) { return false } var i = typeof e; if (i == "number" ? Uo(n) && Vi(e, n.length) : i == "string" && e in n) { return we(n[e], t) } return false } const lf = cf; function df(t) { return af((function (e, n) { var i = -1, o = n.length, r = o > 1 ? n[o - 1] : undefined, s = o > 2 ? n[2] : undefined; r = t.length > 3 && typeof r == "function" ? (o--, r) : undefined; if (s && lf(n[0], n[1], s)) { r = o < 3 ? undefined : r; o = 1 } e = Object(e); while (++i < o) { var a = n[i]; if (a) { t(e, a, i, r) } } return e })) } const uf = df; var hf = uf((function (t, e, n) { Vh(t, e, n) })); const ff = hf; function gf(t, e, n, i) { if (!st(t)) { return t } e = ah(e, t); var o = -1, r = e.length, s = r - 1, a = t; while (a != null && ++o < r) { var c = hh(e[o]), l = n; if (c === "__proto__" || c === "constructor" || c === "prototype") { return t } if (o != s) { var d = a[c]; l = i ? i(d, c, a) : undefined; if (l === undefined) { l = st(d) ? d : Vi(e[o + 1]) ? [] : {} } } mi(a, c, l); a = a[c] } return t } const mf = gf; function pf(t, e, n) { return t == null ? t : mf(t, e, n) } const kf = pf; class bf { constructor(t) { this._styles = {}; this._styleProcessor = t } get isEmpty() { const t = Object.entries(this._styles); const e = Array.from(t); return !e.length } get size() { if (this.isEmpty) { return 0 } return this.getStyleNames().length } setTo(t) { this.clear(); const e = Array.from(_f(t).entries()); for (const [t, n] of e) { this._styleProcessor.toNormalizedForm(t, n, this._styles) } } has(t) { if (this.isEmpty) { return false } const e = this._styleProcessor.getReducedForm(t, this._styles); const n = e.find((([e]) => e === t)); return Array.isArray(n) } set(t, e) { if (st(t)) { for (const [e, n] of Object.entries(t)) { this._styleProcessor.toNormalizedForm(e, n, this._styles) } } else { this._styleProcessor.toNormalizedForm(t, e, this._styles) } } remove(t) { const e = Af(t); Ch(this._styles, e); delete this._styles[t]; this._cleanEmptyObjectsOnPath(e) } getNormalized(t) { return this._styleProcessor.getNormalized(t, this._styles) } toString() { if (this.isEmpty) { return "" } return this._getStylesEntries().map((t => t.join(":"))).sort().join(";") + ";" } getAsString(t) { if (this.isEmpty) { return } if (this._styles[t] && !st(this._styles[t])) { return this._styles[t] } const e = this._styleProcessor.getReducedForm(t, this._styles); const n = e.find((([e]) => e === t)); if (Array.isArray(n)) { return n[1] } } getStyleNames(t = false) { if (this.isEmpty) { return [] } if (t) { return this._styleProcessor.getStyleNames(this._styles) } const e = this._getStylesEntries(); return e.map((([t]) => t)) } clear() { this._styles = {} } _getStylesEntries() { const t = []; const e = Object.keys(this._styles); for (const n of e) { t.push(...this._styleProcessor.getReducedForm(n, this._styles)) } return t } _cleanEmptyObjectsOnPath(t) { const e = t.split("."); const n = e.length > 1; if (!n) { return } const i = e.splice(0, e.length - 1).join("."); const o = yh(this._styles, i); if (!o) { return } const r = !Array.from(Object.keys(o)).length; if (r) { this.remove(i) } } } class wf { constructor() { this._normalizers = new Map; this._extractors = new Map; this._reducers = new Map; this._consumables = new Map } toNormalizedForm(t, e, n) { if (st(e)) { Cf(n, Af(t), e); return } if (this._normalizers.has(t)) { const i = this._normalizers.get(t); const { path: o, value: r } = i(e); Cf(n, o, r) } else { Cf(n, t, e) } } getNormalized(t, e) { if (!t) { return ff({}, e) } if (e[t] !== undefined) { return e[t] } if (this._extractors.has(t)) { const n = this._extractors.get(t); if (typeof n === "string") { return yh(e, n) } const i = n(t, e); if (i) { return i } } return yh(e, Af(t)) } getReducedForm(t, e) { const n = this.getNormalized(t, e); if (n === undefined) { return [] } if (this._reducers.has(t)) { const e = this._reducers.get(t); return e(n) } return [[t, n]] } getStyleNames(t) { const e = Array.from(this._consumables.keys()).filter((e => { const n = this.getNormalized(e, t); if (n && typeof n == "object") { return Object.keys(n).length } return n })); const n = new Set([...e, ...Object.keys(t)]); return Array.from(n.values()) } getRelatedStyles(t) { return this._consumables.get(t) || [] } setNormalizer(t, e) { this._normalizers.set(t, e) } setExtractor(t, e) { this._extractors.set(t, e) } setReducer(t, e) { this._reducers.set(t, e) } setStyleRelation(t, e) { this._mapStyleNames(t, e); for (const n of e) { this._mapStyleNames(n, [t]) } } _mapStyleNames(t, e) { if (!this._consumables.has(t)) { this._consumables.set(t, []) } this._consumables.get(t).push(...e) } } function _f(t) { let e = null; let n = 0; let i = 0; let o = null; const r = new Map; if (t === "") { return r } if (t.charAt(t.length - 1) != ";") { t = t + ";" } for (let s = 0; s < t.length; s++) { const a = t.charAt(s); if (e === null) { switch (a) { case ":": if (!o) { o = t.substr(n, s - n); i = s + 1 } break; case '"': case "'": e = a; break; case ";": { const e = t.substr(i, s - i); if (o) { r.set(o.trim(), e.trim()) } o = null; n = s + 1; break } } } else if (a === e) { e = null } } return r } function Af(t) { return t.replace("-", ".") } function Cf(t, e, n) { let i = n; if (st(n)) { i = ff({}, yh(t, e), n) } kf(t, e, i) } class vf extends Au { constructor(t, e, n, i) { super(t); this._unsafeAttributesToRender = []; this._customProperties = new Map; this.name = e; this._attrs = yf(n); this._children = []; if (i) { this._insertChild(0, i) } this._classes = new Set; if (this._attrs.has("class")) { const t = this._attrs.get("class"); xf(this._classes, t); this._attrs.delete("class") } this._styles = new bf(this.document.stylesProcessor); if (this._attrs.has("style")) { this._styles.setTo(this._attrs.get("style")); this._attrs.delete("style") } } get childCount() { return this._children.length } get isEmpty() { return this._children.length === 0 } getChild(t) { return this._children[t] } getChildIndex(t) { return this._children.indexOf(t) } getChildren() { return this._children[Symbol.iterator]() } *getAttributeKeys() { if (this._classes.size > 0) { yield "class" } if (!this._styles.isEmpty) { yield "style" } yield* this._attrs.keys() } *getAttributes() { yield* this._attrs.entries(); if (this._classes.size > 0) { yield ["class", this.getAttribute("class")] } if (!this._styles.isEmpty) { yield ["style", this.getAttribute("style")] } } getAttribute(t) { if (t == "class") { if (this._classes.size > 0) { return [...this._classes].join(" ") } return undefined } if (t == "style") { const t = this._styles.toString(); return t == "" ? undefined : t } return this._attrs.get(t) } hasAttribute(t) { if (t == "class") { return this._classes.size > 0 } if (t == "style") { return !this._styles.isEmpty } return this._attrs.has(t) } isSimilar(t) { if (!(t instanceof vf)) { return false } if (this === t) { return true } if (this.name != t.name) { return false } if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) { return false } for (const [e, n] of this._attrs) { if (!t._attrs.has(e) || t._attrs.get(e) !== n) { return false } } for (const e of this._classes) { if (!t._classes.has(e)) { return false } } for (const e of this._styles.getStyleNames()) { if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) { return false } } return true } hasClass(...t) { for (const e of t) { if (!this._classes.has(e)) { return false } } return true } getClassNames() { return this._classes.keys() } getStyle(t) { return this._styles.getAsString(t) } getNormalizedStyle(t) { return this._styles.getNormalized(t) } getStyleNames(t) { return this._styles.getStyleNames(t) } hasStyle(...t) { for (const e of t) { if (!this._styles.has(e)) { return false } } return true } findAncestor(...t) { const e = new yu(...t); let n = this.parent; while (n && !n.is("documentFragment")) { if (e.match(n)) { return n } n = n.parent } return null } getCustomProperty(t) { return this._customProperties.get(t) } *getCustomProperties() { yield* this._customProperties.entries() } getIdentity() { const t = Array.from(this._classes).sort().join(","); const e = this._styles.toString(); const n = Array.from(this._attrs).map((t => `${t[0]}="${t[1]}"`)).sort().join(" "); return this.name + (t == "" ? "" : ` class="${t}"`) + (!e ? "" : ` style="${e}"`) + (n == "" ? "" : ` ${n}`) } shouldRenderUnsafeAttribute(t) { return this._unsafeAttributesToRender.includes(t) } _clone(t = false) { const e = []; if (t) { for (const n of this.getChildren()) { e.push(n._clone(t)) } } const n = new this.constructor(this.document, this.name, this._attrs, e); n._classes = new Set(this._classes); n._styles.set(this._styles.getNormalized()); n._customProperties = new Map(this._customProperties); n.getFillerOffset = this.getFillerOffset; n._unsafeAttributesToRender = this._unsafeAttributesToRender; return n } _appendChild(t) { return this._insertChild(this.childCount, t) } _insertChild(t, e) { this._fireChange("children", this); let n = 0; const i = Ef(this.document, e); for (const e of i) { if (e.parent !== null) { e._remove() } e.parent = this; e.document = this.document; this._children.splice(t, 0, e); t++; n++ } return n } _removeChildren(t, e = 1) { this._fireChange("children", this); for (let n = t; n < t + e; n++) { this._children[n].parent = null } return this._children.splice(t, e) } _setAttribute(t, e) { const n = String(e); this._fireChange("attributes", this); if (t == "class") { xf(this._classes, n) } else if (t == "style") { this._styles.setTo(n) } else { this._attrs.set(t, n) } } _removeAttribute(t) { this._fireChange("attributes", this); if (t == "class") { if (this._classes.size > 0) { this._classes.clear(); return true } return false } if (t == "style") { if (!this._styles.isEmpty) { this._styles.clear(); return true } return false } return this._attrs.delete(t) } _addClass(t) { this._fireChange("attributes", this); for (const e of tl(t)) { this._classes.add(e) } } _removeClass(t) { this._fireChange("attributes", this); for (const e of tl(t)) { this._classes.delete(e) } } _setStyle(t, e) { this._fireChange("attributes", this); if (typeof t != "string") { this._styles.set(t) } else { this._styles.set(t, e) } } _removeStyle(t) { this._fireChange("attributes", this); for (const e of tl(t)) { this._styles.remove(e) } } _setCustomProperty(t, e) { this._customProperties.set(t, e) } _removeCustomProperty(t) { return this._customProperties.delete(t) } } vf.prototype.is = function (t, e) { if (!e) { return t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "element" || t === "view:element") } }; function yf(t) { const e = fl(t); for (const [t, n] of e) { if (n === null) { e.delete(t) } else if (typeof n != "string") { e.set(t, String(n)) } } return e } function xf(t, e) { const n = e.split(/\s+/); t.clear(); n.forEach((e => t.add(e))) } function Ef(t, e) { if (typeof e == "string") { return [new Cu(t, e)] } if (!Dt(e)) { e = [e] } return Array.from(e).map((e => { if (typeof e == "string") { return new Cu(t, e) } if (e instanceof vu) { return new Cu(t, e.data) } return e })) } class Df extends vf { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = If } } Df.prototype.is = function (t, e) { if (!e) { return t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element") } }; function If() { const t = [...this.getChildren()]; const e = t[this.childCount - 1]; if (e && e.is("element", "br")) { return this.childCount } for (const e of t) { if (!e.is("uiElement")) { return null } } return this.childCount } class Tf extends (ft(Df)) { constructor(t, e, n, i) { super(t, e, n, i); this.set("isReadOnly", false); this.set("isFocused", false); this.bind("isReadOnly").to(t); this.bind("isFocused").to(t, "isFocused", (e => e && t.selection.editableElement == this)); this.listenTo(t.selection, "change", (() => { this.isFocused = t.isFocused && t.selection.editableElement == this })) } destroy() { this.stopListening() } } Tf.prototype.is = function (t, e) { if (!e) { return t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element") } }; const Mf = Symbol("rootName"); class Sf extends Tf { constructor(t, e) { super(t, e); this.rootName = "main" } get rootName() { return this.getCustomProperty(Mf) } set rootName(t) { this._setCustomProperty(Mf, t) } set _name(t) { this.name = t } } Sf.prototype.is = function (t, e) { if (!e) { return t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element") } }; class Nf { constructor(t = {}) { if (!t.boundaries && !t.startPosition) { throw new z("view-tree-walker-no-start-position", null) } if (t.direction && t.direction != "forward" && t.direction != "backward") { throw new z("view-tree-walker-unknown-direction", t.startPosition, { direction: t.direction }) } this.boundaries = t.boundaries || null; if (t.startPosition) { this._position = Bf._createAt(t.startPosition) } else { this._position = Bf._createAt(t.boundaries[t.direction == "backward" ? "end" : "start"]) } this.direction = t.direction || "forward"; this.singleCharacters = !!t.singleCharacters; this.shallow = !!t.shallow; this.ignoreElementEnd = !!t.ignoreElementEnd; this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null; this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null } [Symbol.iterator]() { return this } get position() { return this._position } skip(t) { let e; let n; do { n = this.position; e = this.next() } while (!e.done && t(e.value)); if (!e.done) { this._position = n } } next() { if (this.direction == "forward") { return this._next() } else { return this._previous() } } _next() { let t = this.position.clone(); const e = this.position; const n = t.parent; if (n.parent === null && t.offset === n.childCount) { return { done: true, value: undefined } } if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) { return { done: true, value: undefined } } let i; if (n instanceof Cu) { if (t.isAtEnd) { this._position = Bf._createAfter(n); return this._next() } i = n.data[t.offset] } else { i = n.getChild(t.offset) } if (i instanceof vf) { if (!this.shallow) { t = new Bf(i, 0) } else { t.offset++ } this._position = t; return this._formatReturnValue("elementStart", i, e, t, 1) } else if (i instanceof Cu) { if (this.singleCharacters) { t = new Bf(i, 0); this._position = t; return this._next() } else { let n = i.data.length; let o; if (i == this._boundaryEndParent) { n = this.boundaries.end.offset; o = new vu(i, 0, n); t = Bf._createAfter(o) } else { o = new vu(i, 0, i.data.length); t.offset++ } this._position = t; return this._formatReturnValue("text", o, e, t, n) } } else if (typeof i == "string") { let i; if (this.singleCharacters) { i = 1 } else { const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length; i = e - t.offset } const o = new vu(n, t.offset, i); t.offset += i; this._position = t; return this._formatReturnValue("text", o, e, t, i) } else { t = Bf._createAfter(n); this._position = t; if (this.ignoreElementEnd) { return this._next() } else { return this._formatReturnValue("elementEnd", n, e, t) } } } _previous() { let t = this.position.clone(); const e = this.position; const n = t.parent; if (n.parent === null && t.offset === 0) { return { done: true, value: undefined } } if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) { return { done: true, value: undefined } } let i; if (n instanceof Cu) { if (t.isAtStart) { this._position = Bf._createBefore(n); return this._previous() } i = n.data[t.offset - 1] } else { i = n.getChild(t.offset - 1) } if (i instanceof vf) { if (!this.shallow) { t = new Bf(i, i.childCount); this._position = t; if (this.ignoreElementEnd) { return this._previous() } else { return this._formatReturnValue("elementEnd", i, e, t) } } else { t.offset--; this._position = t; return this._formatReturnValue("elementStart", i, e, t, 1) } } else if (i instanceof Cu) { if (this.singleCharacters) { t = new Bf(i, i.data.length); this._position = t; return this._previous() } else { let n = i.data.length; let o; if (i == this._boundaryStartParent) { const e = this.boundaries.start.offset; o = new vu(i, e, i.data.length - e); n = o.data.length; t = Bf._createBefore(o) } else { o = new vu(i, 0, i.data.length); t.offset-- } this._position = t; return this._formatReturnValue("text", o, e, t, n) } } else if (typeof i == "string") { let i; if (!this.singleCharacters) { const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0; i = t.offset - e } else { i = 1 } t.offset -= i; const o = new vu(n, t.offset, i); this._position = t; return this._formatReturnValue("text", o, e, t, i) } else { t = Bf._createBefore(n); this._position = t; return this._formatReturnValue("elementStart", n, e, t, 1) } } _formatReturnValue(t, e, n, i, o) { if (e instanceof vu) { if (e.offsetInText + e.data.length == e.textNode.data.length) { if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) { i = Bf._createAfter(e.textNode); this._position = i } else { n = Bf._createAfter(e.textNode) } } if (e.offsetInText === 0) { if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) { i = Bf._createBefore(e.textNode); this._position = i } else { n = Bf._createBefore(e.textNode) } } } return { done: false, value: { type: t, item: e, previousPosition: n, nextPosition: i, length: o } } } } class Bf extends ku { constructor(t, e) { super(); this.parent = t; this.offset = e } get nodeAfter() { if (this.parent.is("$text")) { return null } return this.parent.getChild(this.offset) || null } get nodeBefore() { if (this.parent.is("$text")) { return null } return this.parent.getChild(this.offset - 1) || null } get isAtStart() { return this.offset === 0 } get isAtEnd() { const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount; return this.offset === t } get root() { return this.parent.root } get editableElement() { let t = this.parent; while (!(t instanceof Tf)) { if (t.parent) { t = t.parent } else { return null } } return t } getShiftedBy(t) { const e = Bf._createAt(this); const n = e.offset + t; e.offset = n < 0 ? 0 : n; return e } getLastMatchingPosition(t, e = {}) { e.startPosition = this; const n = new Nf(e); n.skip(t); return n.position } getAncestors() { if (this.parent.is("documentFragment")) { return [this.parent] } else { return this.parent.getAncestors({ includeSelf: true }) } } getCommonAncestor(t) { const e = this.getAncestors(); const n = t.getAncestors(); let i = 0; while (e[i] == n[i] && e[i]) { i++ } return i === 0 ? null : e[i - 1] } isEqual(t) { return this.parent == t.parent && this.offset == t.offset } isBefore(t) { return this.compareWith(t) == "before" } isAfter(t) { return this.compareWith(t) == "after" } compareWith(t) { if (this.root !== t.root) { return "different" } if (this.isEqual(t)) { return "same" } const e = this.parent.is("node") ? this.parent.getPath() : []; const n = t.parent.is("node") ? t.parent.getPath() : []; e.push(this.offset); n.push(t.offset); const i = Et(e, n); switch (i) { case "prefix": return "before"; case "extension": return "after"; default: return e[i] < n[i] ? "before" : "after" } } getWalker(t = {}) { t.startPosition = this; return new Nf(t) } clone() { return new Bf(this.parent, this.offset) } static _createAt(t, e) { if (t instanceof Bf) { return new this(t.parent, t.offset) } else { const n = t; if (e == "end") { e = n.is("$text") ? n.data.length : n.childCount } else if (e == "before") { return this._createBefore(n) } else if (e == "after") { return this._createAfter(n) } else if (e !== 0 && !e) { throw new z("view-createpositionat-offset-required", n) } return new Bf(n, e) } } static _createAfter(t) { if (t.is("$textProxy")) { return new Bf(t.textNode, t.offsetInText + t.data.length) } if (!t.parent) { throw new z("view-position-after-root", t, { root: t }) } return new Bf(t.parent, t.index + 1) } static _createBefore(t) { if (t.is("$textProxy")) { return new Bf(t.textNode, t.offsetInText) } if (!t.parent) { throw new z("view-position-before-root", t, { root: t }) } return new Bf(t.parent, t.index) } } Bf.prototype.is = function (t) { return t === "position" || t === "view:position" }; class zf extends ku { constructor(t, e = null) { super(); this.start = t.clone(); this.end = e ? e.clone() : t.clone() } *[Symbol.iterator]() { yield* new Nf({ boundaries: this, ignoreElementEnd: true }) } get isCollapsed() { return this.start.isEqual(this.end) } get isFlat() { return this.start.parent === this.end.parent } get root() { return this.start.root } getEnlarged() { let t = this.start.getLastMatchingPosition(Pf, { direction: "backward" }); let e = this.end.getLastMatchingPosition(Pf); if (t.parent.is("$text") && t.isAtStart) { t = Bf._createBefore(t.parent) } if (e.parent.is("$text") && e.isAtEnd) { e = Bf._createAfter(e.parent) } return new zf(t, e) } getTrimmed() { let t = this.start.getLastMatchingPosition(Pf); if (t.isAfter(this.end) || t.isEqual(this.end)) { return new zf(t, t) } let e = this.end.getLastMatchingPosition(Pf, { direction: "backward" }); const n = t.nodeAfter; const i = e.nodeBefore; if (n && n.is("$text")) { t = new Bf(n, 0) } if (i && i.is("$text")) { e = new Bf(i, i.data.length) } return new zf(t, e) } isEqual(t) { return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end) } containsPosition(t) { return t.isAfter(this.start) && t.isBefore(this.end) } containsRange(t, e = false) { if (t.isCollapsed) { e = false } const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start); const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end); return n && i } getDifference(t) { const e = []; if (this.isIntersecting(t)) { if (this.containsPosition(t.start)) { e.push(new zf(this.start, t.start)) } if (this.containsPosition(t.end)) { e.push(new zf(t.end, this.end)) } } else { e.push(this.clone()) } return e } getIntersection(t) { if (this.isIntersecting(t)) { let e = this.start; let n = this.end; if (this.containsPosition(t.start)) { e = t.start } if (this.containsPosition(t.end)) { n = t.end } return new zf(e, n) } return null } getWalker(t = {}) { t.boundaries = this; return new Nf(t) } getCommonAncestor() { return this.start.getCommonAncestor(this.end) } getContainedElement() { if (this.isCollapsed) { return null } let t = this.start.nodeAfter; let e = this.end.nodeBefore; if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) { t = this.start.parent.nextSibling } if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) { e = this.end.parent.previousSibling } if (t && t.is("element") && t === e) { return t } return null } clone() { return new zf(this.start, this.end) } *getItems(t = {}) { t.boundaries = this; t.ignoreElementEnd = true; const e = new Nf(t); for (const t of e) { yield t.item } } *getPositions(t = {}) { t.boundaries = this; const e = new Nf(t); yield e.position; for (const t of e) { yield t.nextPosition } } isIntersecting(t) { return this.start.isBefore(t.end) && this.end.isAfter(t.start) } static _createFromParentsAndOffsets(t, e, n, i) { return new this(new Bf(t, e), new Bf(n, i)) } static _createFromPositionAndShift(t, e) { const n = t; const i = t.getShiftedBy(e); return e > 0 ? new this(n, i) : new this(i, n) } static _createIn(t) { return this._createFromParentsAndOffsets(t, 0, t, t.childCount) } static _createOn(t) { const e = t.is("$textProxy") ? t.offsetSize : 1; return this._createFromPositionAndShift(Bf._createBefore(t), e) } } zf.prototype.is = function (t) { return t === "range" || t === "view:range" }; function Pf(t) { if (t.item.is("attributeElement") || t.item.is("uiElement")) { return true } return false } class Lf extends (Y(ku)) { constructor(...t) { super(); this._ranges = []; this._lastRangeBackward = false; this._isFake = false; this._fakeSelectionLabel = ""; if (t.length) { this.setTo(...t) } } get isFake() { return this._isFake } get fakeSelectionLabel() { return this._fakeSelectionLabel } get anchor() { if (!this._ranges.length) { return null } const t = this._ranges[this._ranges.length - 1]; const e = this._lastRangeBackward ? t.end : t.start; return e.clone() } get focus() { if (!this._ranges.length) { return null } const t = this._ranges[this._ranges.length - 1]; const e = this._lastRangeBackward ? t.start : t.end; return e.clone() } get isCollapsed() { return this.rangeCount === 1 && this._ranges[0].isCollapsed } get rangeCount() { return this._ranges.length } get isBackward() { return !this.isCollapsed && this._lastRangeBackward } get editableElement() { if (this.anchor) { return this.anchor.editableElement } return null } *getRanges() { for (const t of this._ranges) { yield t.clone() } } getFirstRange() { let t = null; for (const e of this._ranges) { if (!t || e.start.isBefore(t.start)) { t = e } } return t ? t.clone() : null } getLastRange() { let t = null; for (const e of this._ranges) { if (!t || e.end.isAfter(t.end)) { t = e } } return t ? t.clone() : null } getFirstPosition() { const t = this.getFirstRange(); return t ? t.start.clone() : null } getLastPosition() { const t = this.getLastRange(); return t ? t.end.clone() : null } isEqual(t) { if (this.isFake != t.isFake) { return false } if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) { return false } if (this.rangeCount != t.rangeCount) { return false } else if (this.rangeCount === 0) { return true } if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) { return false } for (const e of this._ranges) { let n = false; for (const i of t._ranges) { if (e.isEqual(i)) { n = true; break } } if (!n) { return false } } return true } isSimilar(t) { if (this.isBackward != t.isBackward) { return false } const e = xt(this.getRanges()); const n = xt(t.getRanges()); if (e != n) { return false } if (e == 0) { return true } for (let e of this.getRanges()) { e = e.getTrimmed(); let n = false; for (let i of t.getRanges()) { i = i.getTrimmed(); if (e.start.isEqual(i.start) && e.end.isEqual(i.end)) { n = true; break } } if (!n) { return false } } return true } getSelectedElement() { if (this.rangeCount !== 1) { return null } return this.getFirstRange().getContainedElement() } setTo(...t) { let [e, n, i] = t; if (typeof n == "object") { i = n; n = undefined } if (e === null) { this._setRanges([]); this._setFakeOptions(i) } else if (e instanceof Lf || e instanceof Of) { this._setRanges(e.getRanges(), e.isBackward); this._setFakeOptions({ fake: e.isFake, label: e.fakeSelectionLabel }) } else if (e instanceof zf) { this._setRanges([e], i && i.backward); this._setFakeOptions(i) } else if (e instanceof Bf) { this._setRanges([new zf(e)]); this._setFakeOptions(i) } else if (e instanceof Au) { const t = !!i && !!i.backward; let o; if (n === undefined) { throw new z("view-selection-setto-required-second-parameter", this) } else if (n == "in") { o = zf._createIn(e) } else if (n == "on") { o = zf._createOn(e) } else { o = new zf(Bf._createAt(e, n)) } this._setRanges([o], t); this._setFakeOptions(i) } else if (Dt(e)) { this._setRanges(e, i && i.backward); this._setFakeOptions(i) } else { throw new z("view-selection-setto-not-selectable", this) } this.fire("change") } setFocus(t, e) { if (this.anchor === null) { throw new z("view-selection-setfocus-no-ranges", this) } const n = Bf._createAt(t, e); if (n.compareWith(this.focus) == "same") { return } const i = this.anchor; this._ranges.pop(); if (n.compareWith(i) == "before") { this._addRange(new zf(n, i), true) } else { this._addRange(new zf(i, n)) } this.fire("change") } _setRanges(t, e = false) { t = Array.from(t); this._ranges = []; for (const e of t) { this._addRange(e) } this._lastRangeBackward = !!e } _setFakeOptions(t = {}) { this._isFake = !!t.fake; this._fakeSelectionLabel = t.fake ? t.label || "" : "" } _addRange(t, e = false) { if (!(t instanceof zf)) { throw new z("view-selection-add-range-not-range", this) } this._pushRange(t); this._lastRangeBackward = !!e } _pushRange(t) { for (const e of this._ranges) { if (t.isIntersecting(e)) { throw new z("view-selection-range-intersects", this, { addedRange: t, intersectingRange: e }) } } this._ranges.push(new zf(t.start, t.end)) } } Lf.prototype.is = function (t) { return t === "selection" || t === "view:selection" }; class Of extends (Y(ku)) { constructor(...t) { super(); this._selection = new Lf; this._selection.delegate("change").to(this); if (t.length) { this._selection.setTo(...t) } } get isFake() { return this._selection.isFake } get fakeSelectionLabel() { return this._selection.fakeSelectionLabel } get anchor() { return this._selection.anchor } get focus() { return this._selection.focus } get isCollapsed() { return this._selection.isCollapsed } get rangeCount() { return this._selection.rangeCount } get isBackward() { return this._selection.isBackward } get editableElement() { return this._selection.editableElement } get _ranges() { return this._selection._ranges } *getRanges() { yield* this._selection.getRanges() } getFirstRange() { return this._selection.getFirstRange() } getLastRange() { return this._selection.getLastRange() } getFirstPosition() { return this._selection.getFirstPosition() } getLastPosition() { return this._selection.getLastPosition() } getSelectedElement() { return this._selection.getSelectedElement() } isEqual(t) { return this._selection.isEqual(t) } isSimilar(t) { return this._selection.isSimilar(t) } _setTo(...t) { this._selection.setTo(...t) } _setFocus(t, e) { this._selection.setFocus(t, e) } } Of.prototype.is = function (t) { return t === "selection" || t == "documentSelection" || t == "view:selection" || t == "view:documentSelection" }; class Rf extends D { constructor(t, e, n) { super(t, e); this.startRange = n; this._eventPhase = "none"; this._currentTarget = null } get eventPhase() { return this._eventPhase } get currentTarget() { return this._currentTarget } } const jf = Symbol("bubbling contexts"); function Vf(t) { class e extends t { fire(t, ...e) { try { const n = t instanceof D ? t : new D(this, t); const i = Wf(this); if (!i.size) { return } Ff(n, "capturing", this); if (Hf(i, "$capture", n, ...e)) { return n.return } const o = n.startRange || this.selection.getFirstRange(); const r = o ? o.getContainedElement() : null; const s = r ? Boolean(Uf(i, r)) : false; let a = r || Gf(o); Ff(n, "atTarget", a); if (!s) { if (Hf(i, "$text", n, ...e)) { return n.return } Ff(n, "bubbling", a) } while (a) { if (a.is("rootElement")) { if (Hf(i, "$root", n, ...e)) { return n.return } } else if (a.is("element")) { if (Hf(i, a.name, n, ...e)) { return n.return } } if (Hf(i, a, n, ...e)) { return n.return } a = a.parent; Ff(n, "bubbling", a) } Ff(n, "bubbling", this); Hf(i, "$document", n, ...e); return n.return } catch (t) { z.rethrowUnexpectedError(t, this) } } _addEventListener(t, e, n) { const i = tl(n.context || "$document"); const o = Wf(this); for (const r of i) { let i = o.get(r); if (!i) { i = new (Y()); o.set(r, i) } this.listenTo(i, t, e, n) } } _removeEventListener(t, e) { const n = Wf(this); for (const i of n.values()) { this.stopListening(i, t, e) } } } return e } { const t = Vf(Object);["fire", "_addEventListener", "_removeEventListener"].forEach((e => { Vf[e] = t.prototype[e] })) } function Ff(t, e, n) { if (t instanceof Rf) { t._eventPhase = e; t._currentTarget = n } } function Hf(t, e, n, ...i) { const o = typeof e == "string" ? t.get(e) : Uf(t, e); if (!o) { return false } o.fire(n, ...i); return n.stop.called } function Uf(t, e) { for (const [n, i] of t) { if (typeof n == "function" && n(e)) { return i } } return null } function Wf(t) { if (!t[jf]) { t[jf] = new Map } return t[jf] } function Gf(t) { if (!t) { return null } const e = t.start.parent; const n = t.end.parent; const i = e.getPath(); const o = n.getPath(); return i.length > o.length ? e : n } class qf extends (Vf(ft())) { constructor(t) { super(); this._postFixers = new Set; this.selection = new Of; this.roots = new cl({ idProperty: "rootName" }); this.stylesProcessor = t; this.set("isReadOnly", false); this.set("isFocused", false); this.set("isSelecting", false); this.set("isComposing", false) } getRoot(t = "main") { return this.roots.get(t) } registerPostFixer(t) { this._postFixers.add(t) } destroy() { this.roots.map((t => t.destroy())); this.stopListening() } _callPostFixers(t) { let e = false; do { for (const n of this._postFixers) { e = n(t); if (e) { break } } } while (e) } } const Yf = 10; class $f extends vf { constructor(t, e, n, i) { super(t, e, n, i); this._priority = Yf; this._id = null; this._clonesGroup = null; this.getFillerOffset = Qf } get priority() { return this._priority } get id() { return this._id } getElementsWithSameId() { if (this.id === null) { throw new z("attribute-element-get-elements-with-same-id-no-id", this) } return new Set(this._clonesGroup) } isSimilar(t) { if (this.id !== null || t.id !== null) { return this.id === t.id } return super.isSimilar(t) && this.priority == t.priority } _clone(t = false) { const e = super._clone(t); e._priority = this._priority; e._id = this._id; return e } } $f.DEFAULT_PRIORITY = Yf; $f.prototype.is = function (t, e) { if (!e) { return t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element") } }; function Qf() { if (Kf(this)) { return null } let t = this.parent; while (t && t.is("attributeElement")) { if (Kf(t) > 1) { return null } t = t.parent } if (!t || Kf(t) > 1) { return null } return this.childCount } function Kf(t) { return Array.from(t.getChildren()).filter((t => !t.is("uiElement"))).length } class Zf extends vf { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = Jf } _insertChild(t, e) { if (e && (e instanceof Au || Array.from(e).length > 0)) { throw new z("view-emptyelement-cannot-add", [this, e]) } return 0 } } Zf.prototype.is = function (t, e) { if (!e) { return t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element") } }; function Jf() { return null } class Xf extends vf { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = eg } _insertChild(t, e) { if (e && (e instanceof Au || Array.from(e).length > 0)) { throw new z("view-uielement-cannot-add", [this, e]) } return 0 } render(t, e) { return this.toDomElement(t) } toDomElement(t) { const e = t.createElement(this.name); for (const t of this.getAttributeKeys()) { e.setAttribute(t, this.getAttribute(t)) } return e } } Xf.prototype.is = function (t, e) { if (!e) { return t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element") } }; function tg(t) { t.document.on("arrowKey", ((e, n) => ng(e, n, t.domConverter)), { priority: "low" }) } function eg() { return null } function ng(t, e, n) { if (e.keyCode == Fc.arrowright) { const t = e.domTarget.ownerDocument.defaultView.getSelection(); const i = t.rangeCount == 1 && t.getRangeAt(0).collapsed; if (i || e.shiftKey) { const e = t.focusNode; const o = t.focusOffset; const r = n.domPositionToView(e, o); if (r === null) { return } let s = false; const a = r.getLastMatchingPosition((t => { if (t.item.is("uiElement")) { s = true } if (t.item.is("uiElement") || t.item.is("attributeElement")) { return true } return false })); if (s) { const e = n.viewPositionToDom(a); if (i) { t.collapse(e.parent, e.offset) } else { t.extend(e.parent, e.offset) } } } } } class ig extends vf { constructor(t, e, n, i) { super(t, e, n, i); this.getFillerOffset = og } _insertChild(t, e) { if (e && (e instanceof Au || Array.from(e).length > 0)) { throw new z("view-rawelement-cannot-add", [this, e]) } return 0 } render(t, e) { } } ig.prototype.is = function (t, e) { if (!e) { return t === "rawElement" || t === "view:rawElement" || t === this.name || t === "view:" + this.name || t === "element" || t === "view:element" || t === "node" || t === "view:node" } else { return e === this.name && (t === "rawElement" || t === "view:rawElement" || t === "element" || t === "view:element") } }; function og() { return null } class rg extends (Y(ku)) { constructor(t, e) { super(); this._children = []; this._customProperties = new Map; this.document = t; if (e) { this._insertChild(0, e) } } [Symbol.iterator]() { return this._children[Symbol.iterator]() } get childCount() { return this._children.length } get isEmpty() { return this.childCount === 0 } get root() { return this } get parent() { return null } get name() { return undefined } getCustomProperty(t) { return this._customProperties.get(t) } *getCustomProperties() { yield* this._customProperties.entries() } _appendChild(t) { return this._insertChild(this.childCount, t) } getChild(t) { return this._children[t] } getChildIndex(t) { return this._children.indexOf(t) } getChildren() { return this._children[Symbol.iterator]() } _insertChild(t, e) { this._fireChange("children", this); let n = 0; const i = sg(this.document, e); for (const e of i) { if (e.parent !== null) { e._remove() } e.parent = this; this._children.splice(t, 0, e); t++; n++ } return n } _removeChildren(t, e = 1) { this._fireChange("children", this); for (let n = t; n < t + e; n++) { this._children[n].parent = null } return this._children.splice(t, e) } _fireChange(t, e) { this.fire("change:" + t, e) } _setCustomProperty(t, e) { this._customProperties.set(t, e) } _removeCustomProperty(t) { return this._customProperties.delete(t) } } rg.prototype.is = function (t) { return t === "documentFragment" || t === "view:documentFragment" }; function sg(t, e) { if (typeof e == "string") { return [new Cu(t, e)] } if (!Dt(e)) { e = [e] } return Array.from(e).map((e => { if (typeof e == "string") { return new Cu(t, e) } if (e instanceof vu) { return new Cu(t, e.data) } return e })) } class ag { constructor(t) { this._cloneGroups = new Map; this._slotFactory = null; this.document = t } setSelection(...t) { this.document.selection._setTo(...t) } setSelectionFocus(t, e) { this.document.selection._setFocus(t, e) } createDocumentFragment(t) { return new rg(this.document, t) } createText(t) { return new Cu(this.document, t) } createAttributeElement(t, e, n = {}) { const i = new $f(this.document, t, e); if (typeof n.priority === "number") { i._priority = n.priority } if (n.id) { i._id = n.id } if (n.renderUnsafeAttributes) { i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes) } return i } createContainerElement(t, e, n = {}, i = {}) { let o = null; if (me(n)) { i = n } else { o = n } const r = new Df(this.document, t, e, o); if (i.renderUnsafeAttributes) { r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes) } return r } createEditableElement(t, e, n = {}) { const i = new Tf(this.document, t, e); if (n.renderUnsafeAttributes) { i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes) } return i } createEmptyElement(t, e, n = {}) { const i = new Zf(this.document, t, e); if (n.renderUnsafeAttributes) { i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes) } return i } createUIElement(t, e, n) { const i = new Xf(this.document, t, e); if (n) { i.render = n } return i } createRawElement(t, e, n, i = {}) { const o = new ig(this.document, t, e); if (n) { o.render = n } if (i.renderUnsafeAttributes) { o._unsafeAttributesToRender.push(...i.renderUnsafeAttributes) } return o } setAttribute(t, e, n) { n._setAttribute(t, e) } removeAttribute(t, e) { e._removeAttribute(t) } addClass(t, e) { e._addClass(t) } removeClass(t, e) { e._removeClass(t) } setStyle(t, e, n) { if (me(t) && n === undefined) { e._setStyle(t) } else { n._setStyle(t, e) } } removeStyle(t, e) { e._removeStyle(t) } setCustomProperty(t, e, n) { n._setCustomProperty(t, e) } removeCustomProperty(t, e) { return e._removeCustomProperty(t) } breakAttributes(t) { if (t instanceof Bf) { return this._breakAttributes(t) } else { return this._breakAttributesRange(t) } } breakContainer(t) { const e = t.parent; if (!e.is("containerElement")) { throw new z("view-writer-break-non-container-element", this.document) } if (!e.parent) { throw new z("view-writer-break-root", this.document) } if (t.isAtStart) { return Bf._createBefore(e) } else if (!t.isAtEnd) { const n = e._clone(false); this.insert(Bf._createAfter(e), n); const i = new zf(t, Bf._createAt(e, "end")); const o = new Bf(n, 0); this.move(i, o) } return Bf._createAfter(e) } mergeAttributes(t) { const e = t.offset; const n = t.parent; if (n.is("$text")) { return t } if (n.is("attributeElement") && n.childCount === 0) { const t = n.parent; const e = n.index; n._remove(); this._removeFromClonedElementsGroup(n); return this.mergeAttributes(new Bf(t, e)) } const i = n.getChild(e - 1); const o = n.getChild(e); if (!i || !o) { return t } if (i.is("$text") && o.is("$text")) { return fg(i, o) } else if (i.is("attributeElement") && o.is("attributeElement") && i.isSimilar(o)) { const t = i.childCount; i._appendChild(o.getChildren()); o._remove(); this._removeFromClonedElementsGroup(o); return this.mergeAttributes(new Bf(i, t)) } return t } mergeContainers(t) { const e = t.nodeBefore; const n = t.nodeAfter; if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) { throw new z("view-writer-merge-containers-invalid-position", this.document) } const i = e.getChild(e.childCount - 1); const o = i instanceof Cu ? Bf._createAt(i, "end") : Bf._createAt(e, "end"); this.move(zf._createIn(n), Bf._createAt(e, "end")); this.remove(zf._createOn(n)); return o } insert(t, e) { e = Dt(e) ? [...e] : [e]; mg(e, this.document); const n = e.reduce(((t, e) => { const n = t[t.length - 1]; const i = !e.is("uiElement"); if (!n || n.breakAttributes != i) { t.push({ breakAttributes: i, nodes: [e] }) } else { n.nodes.push(e) } return t }), []); let i = null; let o = t; for (const { nodes: t, breakAttributes: e } of n) { const n = this._insertNodes(o, t, e); if (!i) { i = n.start } o = n.end } if (!i) { return new zf(t) } return new zf(i, o) } remove(t) { const e = t instanceof zf ? t : zf._createOn(t); kg(e, this.document); if (e.isCollapsed) { return new rg(this.document) } const { start: n, end: i } = this._breakAttributesRange(e, true); const o = n.parent; const r = i.offset - n.offset; const s = o._removeChildren(n.offset, r); for (const t of s) { this._removeFromClonedElementsGroup(t) } const a = this.mergeAttributes(n); e.start = a; e.end = a.clone(); return new rg(this.document, s) } clear(t, e) { kg(t, this.document); const n = t.getWalker({ direction: "backward", ignoreElementEnd: true }); for (const i of n) { const n = i.item; let o; if (n.is("element") && e.isSimilar(n)) { o = zf._createOn(n) } else if (!i.nextPosition.isAfter(t.start) && n.is("$textProxy")) { const t = n.getAncestors().find((t => t.is("element") && e.isSimilar(t))); if (t) { o = zf._createIn(t) } } if (o) { if (o.end.isAfter(t.end)) { o.end = t.end } if (o.start.isBefore(t.start)) { o.start = t.start } this.remove(o) } } } move(t, e) { let n; if (e.isAfter(t.end)) { e = this._breakAttributes(e, true); const i = e.parent; const o = i.childCount; t = this._breakAttributesRange(t, true); n = this.remove(t); e.offset += i.childCount - o } else { n = this.remove(t) } return this.insert(e, n) } wrap(t, e) { if (!(e instanceof $f)) { throw new z("view-writer-wrap-invalid-attribute", this.document) } kg(t, this.document); if (!t.isCollapsed) { return this._wrapRange(t, e) } else { let n = t.start; if (n.parent.is("element") && !cg(n.parent)) { n = n.getLastMatchingPosition((t => t.item.is("uiElement"))) } n = this._wrapPosition(n, e); const i = this.document.selection; if (i.isCollapsed && i.getFirstPosition().isEqual(t.start)) { this.setSelection(n) } return new zf(n) } } unwrap(t, e) { if (!(e instanceof $f)) { throw new z("view-writer-unwrap-invalid-attribute", this.document) } kg(t, this.document); if (t.isCollapsed) { return t } const { start: n, end: i } = this._breakAttributesRange(t, true); const o = n.parent; const r = this._unwrapChildren(o, n.offset, i.offset, e); const s = this.mergeAttributes(r.start); if (!s.isEqual(r.start)) { r.end.offset-- } const a = this.mergeAttributes(r.end); return new zf(s, a) } rename(t, e) { const n = new Df(this.document, t, e.getAttributes()); this.insert(Bf._createAfter(e), n); this.move(zf._createIn(e), Bf._createAt(n, 0)); this.remove(zf._createOn(e)); return n } clearClonedElementsGroup(t) { this._cloneGroups.delete(t) } createPositionAt(t, e) { return Bf._createAt(t, e) } createPositionAfter(t) { return Bf._createAfter(t) } createPositionBefore(t) { return Bf._createBefore(t) } createRange(t, e) { return new zf(t, e) } createRangeOn(t) { return zf._createOn(t) } createRangeIn(t) { return zf._createIn(t) } createSelection(...t) { return new Lf(...t) } createSlot(t = "children") { if (!this._slotFactory) { throw new z("view-writer-invalid-create-slot-context", this.document) } return this._slotFactory(this, t) } _registerSlotFactory(t) { this._slotFactory = t } _clearSlotFactory() { this._slotFactory = null } _insertNodes(t, e, n) { let i; if (n) { i = lg(t) } else { i = t.parent.is("$text") ? t.parent.parent : t.parent } if (!i) { throw new z("view-writer-invalid-position-container", this.document) } let o; if (n) { o = this._breakAttributes(t, true) } else { o = t.parent.is("$text") ? hg(t) : t } const r = i._insertChild(o.offset, e); for (const t of e) { this._addToClonedElementsGroup(t) } const s = o.getShiftedBy(r); const a = this.mergeAttributes(o); if (!a.isEqual(o)) { s.offset-- } const c = this.mergeAttributes(s); return new zf(a, c) } _wrapChildren(t, e, n, i) { let o = e; const r = []; while (o < n) { const e = t.getChild(o); const n = e.is("$text"); const s = e.is("attributeElement"); if (s && this._wrapAttributeElement(i, e)) { r.push(new Bf(t, o)) } else if (n || !s || dg(i, e)) { const n = i._clone(); e._remove(); n._appendChild(e); t._insertChild(o, n); this._addToClonedElementsGroup(n); r.push(new Bf(t, o)) } else { this._wrapChildren(e, 0, e.childCount, i) } o++ } let s = 0; for (const t of r) { t.offset -= s; if (t.offset == e) { continue } const i = this.mergeAttributes(t); if (!i.isEqual(t)) { s++; n-- } } return zf._createFromParentsAndOffsets(t, e, t, n) } _unwrapChildren(t, e, n, i) { let o = e; const r = []; while (o < n) { const e = t.getChild(o); if (!e.is("attributeElement")) { o++; continue } if (e.isSimilar(i)) { const i = e.getChildren(); const s = e.childCount; e._remove(); t._insertChild(o, i); this._removeFromClonedElementsGroup(e); r.push(new Bf(t, o), new Bf(t, o + s)); o += s; n += s - 1; continue } if (this._unwrapAttributeElement(i, e)) { r.push(new Bf(t, o), new Bf(t, o + 1)); o++; continue } this._unwrapChildren(e, 0, e.childCount, i); o++ } let s = 0; for (const t of r) { t.offset -= s; if (t.offset == e || t.offset == n) { continue } const i = this.mergeAttributes(t); if (!i.isEqual(t)) { s++; n-- } } return zf._createFromParentsAndOffsets(t, e, t, n) } _wrapRange(t, e) { const { start: n, end: i } = this._breakAttributesRange(t, true); const o = n.parent; const r = this._wrapChildren(o, n.offset, i.offset, e); const s = this.mergeAttributes(r.start); if (!s.isEqual(r.start)) { r.end.offset-- } const a = this.mergeAttributes(r.end); return new zf(s, a) } _wrapPosition(t, e) { if (e.isSimilar(t.parent)) { return ug(t.clone()) } if (t.parent.is("$text")) { t = hg(t) } const n = this.createAttributeElement("_wrapPosition-fake-element"); n._priority = Number.POSITIVE_INFINITY; n.isSimilar = () => false; t.parent._insertChild(t.offset, n); const i = new zf(t, t.getShiftedBy(1)); this.wrap(i, e); const o = new Bf(n.parent, n.index); n._remove(); const r = o.nodeBefore; const s = o.nodeAfter; if (r instanceof Cu && s instanceof Cu) { return fg(r, s) } return ug(o) } _wrapAttributeElement(t, e) { if (!bg(t, e)) { return false } if (t.name !== e.name || t.priority !== e.priority) { return false } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) { return false } } for (const n of t.getStyleNames()) { if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) { return false } } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } if (!e.hasAttribute(n)) { this.setAttribute(n, t.getAttribute(n), e) } } for (const n of t.getStyleNames()) { if (!e.hasStyle(n)) { this.setStyle(n, t.getStyle(n), e) } } for (const n of t.getClassNames()) { if (!e.hasClass(n)) { this.addClass(n, e) } } return true } _unwrapAttributeElement(t, e) { if (!bg(t, e)) { return false } if (t.name !== e.name || t.priority !== e.priority) { return false } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) { return false } } if (!e.hasClass(...t.getClassNames())) { return false } for (const n of t.getStyleNames()) { if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) { return false } } for (const n of t.getAttributeKeys()) { if (n === "class" || n === "style") { continue } this.removeAttribute(n, e) } this.removeClass(Array.from(t.getClassNames()), e); this.removeStyle(Array.from(t.getStyleNames()), e); return true } _breakAttributesRange(t, e = false) { const n = t.start; const i = t.end; kg(t, this.document); if (t.isCollapsed) { const n = this._breakAttributes(t.start, e); return new zf(n, n) } const o = this._breakAttributes(i, e); const r = o.parent.childCount; const s = this._breakAttributes(n, e); o.offset += o.parent.childCount - r; return new zf(s, o) } _breakAttributes(t, e = false) { const n = t.offset; const i = t.parent; if (t.parent.is("emptyElement")) { throw new z("view-writer-cannot-break-empty-element", this.document) } if (t.parent.is("uiElement")) { throw new z("view-writer-cannot-break-ui-element", this.document) } if (t.parent.is("rawElement")) { throw new z("view-writer-cannot-break-raw-element", this.document) } if (!e && i.is("$text") && pg(i.parent)) { return t.clone() } if (pg(i)) { return t.clone() } if (i.is("$text")) { return this._breakAttributes(hg(t), e) } const o = i.childCount; if (n == o) { const t = new Bf(i.parent, i.index + 1); return this._breakAttributes(t, e) } else { if (n === 0) { const t = new Bf(i.parent, i.index); return this._breakAttributes(t, e) } else { const t = i.index + 1; const o = i._clone(); i.parent._insertChild(t, o); this._addToClonedElementsGroup(o); const r = i.childCount - n; const s = i._removeChildren(n, r); o._appendChild(s); const a = new Bf(i.parent, t); return this._breakAttributes(a, e) } } } _addToClonedElementsGroup(t) { if (!t.root.is("rootElement")) { return } if (t.is("element")) { for (const e of t.getChildren()) { this._addToClonedElementsGroup(e) } } const e = t.id; if (!e) { return } let n = this._cloneGroups.get(e); if (!n) { n = new Set; this._cloneGroups.set(e, n) } n.add(t); t._clonesGroup = n } _removeFromClonedElementsGroup(t) { if (t.is("element")) { for (const e of t.getChildren()) { this._removeFromClonedElementsGroup(e) } } const e = t.id; if (!e) { return } const n = this._cloneGroups.get(e); if (!n) { return } n.delete(t) } } function cg(t) { return Array.from(t.getChildren()).some((t => !t.is("uiElement"))) } function lg(t) { let e = t.parent; while (!pg(e)) { if (!e) { return undefined } e = e.parent } return e } function dg(t, e) { if (t.priority < e.priority) { return true } else if (t.priority > e.priority) { return false } return t.getIdentity() < e.getIdentity() } function ug(t) { const e = t.nodeBefore; if (e && e.is("$text")) { return new Bf(e, e.data.length) } const n = t.nodeAfter; if (n && n.is("$text")) { return new Bf(n, 0) } return t } function hg(t) { if (t.offset == t.parent.data.length) { return new Bf(t.parent.parent, t.parent.index + 1) } if (t.offset === 0) { return new Bf(t.parent.parent, t.parent.index) } const e = t.parent.data.slice(t.offset); t.parent._data = t.parent.data.slice(0, t.offset); t.parent.parent._insertChild(t.parent.index + 1, new Cu(t.root.document, e)); return new Bf(t.parent.parent, t.parent.index + 1) } function fg(t, e) { const n = t.data.length; t._data += e.data; e._remove(); return new Bf(t, n) } const gg = [Cu, $f, Df, Zf, ig, Xf]; function mg(t, e) { for (const n of t) { if (!gg.some((t => n instanceof t))) { throw new z("view-writer-insert-invalid-node-type", e) } if (!n.is("$text")) { mg(n.getChildren(), e) } } } function pg(t) { return t && (t.is("containerElement") || t.is("documentFragment")) } function kg(t, e) { const n = lg(t.start); const i = lg(t.end); if (!n || !i || n !== i) { throw new z("view-writer-invalid-range-container", e) } } function bg(t, e) { return t.id === null && e.id === null } const wg = t => t.createTextNode(" "); const _g = t => { const e = t.createElement("span"); e.dataset.ckeFiller = "true"; e.innerText = " "; return e }; const Ag = t => { const e = t.createElement("br"); e.dataset.ckeFiller = "true"; return e }; const Cg = 7; const vg = "⁠".repeat(Cg); function yg(t) { return rc(t) && t.data.substr(0, Cg) === vg } function xg(t) { return t.data.length == Cg && yg(t) } function Eg(t) { if (yg(t)) { return t.data.slice(Cg) } else { return t.data } } function Dg(t) { t.document.on("arrowKey", Ig, { priority: "low" }) } function Ig(t, e) { if (e.keyCode == Fc.arrowleft) { const t = e.domTarget.ownerDocument.defaultView.getSelection(); if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) { const e = t.getRangeAt(0).startContainer; const n = t.getRangeAt(0).startOffset; if (yg(e) && n <= Cg) { t.collapse(e, 0) } } } } var Tg = n(4401); var Mg = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Mg.insert = "head"; Mg.singleton = true; var Sg = Dl()(Tg.Z, Mg); const Ng = Tg.Z.locals || {}; class Bg extends (ft()) { constructor(t, e) { super(); this.domDocuments = new Set; this.markedAttributes = new Set; this.markedChildren = new Set; this.markedTexts = new Set; this._inlineFiller = null; this._fakeSelectionContainer = null; this.domConverter = t; this.selection = e; this.set("isFocused", false); this.set("isSelecting", false); if (l.isBlink && !l.isAndroid) { this.on("change:isSelecting", (() => { if (!this.isSelecting) { this.render() } })) } this.set("isComposing", false); this.on("change:isComposing", (() => { if (!this.isComposing) { this.render() } })) } markToSync(t, e) { if (t === "text") { if (this.domConverter.mapViewToDom(e.parent)) { this.markedTexts.add(e) } } else { if (!this.domConverter.mapViewToDom(e)) { return } if (t === "attributes") { this.markedAttributes.add(e) } else if (t === "children") { this.markedChildren.add(e) } else { const e = t; throw new z("view-renderer-unknown-type", this) } } } render() { if (this.isComposing && !l.isAndroid) { return } let t = null; const e = l.isBlink && !l.isAndroid ? !this.isSelecting : true; for (const t of this.markedChildren) { this._updateChildrenMappings(t) } if (e) { if (this._inlineFiller && !this._isSelectionInInlineFiller()) { this._removeInlineFiller() } if (this._inlineFiller) { t = this._getInlineFillerPosition() } else if (this._needsInlineFillerAtSelection()) { t = this.selection.getFirstPosition(); this.markedChildren.add(t.parent) } } else if (this._inlineFiller && this._inlineFiller.parentNode) { t = this.domConverter.domPositionToView(this._inlineFiller); if (t && t.parent.is("$text")) { t = Bf._createBefore(t.parent) } } for (const t of this.markedAttributes) { this._updateAttrs(t) } for (const e of this.markedChildren) { this._updateChildren(e, { inlineFillerPosition: t }) } for (const e of this.markedTexts) { if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) { this._updateText(e, { inlineFillerPosition: t }) } } if (e) { if (t) { const e = this.domConverter.viewPositionToDom(t); const n = e.parent.ownerDocument; if (!yg(e.parent)) { this._inlineFiller = Pg(n, e.parent, e.offset) } else { this._inlineFiller = e.parent } } else { this._inlineFiller = null } } this._updateFocus(); this._updateSelection(); this.markedTexts.clear(); this.markedAttributes.clear(); this.markedChildren.clear() } _updateChildrenMappings(t) { const e = this.domConverter.mapViewToDom(t); if (!e) { return } const n = Array.from(this.domConverter.mapViewToDom(t).childNodes); const i = Array.from(this.domConverter.viewChildrenToDom(t, { withChildren: false })); const o = this._diffNodeLists(n, i); const r = this._findUpdateActions(o, n, i, Lg); if (r.indexOf("update") !== -1) { const e = { equal: 0, insert: 0, delete: 0 }; for (const o of r) { if (o === "update") { const o = e.equal + e.insert; const r = e.equal + e.delete; const s = t.getChild(o); if (s && !(s.is("uiElement") || s.is("rawElement"))) { this._updateElementMappings(s, n[r]) } Dc(i[o]); e.equal++ } else { e[o]++ } } } } _updateElementMappings(t, e) { this.domConverter.unbindDomElement(e); this.domConverter.bindElements(e, t); this.markedChildren.add(t); this.markedAttributes.add(t) } _getInlineFillerPosition() { const t = this.selection.getFirstPosition(); if (t.parent.is("$text")) { return Bf._createBefore(t.parent) } else { return t } } _isSelectionInInlineFiller() { if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) { return false } const t = this.selection.getFirstPosition(); const e = this.domConverter.viewPositionToDom(t); if (e && rc(e.parent) && yg(e.parent)) { return true } return false } _removeInlineFiller() { const t = this._inlineFiller; if (!yg(t)) { throw new z("view-renderer-filler-was-lost", this) } if (xg(t)) { t.remove() } else { t.data = t.data.substr(Cg) } this._inlineFiller = null } _needsInlineFillerAtSelection() { if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) { return false } const t = this.selection.getFirstPosition(); const e = t.parent; const n = t.offset; if (!this.domConverter.mapViewToDom(e.root)) { return false } if (!e.is("element")) { return false } if (!zg(e)) { return false } if (n === e.getFillerOffset()) { return false } const i = t.nodeBefore; const o = t.nodeAfter; if (i instanceof Cu || o instanceof Cu) { return false } if (l.isAndroid && (i || o)) { return false } return true } _updateText(t, e) { const n = this.domConverter.findCorrespondingDomText(t); const i = this.domConverter.viewToDom(t); let o = i.data; const r = e.inlineFillerPosition; if (r && r.parent == t.parent && r.offset == t.index) { o = vg + o } Hg(n, o) } _updateAttrs(t) { const e = this.domConverter.mapViewToDom(t); if (!e) { return } const n = Array.from(e.attributes).map((t => t.name)); const i = t.getAttributeKeys(); for (const n of i) { this.domConverter.setDomElementAttribute(e, n, t.getAttribute(n), t) } for (const i of n) { if (!t.hasAttribute(i)) { this.domConverter.removeDomElementAttribute(e, i) } } } _updateChildren(t, e) { const n = this.domConverter.mapViewToDom(t); if (!n) { return } if (l.isAndroid) { let t = null; for (const e of Array.from(n.childNodes)) { if (t && rc(t) && rc(e)) { n.normalize(); break } t = e } } const i = e.inlineFillerPosition; const o = n.childNodes; const r = Array.from(this.domConverter.viewChildrenToDom(t, { bind: true })); if (i && i.parent === t) { Pg(n.ownerDocument, r, i.offset) } const s = this._diffNodeLists(o, r); const a = this._findUpdateActions(s, o, r, Og); let c = 0; const d = new Set; for (const t of a) { if (t === "delete") { d.add(o[c]); Dc(o[c]) } else if (t === "equal" || t === "update") { c++ } } c = 0; for (const t of a) { if (t === "insert") { kc(n, c, r[c]); c++ } else if (t === "update") { Hg(o[c], r[c].data); c++ } else if (t === "equal") { this._markDescendantTextToSync(this.domConverter.domToView(r[c])); c++ } } for (const t of d) { if (!t.parentNode) { this.domConverter.unbindDomElement(t) } } } _diffNodeLists(t, e) { t = Vg(t, this._fakeSelectionContainer); return y(t, e, Rg.bind(null, this.domConverter)) } _findUpdateActions(t, e, n, i) { if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) { return t } let o = []; let r = []; let s = []; const a = { equal: 0, insert: 0, delete: 0 }; for (const c of t) { if (c === "insert") { s.push(n[a.equal + a.insert]) } else if (c === "delete") { r.push(e[a.equal + a.delete]) } else { o = o.concat(y(r, s, i).map((t => t === "equal" ? "update" : t))); o.push("equal"); r = []; s = [] } a[c]++ } return o.concat(y(r, s, i).map((t => t === "equal" ? "update" : t))) } _markDescendantTextToSync(t) { if (!t) { return } if (t.is("$text")) { this.markedTexts.add(t) } else if (t.is("element")) { for (const e of t.getChildren()) { this._markDescendantTextToSync(e) } } } _updateSelection() { if (l.isBlink && !l.isAndroid && this.isSelecting && !this.markedChildren.size) { return } if (this.selection.rangeCount === 0) { this._removeDomSelection(); this._removeFakeSelection(); return } const t = this.domConverter.mapViewToDom(this.selection.editableElement); if (!this.isFocused || !t) { return } if (this.selection.isFake) { this._updateFakeSelection(t) } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) { this._removeFakeSelection(); this._updateDomSelection(t) } else if (!(this.isComposing && l.isAndroid)) { this._updateDomSelection(t) } } _updateFakeSelection(t) { const e = t.ownerDocument; if (!this._fakeSelectionContainer) { this._fakeSelectionContainer = Fg(e) } const n = this._fakeSelectionContainer; this.domConverter.bindFakeSelection(n, this.selection); if (!this._fakeSelectionNeedsUpdate(t)) { return } if (!n.parentElement || n.parentElement != t) { t.appendChild(n) } n.textContent = this.selection.fakeSelectionLabel || " "; const i = e.getSelection(); const o = e.createRange(); i.removeAllRanges(); o.selectNodeContents(n); i.addRange(o) } _updateDomSelection(t) { const e = t.ownerDocument.defaultView.getSelection(); if (!this._domSelectionNeedsUpdate(e)) { return } const n = this.domConverter.viewPositionToDom(this.selection.anchor); const i = this.domConverter.viewPositionToDom(this.selection.focus); e.collapse(n.parent, n.offset); e.extend(i.parent, i.offset); if (l.isGecko) { jg(i, e) } } _domSelectionNeedsUpdate(t) { if (!this.domConverter.isDomSelectionCorrect(t)) { return true } const e = t && this.domConverter.domSelectionToView(t); if (e && this.selection.isEqual(e)) { return false } if (!this.selection.isCollapsed && this.selection.isSimilar(e)) { return false } return true } _fakeSelectionNeedsUpdate(t) { const e = this._fakeSelectionContainer; const n = t.ownerDocument.getSelection(); if (!e || e.parentElement !== t) { return true } if (n.anchorNode !== e && !e.contains(n.anchorNode)) { return true } return e.textContent !== this.selection.fakeSelectionLabel } _removeDomSelection() { for (const t of this.domDocuments) { const e = t.getSelection(); if (e.rangeCount) { const n = t.activeElement; const i = this.domConverter.mapDomToView(n); if (n && i) { e.removeAllRanges() } } } } _removeFakeSelection() { const t = this._fakeSelectionContainer; if (t) { t.remove() } } _updateFocus() { if (this.isFocused) { const t = this.selection.editableElement; if (t) { this.domConverter.focus(t) } } } } function zg(t) { if (t.getAttribute("contenteditable") == "false") { return false } const e = t.findAncestor((t => t.hasAttribute("contenteditable"))); return !e || e.getAttribute("contenteditable") == "true" } function Pg(t, e, n) { const i = e instanceof Array ? e : e.childNodes; const o = i[n]; if (rc(o)) { o.data = vg + o.data; return o } else { const o = t.createTextNode(vg); if (Array.isArray(e)) { i.splice(n, 0, o) } else { kc(e, n, o) } return o } } function Lg(t, e) { return $a(t) && $a(e) && !rc(t) && !rc(e) && !bc(t) && !bc(e) && t.tagName.toLowerCase() === e.tagName.toLowerCase() } function Og(t, e) { return $a(t) && $a(e) && rc(t) && rc(e) } function Rg(t, e, n) { if (e === n) { return true } else if (rc(e) && rc(n)) { return e.data === n.data } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) { return true } return false } function jg(t, e) { const n = t.parent; if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) { return } const i = n.childNodes[t.offset]; if (i && i.tagName == "BR") { e.addRange(e.getRangeAt(0)) } } function Vg(t, e) { const n = Array.from(t); if (n.length == 0 || !e) { return n } const i = n[n.length - 1]; if (i == e) { n.pop() } return n } function Fg(t) { const e = t.createElement("div"); e.className = "ck-fake-selection-container"; Object.assign(e.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }); e.textContent = " "; return e } function Hg(t, e) { const n = t.data; if (n == e) { return } const i = b(n, e); for (const e of i) { if (e.type === "insert") { t.insertData(e.index, e.values.join("")) } else { t.deleteData(e.index, e.howMany) } } } const Ug = Ag(nc.document); const Wg = wg(nc.document); const Gg = _g(nc.document); const qg = "data-ck-unsafe-attribute-"; const Yg = "data-ck-unsafe-element"; class $g { constructor(t, { blockFillerMode: e, renderingMode: n = "editing" } = {}) { this._domToViewMapping = new WeakMap; this._viewToDomMapping = new WeakMap; this._fakeSelectionMapping = new WeakMap; this._rawContentElementMatcher = new yu; this._encounteredRawContentDomNodes = new WeakSet; this.document = t; this.renderingMode = n; this.blockFillerMode = e || (n === "editing" ? "br" : "nbsp"); this.preElements = ["pre"]; this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"]; this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"]; this.unsafeElements = ["script", "style"]; this._domDocument = this.renderingMode === "editing" ? nc.document : nc.document.implementation.createHTMLDocument("") } bindFakeSelection(t, e) { this._fakeSelectionMapping.set(t, new Lf(e)) } fakeSelectionToView(t) { return this._fakeSelectionMapping.get(t) } bindElements(t, e) { this._domToViewMapping.set(t, e); this._viewToDomMapping.set(e, t) } unbindDomElement(t) { const e = this._domToViewMapping.get(t); if (e) { this._domToViewMapping.delete(t); this._viewToDomMapping.delete(e); for (const e of Array.from(t.children)) { this.unbindDomElement(e) } } } bindDocumentFragments(t, e) { this._domToViewMapping.set(t, e); this._viewToDomMapping.set(e, t) } shouldRenderAttribute(t, e, n) { if (this.renderingMode === "data") { return true } t = t.toLowerCase(); if (t.startsWith("on")) { return false } if (t === "srcdoc" && e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) { return false } if (n === "img" && (t === "src" || t === "srcset")) { return true } if (n === "source" && t === "srcset") { return true } if (e.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) { return false } return true } setContentOf(t, e) { if (this.renderingMode === "data") { t.innerHTML = e; return } const n = (new DOMParser).parseFromString(e, "text/html"); const i = n.createDocumentFragment(); const o = n.body.childNodes; while (o.length > 0) { i.appendChild(o[0]) } const r = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT); const s = []; let a; while (a = r.nextNode()) { s.push(a) } for (const t of s) { for (const e of t.getAttributeNames()) { this.setDomElementAttribute(t, e, t.getAttribute(e)) } const e = t.tagName.toLowerCase(); if (this._shouldRenameElement(e)) { Xg(e); t.replaceWith(this._createReplacementDomElement(e, t)) } } while (t.firstChild) { t.firstChild.remove() } t.append(i) } viewToDom(t, e = {}) { if (t.is("$text")) { const e = this._processDataFromViewText(t); return this._domDocument.createTextNode(e) } else { if (this.mapViewToDom(t)) { return this.mapViewToDom(t) } let n; if (t.is("documentFragment")) { n = this._domDocument.createDocumentFragment(); if (e.bind) { this.bindDocumentFragments(n, t) } } else if (t.is("uiElement")) { if (t.name === "$comment") { n = this._domDocument.createComment(t.getCustomProperty("$rawContent")) } else { n = t.render(this._domDocument, this) } if (e.bind) { this.bindElements(n, t) } return n } else { if (this._shouldRenameElement(t.name)) { Xg(t.name); n = this._createReplacementDomElement(t.name) } else if (t.hasAttribute("xmlns")) { n = this._domDocument.createElementNS(t.getAttribute("xmlns"), t.name) } else { n = this._domDocument.createElement(t.name) } if (t.is("rawElement")) { t.render(n, this) } if (e.bind) { this.bindElements(n, t) } for (const e of t.getAttributeKeys()) { this.setDomElementAttribute(n, e, t.getAttribute(e), t) } } if (e.withChildren !== false) { for (const i of this.viewChildrenToDom(t, e)) { n.appendChild(i) } } return n } } setDomElementAttribute(t, e, n, i) { const o = this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) || i && i.shouldRenderUnsafeAttribute(e); if (!o) { P("domconverter-unsafe-attribute-detected", { domElement: t, key: e, value: n }) } if (t.hasAttribute(e) && !o) { t.removeAttribute(e) } else if (t.hasAttribute(qg + e) && o) { t.removeAttribute(qg + e) } t.setAttribute(o ? e : qg + e, n) } removeDomElementAttribute(t, e) { if (e == Yg) { return } t.removeAttribute(e); t.removeAttribute(qg + e) } *viewChildrenToDom(t, e = {}) { const n = t.getFillerOffset && t.getFillerOffset(); let i = 0; for (const o of t.getChildren()) { if (n === i) { yield this._getBlockFiller() } const t = o.is("element") && !!o.getCustomProperty("dataPipeline:transparentRendering") && !ll(o.getAttributes()); if (t && this.renderingMode == "data") { yield* this.viewChildrenToDom(o, e) } else { if (t) { P("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: o }) } yield this.viewToDom(o, e) } i++ } if (n === i) { yield this._getBlockFiller() } } viewRangeToDom(t) { const e = this.viewPositionToDom(t.start); const n = this.viewPositionToDom(t.end); const i = this._domDocument.createRange(); i.setStart(e.parent, e.offset); i.setEnd(n.parent, n.offset); return i } viewPositionToDom(t) { const e = t.parent; if (e.is("$text")) { const n = this.findCorrespondingDomText(e); if (!n) { return null } let i = t.offset; if (yg(n)) { i += Cg } return { parent: n, offset: i } } else { let n, i, o; if (t.offset === 0) { n = this.mapViewToDom(e); if (!n) { return null } o = n.childNodes[0] } else { const e = t.nodeBefore; i = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(e); if (!i) { return null } n = i.parentNode; o = i.nextSibling } if (rc(o) && yg(o)) { return { parent: o, offset: Cg } } const r = i ? pc(i) + 1 : 0; return { parent: n, offset: r } } } domToView(t, e = {}) { if (this.isBlockFiller(t)) { return null } const n = this.getHostViewElement(t); if (n) { return n } if (bc(t) && e.skipComments) { return null } if (rc(t)) { if (xg(t)) { return null } else { const e = this._processDataFromDomText(t); return e === "" ? null : new Cu(this.document, e) } } else { if (this.mapDomToView(t)) { return this.mapDomToView(t) } let n; if (this.isDocumentFragment(t)) { n = new rg(this.document); if (e.bind) { this.bindDocumentFragments(t, n) } } else { n = this._createViewElement(t, e); if (e.bind) { this.bindElements(t, n) } const i = t.attributes; if (i) { for (let t = i.length, e = 0; e < t; e++) { n._setAttribute(i[e].name, i[e].value) } } if (this._isViewElementWithRawContent(n, e) || bc(t)) { const e = bc(t) ? t.data : t.innerHTML; n._setCustomProperty("$rawContent", e); this._encounteredRawContentDomNodes.add(t); return n } } if (e.withChildren !== false) { for (const i of this.domChildrenToView(t, e)) { n._appendChild(i) } } return n } } *domChildrenToView(t, e) { for (let n = 0; n < t.childNodes.length; n++) { const i = t.childNodes[n]; const o = this.domToView(i, e); if (o !== null) { yield o } } } domSelectionToView(t) { if (t.rangeCount === 1) { let e = t.getRangeAt(0).startContainer; if (rc(e)) { e = e.parentNode } const n = this.fakeSelectionToView(e); if (n) { return n } } const e = this.isDomSelectionBackward(t); const n = []; for (let e = 0; e < t.rangeCount; e++) { const i = t.getRangeAt(e); const o = this.domRangeToView(i); if (o) { n.push(o) } } return new Lf(n, { backward: e }) } domRangeToView(t) { const e = this.domPositionToView(t.startContainer, t.startOffset); const n = this.domPositionToView(t.endContainer, t.endOffset); if (e && n) { return new zf(e, n) } return null } domPositionToView(t, e = 0) { if (this.isBlockFiller(t)) { return this.domPositionToView(t.parentNode, pc(t)) } const n = this.mapDomToView(t); if (n && (n.is("uiElement") || n.is("rawElement"))) { return Bf._createBefore(n) } if (rc(t)) { if (xg(t)) { return this.domPositionToView(t.parentNode, pc(t)) } const n = this.findCorrespondingViewText(t); let i = e; if (!n) { return null } if (yg(t)) { i -= Cg; i = i < 0 ? 0 : i } return new Bf(n, i) } else { if (e === 0) { const e = this.mapDomToView(t); if (e) { return new Bf(e, 0) } } else { const n = t.childNodes[e - 1]; if (rc(n) && xg(n) || n && this.isBlockFiller(n)) { return this.domPositionToView(n.parentNode, pc(n)) } const i = rc(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n); if (i && i.parent) { return new Bf(i.parent, i.index + 1) } } return null } } mapDomToView(t) { const e = this.getHostViewElement(t); return e || this._domToViewMapping.get(t) } findCorrespondingViewText(t) { if (xg(t)) { return null } const e = this.getHostViewElement(t); if (e) { return e } const n = t.previousSibling; if (n) { if (!this.isElement(n)) { return null } const t = this.mapDomToView(n); if (t) { const e = t.nextSibling; if (e instanceof Cu) { return e } else { return null } } } else { const e = this.mapDomToView(t.parentNode); if (e) { const t = e.getChild(0); if (t instanceof Cu) { return t } else { return null } } } return null } mapViewToDom(t) { return this._viewToDomMapping.get(t) } findCorrespondingDomText(t) { const e = t.previousSibling; if (e && this.mapViewToDom(e)) { return this.mapViewToDom(e).nextSibling } if (!e && t.parent && this.mapViewToDom(t.parent)) { return this.mapViewToDom(t.parent).childNodes[0] } return null } focus(t) { const e = this.mapViewToDom(t); if (e && e.ownerDocument.activeElement !== e) { const { scrollX: t, scrollY: n } = nc.window; const i = []; Kg(e, (t => { const { scrollLeft: e, scrollTop: n } = t; i.push([e, n]) })); e.focus(); Kg(e, (t => { const [e, n] = i.shift(); t.scrollLeft = e; t.scrollTop = n })); nc.window.scrollTo(t, n) } } isElement(t) { return t && t.nodeType == Node.ELEMENT_NODE } isDocumentFragment(t) { return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE } isBlockFiller(t) { if (this.blockFillerMode == "br") { return t.isEqualNode(Ug) } if (t.tagName === "BR" && Jg(t, this.blockElements) && t.parentNode.childNodes.length === 1) { return true } return t.isEqualNode(Gg) || Zg(t, this.blockElements) } isDomSelectionBackward(t) { if (t.isCollapsed) { return false } const e = this._domDocument.createRange(); try { e.setStart(t.anchorNode, t.anchorOffset); e.setEnd(t.focusNode, t.focusOffset) } catch (t) { return false } const n = e.collapsed; e.detach(); return n } getHostViewElement(t) { const e = ic(t); e.pop(); while (e.length) { const t = e.pop(); const n = this._domToViewMapping.get(t); if (n && (n.is("uiElement") || n.is("rawElement"))) { return n } } return null } isDomSelectionCorrect(t) { return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset) } registerRawContentMatcher(t) { this._rawContentElementMatcher.add(t) } _getBlockFiller() { switch (this.blockFillerMode) { case "nbsp": return wg(this._domDocument); case "markedNbsp": return _g(this._domDocument); case "br": return Ag(this._domDocument) } } _isDomSelectionPositionCorrect(t, e) { if (rc(t) && yg(t) && e < Cg) { return false } if (this.isElement(t) && yg(t.childNodes[e])) { return false } const n = this.mapDomToView(t); if (n && (n.is("uiElement") || n.is("rawElement"))) { return false } return true } _processDataFromViewText(t) { let e = t.data; if (t.getAncestors().some((t => this.preElements.includes(t.name)))) { return e } if (e.charAt(0) == " ") { const n = this._getTouchingInlineViewNode(t, false); const i = n && n.is("$textProxy") && this._nodeEndsWithSpace(n); if (i || !n) { e = " " + e.substr(1) } } if (e.charAt(e.length - 1) == " ") { const n = this._getTouchingInlineViewNode(t, true); const i = n && n.is("$textProxy") && n.data.charAt(0) == " "; if (e.charAt(e.length - 2) == " " || !n || i) { e = e.substr(0, e.length - 1) + " " } } return e.replace(/ {2}/g, "  ") } _nodeEndsWithSpace(t) { if (t.getAncestors().some((t => this.preElements.includes(t.name)))) { return false } const e = this._processDataFromViewText(t); return e.charAt(e.length - 1) == " " } _processDataFromDomText(t) { let e = t.data; if (Qg(t, this.preElements)) { return Eg(t) } e = e.replace(/[ \n\t\r]{1,}/g, " "); const n = this._getTouchingInlineDomNode(t, false); const i = this._getTouchingInlineDomNode(t, true); const o = this._checkShouldLeftTrimDomText(t, n); const r = this._checkShouldRightTrimDomText(t, i); if (o) { e = e.replace(/^ /, "") } if (r) { e = e.replace(/ $/, "") } e = Eg(new Text(e)); e = e.replace(/ \u00A0/g, "  "); const s = i && this.isElement(i) && i.tagName != "BR"; const a = i && rc(i) && i.data.charAt(0) == " "; if (/( |\u00A0)\u00A0$/.test(e) || !i || s || a) { e = e.replace(/\u00A0$/, " ") } if (o || n && this.isElement(n) && n.tagName != "BR") { e = e.replace(/^\u00A0/, " ") } return e } _checkShouldLeftTrimDomText(t, e) { if (!e) { return true } if (this.isElement(e)) { return e.tagName === "BR" } if (this._encounteredRawContentDomNodes.has(t.previousSibling)) { return false } return /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)) } _checkShouldRightTrimDomText(t, e) { if (e) { return false } return !yg(t) } _getTouchingInlineViewNode(t, e) { const n = new Nf({ startPosition: e ? Bf._createAfter(t) : Bf._createBefore(t), direction: e ? "forward" : "backward" }); for (const t of n) { if (t.item.is("element") && this.inlineObjectElements.includes(t.item.name)) { return t.item } else if (t.item.is("containerElement")) { return null } else if (t.item.is("element", "br")) { return null } else if (t.item.is("$textProxy")) { return t.item } } return null } _getTouchingInlineDomNode(t, e) { if (!t.parentNode) { return null } const n = e ? "firstChild" : "lastChild"; const i = e ? "nextSibling" : "previousSibling"; let o = true; let r = t; do { if (!o && r[n]) { r = r[n] } else if (r[i]) { r = r[i]; o = false } else { r = r.parentNode; o = true } if (!r || this._isBlockElement(r)) { return null } } while (!(rc(r) || r.tagName == "BR" || this._isInlineObjectElement(r))); return r } _isBlockElement(t) { return this.isElement(t) && this.blockElements.includes(t.tagName.toLowerCase()) } _isInlineObjectElement(t) { return this.isElement(t) && this.inlineObjectElements.includes(t.tagName.toLowerCase()) } _createViewElement(t, e) { if (bc(t)) { return new Xf(this.document, "$comment") } const n = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase(); return new vf(this.document, n) } _isViewElementWithRawContent(t, e) { return e.withChildren !== false && !!this._rawContentElementMatcher.match(t) } _shouldRenameElement(t) { const e = t.toLowerCase(); return this.renderingMode === "editing" && this.unsafeElements.includes(e) } _createReplacementDomElement(t, e) { const n = this._domDocument.createElement("span"); n.setAttribute(Yg, t); if (e) { while (e.firstChild) { n.appendChild(e.firstChild) } for (const t of e.getAttributeNames()) { n.setAttribute(t, e.getAttribute(t)) } } return n } } function Qg(t, e) { const n = ic(t); return n.some((t => t.tagName && e.includes(t.tagName.toLowerCase()))) } function Kg(t, e) { let n = t; while (n) { e(n); n = n.parentElement } } function Zg(t, e) { const n = t.isEqualNode(Wg); return n && Jg(t, e) && t.parentNode.childNodes.length === 1 } function Jg(t, e) { const n = t.parentNode; return !!n && !!n.tagName && e.includes(n.tagName.toLowerCase()) } function Xg(t) { if (t === "script") { P("domconverter-unsafe-script-element-detected") } if (t === "style") { P("domconverter-unsafe-style-element-detected") } } class tm extends (Za()) { constructor(t) { super(); this._isEnabled = false; this.view = t; this.document = t.document } get isEnabled() { return this._isEnabled } enable() { this._isEnabled = true } disable() { this._isEnabled = false } destroy() { this.disable(); this.stopListening() } checkShouldIgnoreEventFromTarget(t) { if (t && t.nodeType === 3) { t = t.parentNode } if (!t || t.nodeType !== 1) { return false } return t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *") } } var em = uf((function (t, e) { ki(e, er(e), t) })); const nm = em; class im { constructor(t, e, n) { this.view = t; this.document = t.document; this.domEvent = e; this.domTarget = e.target; nm(this, n) } get target() { return this.view.domConverter.mapDomToView(this.domTarget) } preventDefault() { this.domEvent.preventDefault() } stopPropagation() { this.domEvent.stopPropagation() } } class om extends tm { constructor() { super(...arguments); this.useCapture = false } observe(t) { const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType; e.forEach((e => { this.listenTo(t, e, ((t, e) => { if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) { this.onDomEvent(e) } }), { useCapture: this.useCapture }) })) } stopObserving(t) { this.stopListening(t) } fire(t, e, n) { if (this.isEnabled) { this.document.fire(t, new im(this.view, e, n)) } } } class rm extends om { constructor() { super(...arguments); this.domEventType = ["keydown", "keyup"] } onDomEvent(t) { const e = { keyCode: t.keyCode, altKey: t.altKey, ctrlKey: t.ctrlKey, shiftKey: t.shiftKey, metaKey: t.metaKey, get keystroke() { return Uc(this) } }; this.fire(t.type, t, e) } } var sm = function () { return Nt.Date.now() }; const am = sm; var cm = /\s/; function lm(t) { var e = t.length; while (e-- && cm.test(t.charAt(e))) { } return e } const dm = lm; var um = /^\s+/; function hm(t) { return t ? t.slice(0, dm(t) + 1).replace(um, "") : t } const fm = hm; var gm = 0 / 0; var mm = /^[-+]0x[0-9a-f]+$/i; var pm = /^0b[01]+$/i; var km = /^0o[0-7]+$/i; var bm = parseInt; function wm(t) { if (typeof t == "number") { return t } if (Lu(t)) { return gm } if (st(t)) { var e = typeof t.valueOf == "function" ? t.valueOf() : t; t = st(e) ? e + "" : e } if (typeof t != "string") { return t === 0 ? t : +t } t = fm(t); var n = pm.test(t); return n || km.test(t) ? bm(t.slice(2), n ? 2 : 8) : mm.test(t) ? gm : +t } const _m = wm; var Am = "Expected a function"; var Cm = Math.max, vm = Math.min; function ym(t, e, n) { var i, o, r, s, a, c, l = 0, d = false, u = false, h = true; if (typeof t != "function") { throw new TypeError(Am) } e = _m(e) || 0; if (st(n)) { d = !!n.leading; u = "maxWait" in n; r = u ? Cm(_m(n.maxWait) || 0, e) : r; h = "trailing" in n ? !!n.trailing : h } function f(e) { var n = i, r = o; i = o = undefined; l = e; s = t.apply(r, n); return s } function g(t) { l = t; a = setTimeout(k, e); return d ? f(t) : s } function m(t) { var n = t - c, i = t - l, o = e - n; return u ? vm(o, r - i) : o } function p(t) { var n = t - c, i = t - l; return c === undefined || n >= e || n < 0 || u && i >= r } function k() { var t = am(); if (p(t)) { return b(t) } a = setTimeout(k, m(t)) } function b(t) { a = undefined; if (h && i) { return f(t) } i = o = undefined; return s } function w() { if (a !== undefined) { clearTimeout(a) } l = 0; i = c = o = a = undefined } function _() { return a === undefined ? s : b(am()) } function A() { var t = am(), n = p(t); i = arguments; o = this; c = t; if (n) { if (a === undefined) { return g(c) } if (u) { clearTimeout(a); a = setTimeout(k, e); return f(c) } } if (a === undefined) { a = setTimeout(k, e) } return s } A.cancel = w; A.flush = _; return A } const xm = ym; class Em extends tm { constructor(t) { super(t); this._fireSelectionChangeDoneDebounced = xm((t => { this.document.fire("selectionChangeDone", t) }), 200) } observe() { const t = this.document; t.on("arrowKey", ((e, n) => { const i = t.selection; if (i.isFake && this.isEnabled) { n.preventDefault() } }), { context: "$capture" }); t.on("arrowKey", ((e, n) => { const i = t.selection; if (i.isFake && this.isEnabled) { this._handleSelectionMove(n.keyCode) } }), { priority: "lowest" }) } stopObserving() { } destroy() { super.destroy(); this._fireSelectionChangeDoneDebounced.cancel() } _handleSelectionMove(t) { const e = this.document.selection; const n = new Lf(e.getRanges(), { backward: e.isBackward, fake: false }); if (t == Fc.arrowleft || t == Fc.arrowup) { n.setTo(n.getFirstPosition()) } if (t == Fc.arrowright || t == Fc.arrowdown) { n.setTo(n.getLastPosition()) } const i = { oldSelection: e, newSelection: n, domSelection: null }; this.document.fire("selectionChange", i); this._fireSelectionChangeDoneDebounced(i) } } var Dm = "__lodash_hash_undefined__"; function Im(t) { this.__data__.set(t, Dm); return this } const Tm = Im; function Mm(t) { return this.__data__.has(t) } const Sm = Mm; function Nm(t) { var e = -1, n = t == null ? 0 : t.length; this.__data__ = new ti; while (++e < n) { this.add(t[e]) } } Nm.prototype.add = Nm.prototype.push = Tm; Nm.prototype.has = Sm; const Bm = Nm; function zm(t, e) { var n = -1, i = t == null ? 0 : t.length; while (++n < i) { if (e(t[n], n, t)) { return true } } return false } const Pm = zm; function Lm(t, e) { return t.has(e) } const Om = Lm; var Rm = 1, jm = 2; function Vm(t, e, n, i, o, r) { var s = n & Rm, a = t.length, c = e.length; if (a != c && !(s && c > a)) { return false } var l = r.get(t); var d = r.get(e); if (l && d) { return l == e && d == t } var u = -1, h = true, f = n & jm ? new Bm : undefined; r.set(t, e); r.set(e, t); while (++u < a) { var g = t[u], m = e[u]; if (i) { var p = s ? i(m, g, u, e, t, r) : i(g, m, u, t, e, r) } if (p !== undefined) { if (p) { continue } h = false; break } if (f) { if (!Pm(e, (function (t, e) { if (!Om(f, e) && (g === t || o(g, t, n, i, r))) { return f.push(e) } }))) { h = false; break } } else if (!(g === m || o(g, m, n, i, r))) { h = false; break } } r["delete"](t); r["delete"](e); return h } const Fm = Vm; function Hm(t) { var e = -1, n = Array(t.size); t.forEach((function (t, i) { n[++e] = [i, t] })); return n } const Um = Hm; function Wm(t) { var e = -1, n = Array(t.size); t.forEach((function (t) { n[++e] = t })); return n } const Gm = Wm; var qm = 1, Ym = 2; var $m = "[object Boolean]", Qm = "[object Date]", Km = "[object Error]", Zm = "[object Map]", Jm = "[object Number]", Xm = "[object RegExp]", tp = "[object Set]", ep = "[object String]", np = "[object Symbol]"; var ip = "[object ArrayBuffer]", op = "[object DataView]"; var rp = zt ? zt.prototype : undefined, sp = rp ? rp.valueOf : undefined; function ap(t, e, n, i, o, r, s) { switch (n) { case op: if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) { return false } t = t.buffer; e = e.buffer; case ip: if (t.byteLength != e.byteLength || !r(new ls(t), new ls(e))) { return false } return true; case $m: case Qm: case Jm: return we(+t, +e); case Km: return t.name == e.name && t.message == e.message; case Xm: case ep: return t == e + ""; case Zm: var a = Um; case tp: var c = i & qm; a || (a = Gm); if (t.size != e.size && !c) { return false } var l = s.get(t); if (l) { return l == e } i |= Ym; s.set(t, e); var d = Fm(a(t), a(e), i, o, r, s); s["delete"](t); return d; case np: if (sp) { return sp.call(t) == sp.call(e) } }return false } const cp = ap; var lp = 1; var dp = Object.prototype; var up = dp.hasOwnProperty; function hp(t, e, n, i, o, r) { var s = n & lp, a = zr(t), c = a.length, l = zr(e), d = l.length; if (c != d && !s) { return false } var u = c; while (u--) { var h = a[u]; if (!(s ? h in e : up.call(e, h))) { return false } } var f = r.get(t); var g = r.get(e); if (f && g) { return f == e && g == t } var m = true; r.set(t, e); r.set(e, t); var p = s; while (++u < c) { h = a[u]; var k = t[h], b = e[h]; if (i) { var w = s ? i(b, k, h, e, t, r) : i(k, b, h, t, e, r) } if (!(w === undefined ? k === b || o(k, b, n, i, r) : w)) { m = false; break } p || (p = h == "constructor") } if (m && !p) { var _ = t.constructor, A = e.constructor; if (_ != A && ("constructor" in t && "constructor" in e) && !(typeof _ == "function" && _ instanceof _ && typeof A == "function" && A instanceof A)) { m = false } } r["delete"](t); r["delete"](e); return m } const fp = hp; var gp = 1; var mp = "[object Arguments]", pp = "[object Array]", kp = "[object Object]"; var bp = Object.prototype; var wp = bp.hasOwnProperty; function _p(t, e, n, i, o, r) { var s = Zt(t), a = Zt(e), c = s ? pp : is(t), l = a ? pp : is(e); c = c == mp ? kp : c; l = l == mp ? kp : l; var d = c == kp, u = l == kp, h = c == l; if (h && Li(t)) { if (!Li(e)) { return false } s = true; d = false } if (h && !d) { r || (r = new ri); return s || Io(t) ? Fm(t, e, n, i, o, r) : cp(t, e, c, n, i, o, r) } if (!(n & gp)) { var f = d && wp.call(t, "__wrapped__"), g = u && wp.call(e, "__wrapped__"); if (f || g) { var m = f ? t.value() : t, p = g ? e.value() : e; r || (r = new ri); return o(m, p, n, i, r) } } if (!h) { return false } r || (r = new ri); return fp(t, e, n, i, o, r) } const Ap = _p; function Cp(t, e, n, i, o) { if (t === e) { return true } if (t == null || e == null || !Xt(t) && !Xt(e)) { return t !== t && e !== e } return Ap(t, e, n, i, Cp, o) } const vp = Cp; function yp(t, e, n) { n = typeof n == "function" ? n : undefined; var i = n ? n(t, e) : undefined; return i === undefined ? vp(t, e, undefined, n) : !!i } const xp = yp; class Ep extends tm { constructor(t) { super(t); this._config = { childList: true, characterData: true, subtree: true }; this.domConverter = t.domConverter; this.renderer = t._renderer; this._domElements = new Set; this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this)) } flush() { this._onMutations(this._mutationObserver.takeRecords()) } observe(t) { this._domElements.add(t); if (this.isEnabled) { this._mutationObserver.observe(t, this._config) } } stopObserving(t) { this._domElements.delete(t); if (this.isEnabled) { this._mutationObserver.disconnect(); for (const t of this._domElements) { this._mutationObserver.observe(t, this._config) } } } enable() { super.enable(); for (const t of this._domElements) { this._mutationObserver.observe(t, this._config) } } disable() { super.disable(); this._mutationObserver.disconnect() } destroy() { super.destroy(); this._mutationObserver.disconnect() } _onMutations(t) { if (t.length === 0) { return } const e = this.domConverter; const n = new Set; const i = new Set; for (const n of t) { const t = e.mapDomToView(n.target); if (!t) { continue } if (t.is("uiElement") || t.is("rawElement")) { continue } if (n.type === "childList" && !this._isBogusBrMutation(n)) { i.add(t) } } for (const o of t) { const t = e.mapDomToView(o.target); if (t && (t.is("uiElement") || t.is("rawElement"))) { continue } if (o.type === "characterData") { const t = e.findCorrespondingViewText(o.target); if (t && !i.has(t.parent)) { n.add(t) } else if (!t && yg(o.target)) { i.add(e.mapDomToView(o.target.parentNode)) } } } let o = false; for (const t of n) { o = true; this.renderer.markToSync("text", t) } for (const t of i) { const n = e.mapViewToDom(t); const i = Array.from(t.getChildren()); const r = Array.from(e.domChildrenToView(n, { withChildren: false })); if (!xp(i, r, Dp)) { o = true; this.renderer.markToSync("children", t) } } if (o) { this.view.forceRender() } } _isBogusBrMutation(t) { let e = null; if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) { e = this.domConverter.domToView(t.addedNodes[0], { withChildren: false }) } return e && e.is("element", "br") } } function Dp(t, e) { if (Array.isArray(t)) { return } if (t === e) { return true } else if (t.is("$text") && e.is("$text")) { return t.data === e.data } return false } class Ip extends om { constructor(t) { super(t); this._isFocusChanging = false; this.domEventType = ["focus", "blur"]; this.useCapture = true; const e = this.document; e.on("focus", (() => { this._isFocusChanging = true; this._renderTimeoutId = setTimeout((() => { this.flush(); t.change((() => { })) }), 50) })); e.on("blur", ((n, i) => { const o = e.selection.editableElement; if (o === null || o === i.target) { e.isFocused = false; this._isFocusChanging = false; t.change((() => { })) } })) } flush() { if (this._isFocusChanging) { this._isFocusChanging = false; this.document.isFocused = true } } onDomEvent(t) { this.fire(t.type, t) } destroy() { if (this._renderTimeoutId) { clearTimeout(this._renderTimeoutId) } super.destroy() } } class Tp extends tm { constructor(t) { super(t); this.mutationObserver = t.getObserver(Ep); this.focusObserver = t.getObserver(Ip); this.selection = this.document.selection; this.domConverter = t.domConverter; this._documents = new WeakSet; this._fireSelectionChangeDoneDebounced = xm((t => { this.document.fire("selectionChangeDone", t) }), 200); this._clearInfiniteLoopInterval = setInterval((() => this._clearInfiniteLoop()), 1e3); this._documentIsSelectingInactivityTimeoutDebounced = xm((() => this.document.isSelecting = false), 5e3); this._loopbackCounter = 0 } observe(t) { const e = t.ownerDocument; const n = () => { this.document.isSelecting = true; this._documentIsSelectingInactivityTimeoutDebounced() }; const i = () => { if (!this.document.isSelecting) { return } this._handleSelectionChange(null, e); this.document.isSelecting = false; this._documentIsSelectingInactivityTimeoutDebounced.cancel() }; this.listenTo(t, "selectstart", n, { priority: "highest" }); this.listenTo(t, "keydown", i, { priority: "highest", useCapture: true }); this.listenTo(t, "keyup", i, { priority: "highest", useCapture: true }); if (this._documents.has(e)) { return } this.listenTo(e, "mouseup", i, { priority: "highest", useCapture: true }); this.listenTo(e, "selectionchange", ((t, n) => { if (this.document.isComposing && !l.isAndroid) { return } this._handleSelectionChange(n, e); this._documentIsSelectingInactivityTimeoutDebounced() })); this._documents.add(e) } stopObserving(t) { this.stopListening(t) } destroy() { super.destroy(); clearInterval(this._clearInfiniteLoopInterval); this._fireSelectionChangeDoneDebounced.cancel(); this._documentIsSelectingInactivityTimeoutDebounced.cancel() } _reportInfiniteLoop() { } _handleSelectionChange(t, e) { if (!this.isEnabled) { return } const n = e.defaultView.getSelection(); if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) { return } this.mutationObserver.flush(); const i = this.domConverter.domSelectionToView(n); if (i.rangeCount == 0) { this.view.hasDomSelection = false; return } this.view.hasDomSelection = true; if (this.selection.isEqual(i) && this.domConverter.isDomSelectionCorrect(n)) { return } if (++this._loopbackCounter > 60) { this._reportInfiniteLoop(); return } this.focusObserver.flush(); if (this.selection.isSimilar(i)) { this.view.forceRender() } else { const t = { oldSelection: this.selection, newSelection: i, domSelection: n }; this.document.fire("selectionChange", t); this._fireSelectionChangeDoneDebounced(t) } } _clearInfiniteLoop() { this._loopbackCounter = 0 } } class Mp extends om { constructor(t) { super(t); this.domEventType = ["compositionstart", "compositionupdate", "compositionend"]; const e = this.document; e.on("compositionstart", (() => { e.isComposing = true }), { priority: "low" }); e.on("compositionend", (() => { e.isComposing = false }), { priority: "low" }) } onDomEvent(t) { this.fire(t.type, t, { data: t.data }) } } class Sp { constructor(t, e = {}) { this._files = e.cacheFiles ? Np(t) : null; this._native = t } get files() { if (!this._files) { this._files = Np(this._native) } return this._files } get types() { return this._native.types } getData(t) { return this._native.getData(t) } setData(t, e) { this._native.setData(t, e) } set effectAllowed(t) { this._native.effectAllowed = t } get effectAllowed() { return this._native.effectAllowed } set dropEffect(t) { this._native.dropEffect = t } get dropEffect() { return this._native.dropEffect } get isCanceled() { return this._native.dropEffect == "none" || !!this._native.mozUserCancelled } } function Np(t) { const e = Array.from(t.files || []); const n = Array.from(t.items || []); if (e.length) { return e } return n.filter((t => t.kind === "file")).map((t => t.getAsFile())) } class Bp extends om { constructor() { super(...arguments); this.domEventType = "beforeinput" } onDomEvent(t) { const e = t.getTargetRanges(); const n = this.view; const i = n.document; let o = null; let r = null; let s = []; if (t.dataTransfer) { o = new Sp(t.dataTransfer) } if (t.data !== null) { r = t.data } else if (o) { r = o.getData("text/plain") } if (i.selection.isFake) { s = Array.from(i.selection.getRanges()) } else if (e.length) { s = e.map((t => n.domConverter.domRangeToView(t))) } else if (l.isAndroid) { const e = t.target.ownerDocument.defaultView.getSelection(); s = Array.from(n.domConverter.domSelectionToView(e).getRanges()) } if (l.isAndroid && t.inputType == "insertCompositionText" && r && r.endsWith("\n")) { this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: [n.createRange(s[0].end)] }); return } if (t.inputType == "insertText" && r && r.includes("\n")) { const e = r.split(/\n{1,2}/g); let n = s; for (let r = 0; r < e.length; r++) { const s = e[r]; if (s != "") { this.fire(t.type, t, { data: s, dataTransfer: o, targetRanges: n, inputType: t.inputType, isComposing: t.isComposing }); n = [i.selection.getFirstRange()] } if (r + 1 < e.length) { this.fire(t.type, t, { inputType: "insertParagraph", targetRanges: n }); n = [i.selection.getFirstRange()] } } return } this.fire(t.type, t, { data: r, dataTransfer: o, targetRanges: s, inputType: t.inputType, isComposing: t.isComposing }) } } class zp extends tm { constructor(t) { super(t); this.document.on("keydown", ((t, e) => { if (this.isEnabled && qc(e.keyCode)) { const n = new Rf(this.document, "arrowKey", this.document.selection.getFirstRange()); this.document.fire(n, e); if (n.stop.called) { t.stop() } } })) } observe() { } stopObserving() { } } class Pp extends tm { constructor(t) { super(t); const e = this.document; e.on("keydown", ((t, n) => { if (!this.isEnabled || n.keyCode != Fc.tab || n.ctrlKey) { return } const i = new Rf(e, "tab", e.selection.getFirstRange()); e.fire(i, n); if (i.stop.called) { t.stop() } })) } observe() { } stopObserving() { } } class Lp extends (ft()) { constructor(t) { super(); this.domRoots = new Map; this._initialDomRootAttributes = new WeakMap; this._observers = new Map; this._ongoingChange = false; this._postFixersInProgress = false; this._renderingDisabled = false; this._hasChangedSinceTheLastRendering = false; this.document = new qf(t); this.domConverter = new $g(this.document); this.set("isRenderingInProgress", false); this.set("hasDomSelection", false); this._renderer = new Bg(this.domConverter, this.document.selection); this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"); this._writer = new ag(this.document); this.addObserver(Ep); this.addObserver(Ip); this.addObserver(Tp); this.addObserver(rm); this.addObserver(Em); this.addObserver(Mp); this.addObserver(zp); this.addObserver(Bp); this.addObserver(Pp); Dg(this); tg(this); this.on("render", (() => { this._render(); this.document.fire("layoutChanged"); this._hasChangedSinceTheLastRendering = false })); this.listenTo(this.document.selection, "change", (() => { this._hasChangedSinceTheLastRendering = true })); this.listenTo(this.document, "change:isFocused", (() => { this._hasChangedSinceTheLastRendering = true })) } attachDomRoot(t, e = "main") { const n = this.document.getRoot(e); n._name = t.tagName.toLowerCase(); const i = {}; for (const { name: e, value: o } of Array.from(t.attributes)) { i[e] = o; if (e === "class") { this._writer.addClass(o.split(" "), n) } else { this._writer.setAttribute(e, o, n) } } this._initialDomRootAttributes.set(t, i); const o = () => { this._writer.setAttribute("contenteditable", (!n.isReadOnly).toString(), n); if (n.isReadOnly) { this._writer.addClass("ck-read-only", n) } else { this._writer.removeClass("ck-read-only", n) } }; o(); this.domRoots.set(e, t); this.domConverter.bindElements(t, n); this._renderer.markToSync("children", n); this._renderer.markToSync("attributes", n); this._renderer.domDocuments.add(t.ownerDocument); n.on("change:children", ((t, e) => this._renderer.markToSync("children", e))); n.on("change:attributes", ((t, e) => this._renderer.markToSync("attributes", e))); n.on("change:text", ((t, e) => this._renderer.markToSync("text", e))); n.on("change:isReadOnly", (() => this.change(o))); n.on("change", (() => { this._hasChangedSinceTheLastRendering = true })); for (const n of this._observers.values()) { n.observe(t, e) } } detachDomRoot(t) { const e = this.domRoots.get(t); Array.from(e.attributes).forEach((({ name: t }) => e.removeAttribute(t))); const n = this._initialDomRootAttributes.get(e); for (const t in n) { e.setAttribute(t, n[t]) } this.domRoots.delete(t); this.domConverter.unbindDomElement(e); for (const t of this._observers.values()) { t.stopObserving(e) } } getDomRoot(t = "main") { return this.domRoots.get(t) } addObserver(t) { let e = this._observers.get(t); if (e) { return e } e = new t(this); this._observers.set(t, e); for (const [t, n] of this.domRoots) { e.observe(n, t) } e.enable(); return e } getObserver(t) { return this._observers.get(t) } disableObservers() { for (const t of this._observers.values()) { t.disable() } } enableObservers() { for (const t of this._observers.values()) { t.enable() } } scrollToTheSelection({ alignToTop: t, forceScroll: e, viewportOffset: n = 20, ancestorOffset: i = 20 } = {}) { const o = this.document.selection.getFirstRange(); if (o) { Ic({ target: this.domConverter.viewRangeToDom(o), viewportOffset: n, ancestorOffset: i, alignToTop: t, forceScroll: e }) } } focus() { if (!this.document.isFocused) { const t = this.document.selection.editableElement; if (t) { this.domConverter.focus(t); this.forceRender() } else { } } } change(t) { if (this.isRenderingInProgress || this._postFixersInProgress) { throw new z("cannot-change-view-tree", this) } try { if (this._ongoingChange) { return t(this._writer) } this._ongoingChange = true; const e = t(this._writer); this._ongoingChange = false; if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) { this._postFixersInProgress = true; this.document._callPostFixers(this._writer); this._postFixersInProgress = false; this.fire("render") } return e } catch (t) { z.rethrowUnexpectedError(t, this) } } forceRender() { this._hasChangedSinceTheLastRendering = true; this.getObserver(Ip).flush(); this.change((() => { })) } destroy() { for (const t of this._observers.values()) { t.destroy() } this.document.destroy(); this.stopListening() } createPositionAt(t, e) { return Bf._createAt(t, e) } createPositionAfter(t) { return Bf._createAfter(t) } createPositionBefore(t) { return Bf._createBefore(t) } createRange(t, e) { return new zf(t, e) } createRangeOn(t) { return zf._createOn(t) } createRangeIn(t) { return zf._createIn(t) } createSelection(...t) { return new Lf(...t) } _disableRendering(t) { this._renderingDisabled = t; if (t == false) { this.change((() => { })) } } _render() { this.isRenderingInProgress = true; this.disableObservers(); this._renderer.render(); this.enableObservers(); this.isRenderingInProgress = false } } class Op { is() { throw new Error("is() method is abstract") } } class Rp extends Op { constructor(t) { super(); this.parent = null; this._attrs = fl(t) } get document() { return null } get index() { let t; if (!this.parent) { return null } if ((t = this.parent.getChildIndex(this)) === null) { throw new z("model-node-not-found-in-parent", this) } return t } get startOffset() { let t; if (!this.parent) { return null } if ((t = this.parent.getChildStartOffset(this)) === null) { throw new z("model-node-not-found-in-parent", this) } return t } get offsetSize() { return 1 } get endOffset() { if (!this.parent) { return null } return this.startOffset + this.offsetSize } get nextSibling() { const t = this.index; return t !== null && this.parent.getChild(t + 1) || null } get previousSibling() { const t = this.index; return t !== null && this.parent.getChild(t - 1) || null } get root() { let t = this; while (t.parent) { t = t.parent } return t } isAttached() { return this.parent === null ? false : this.root.isAttached() } getPath() { const t = []; let e = this; while (e.parent) { t.unshift(e.startOffset); e = e.parent } return t } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this : this.parent; while (n) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } getCommonAncestor(t, e = {}) { const n = this.getAncestors(e); const i = t.getAncestors(e); let o = 0; while (n[o] == i[o] && n[o]) { o++ } return o === 0 ? null : n[o - 1] } isBefore(t) { if (this == t) { return false } if (this.root !== t.root) { return false } const e = this.getPath(); const n = t.getPath(); const i = Et(e, n); switch (i) { case "prefix": return true; case "extension": return false; default: return e[i] < n[i] } } isAfter(t) { if (this == t) { return false } if (this.root !== t.root) { return false } return !this.isBefore(t) } hasAttribute(t) { return this._attrs.has(t) } getAttribute(t) { return this._attrs.get(t) } getAttributes() { return this._attrs.entries() } getAttributeKeys() { return this._attrs.keys() } toJSON() { const t = {}; if (this._attrs.size) { t.attributes = Array.from(this._attrs).reduce(((t, e) => { t[e[0]] = e[1]; return t }), {}) } return t } _clone(t) { return new this.constructor(this._attrs) } _remove() { this.parent._removeChildren(this.index) } _setAttribute(t, e) { this._attrs.set(t, e) } _setAttributesTo(t) { this._attrs = fl(t) } _removeAttribute(t) { return this._attrs.delete(t) } _clearAttributes() { this._attrs.clear() } } Rp.prototype.is = function (t) { return t === "node" || t === "model:node" }; class jp { constructor(t) { this._nodes = []; if (t) { this._insertNodes(0, t) } } [Symbol.iterator]() { return this._nodes[Symbol.iterator]() } get length() { return this._nodes.length } get maxOffset() { return this._nodes.reduce(((t, e) => t + e.offsetSize), 0) } getNode(t) { return this._nodes[t] || null } getNodeIndex(t) { const e = this._nodes.indexOf(t); return e == -1 ? null : e } getNodeStartOffset(t) { const e = this.getNodeIndex(t); return e === null ? null : this._nodes.slice(0, e).reduce(((t, e) => t + e.offsetSize), 0) } indexToOffset(t) { if (t == this._nodes.length) { return this.maxOffset } const e = this._nodes[t]; if (!e) { throw new z("model-nodelist-index-out-of-bounds", this) } return this.getNodeStartOffset(e) } offsetToIndex(t) { let e = 0; for (const n of this._nodes) { if (t >= e && t < e + n.offsetSize) { return this.getNodeIndex(n) } e += n.offsetSize } if (e != t) { throw new z("model-nodelist-offset-out-of-bounds", this, { offset: t, nodeList: this }) } return this.length } _insertNodes(t, e) { for (const t of e) { if (!(t instanceof Rp)) { throw new z("model-nodelist-insertnodes-not-node", this) } } this._nodes = ml(this._nodes, Array.from(e), t, 0) } _removeNodes(t, e = 1) { return this._nodes.splice(t, e) } toJSON() { return this._nodes.map((t => t.toJSON())) } } class Vp extends Rp { constructor(t, e) { super(e); this._data = t || "" } get offsetSize() { return this.data.length } get data() { return this._data } toJSON() { const t = super.toJSON(); t.data = this.data; return t } _clone() { return new Vp(this.data, this.getAttributes()) } static fromJSON(t) { return new Vp(t.data, t.attributes) } } Vp.prototype.is = function (t) { return t === "$text" || t === "model:$text" || t === "text" || t === "model:text" || t === "node" || t === "model:node" }; class Fp extends Op { constructor(t, e, n) { super(); this.textNode = t; if (e < 0 || e > t.offsetSize) { throw new z("model-textproxy-wrong-offsetintext", this) } if (n < 0 || e + n > t.offsetSize) { throw new z("model-textproxy-wrong-length", this) } this.data = t.data.substring(e, e + n); this.offsetInText = e } get startOffset() { return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null } get offsetSize() { return this.data.length } get endOffset() { return this.startOffset !== null ? this.startOffset + this.offsetSize : null } get isPartial() { return this.offsetSize !== this.textNode.offsetSize } get parent() { return this.textNode.parent } get root() { return this.textNode.root } getPath() { const t = this.textNode.getPath(); if (t.length > 0) { t[t.length - 1] += this.offsetInText } return t } getAncestors(t = {}) { const e = []; let n = t.includeSelf ? this : this.parent; while (n) { e[t.parentFirst ? "push" : "unshift"](n); n = n.parent } return e } hasAttribute(t) { return this.textNode.hasAttribute(t) } getAttribute(t) { return this.textNode.getAttribute(t) } getAttributes() { return this.textNode.getAttributes() } getAttributeKeys() { return this.textNode.getAttributeKeys() } } Fp.prototype.is = function (t) { return t === "$textProxy" || t === "model:$textProxy" || t === "textProxy" || t === "model:textProxy" }; class Hp extends Rp { constructor(t, e, n) { super(e); this._children = new jp; this.name = t; if (n) { this._insertChild(0, n) } } get childCount() { return this._children.length } get maxOffset() { return this._children.maxOffset } get isEmpty() { return this.childCount === 0 } getChild(t) { return this._children.getNode(t) } getChildren() { return this._children[Symbol.iterator]() } getChildIndex(t) { return this._children.getNodeIndex(t) } getChildStartOffset(t) { return this._children.getNodeStartOffset(t) } offsetToIndex(t) { return this._children.offsetToIndex(t) } getNodeByPath(t) { let e = this; for (const n of t) { e = e.getChild(e.offsetToIndex(n)) } return e } findAncestor(t, e = {}) { let n = e.includeSelf ? this : this.parent; while (n) { if (n.name === t) { return n } n = n.parent } return null } toJSON() { const t = super.toJSON(); t.name = this.name; if (this._children.length > 0) { t.children = []; for (const e of this._children) { t.children.push(e.toJSON()) } } return t } _clone(t = false) { const e = t ? Array.from(this._children).map((t => t._clone(true))) : undefined; return new Hp(this.name, this.getAttributes(), e) } _appendChild(t) { this._insertChild(this.childCount, t) } _insertChild(t, e) { const n = Up(e); for (const t of n) { if (t.parent !== null) { t._remove() } t.parent = this } this._children._insertNodes(t, n) } _removeChildren(t, e = 1) { const n = this._children._removeNodes(t, e); for (const t of n) { t.parent = null } return n } static fromJSON(t) { let e; if (t.children) { e = []; for (const n of t.children) { if (n.name) { e.push(Hp.fromJSON(n)) } else { e.push(Vp.fromJSON(n)) } } } return new Hp(t.name, t.attributes, e) } } Hp.prototype.is = function (t, e) { if (!e) { return t === "element" || t === "model:element" || t === "node" || t === "model:node" } return e === this.name && (t === "element" || t === "model:element") }; function Up(t) { if (typeof t == "string") { return [new Vp(t)] } if (!Dt(t)) { t = [t] } return Array.from(t).map((t => { if (typeof t == "string") { return new Vp(t) } if (t instanceof Fp) { return new Vp(t.data, t.getAttributes()) } return t })) } class Wp { constructor(t) { if (!t || !t.boundaries && !t.startPosition) { throw new z("model-tree-walker-no-start-position", null) } const e = t.direction || "forward"; if (e != "forward" && e != "backward") { throw new z("model-tree-walker-unknown-direction", t, { direction: e }) } this.direction = e; this.boundaries = t.boundaries || null; if (t.startPosition) { this._position = t.startPosition.clone() } else { this._position = qp._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]) } this.position.stickiness = "toNone"; this.singleCharacters = !!t.singleCharacters; this.shallow = !!t.shallow; this.ignoreElementEnd = !!t.ignoreElementEnd; this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null; this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null; this._visitedParent = this.position.parent } [Symbol.iterator]() { return this } get position() { return this._position } skip(t) { let e, n, i, o; do { i = this.position; o = this._visitedParent; ({ done: e, value: n } = this.next()) } while (!e && t(n)); if (!e) { this._position = i; this._visitedParent = o } } next() { if (this.direction == "forward") { return this._next() } else { return this._previous() } } _next() { const t = this.position; const e = this.position.clone(); const n = this._visitedParent; if (n.parent === null && e.offset === n.maxOffset) { return { done: true, value: undefined } } if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) { return { done: true, value: undefined } } const i = Yp(e, n); const o = i ? i : $p(e, n, i); if (o instanceof Hp) { if (!this.shallow) { e.path.push(0); this._visitedParent = o } else { e.offset++ } this._position = e; return Gp("elementStart", o, t, e, 1) } else if (o instanceof Vp) { let i; if (this.singleCharacters) { i = 1 } else { let t = o.endOffset; if (this._boundaryEndParent == n && this.boundaries.end.offset < t) { t = this.boundaries.end.offset } i = t - e.offset } const r = e.offset - o.startOffset; const s = new Fp(o, r, i); e.offset += i; this._position = e; return Gp("text", s, t, e, i) } else { e.path.pop(); e.offset++; this._position = e; this._visitedParent = n.parent; if (this.ignoreElementEnd) { return this._next() } else { return Gp("elementEnd", n, t, e) } } } _previous() { const t = this.position; const e = this.position.clone(); const n = this._visitedParent; if (n.parent === null && e.offset === 0) { return { done: true, value: undefined } } if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) { return { done: true, value: undefined } } const i = e.parent; const o = Yp(e, i); const r = o ? o : Qp(e, i, o); if (r instanceof Hp) { e.offset--; if (!this.shallow) { e.path.push(r.maxOffset); this._position = e; this._visitedParent = r; if (this.ignoreElementEnd) { return this._previous() } else { return Gp("elementEnd", r, t, e) } } else { this._position = e; return Gp("elementStart", r, t, e, 1) } } else if (r instanceof Vp) { let i; if (this.singleCharacters) { i = 1 } else { let t = r.startOffset; if (this._boundaryStartParent == n && this.boundaries.start.offset > t) { t = this.boundaries.start.offset } i = e.offset - t } const o = e.offset - r.startOffset; const s = new Fp(r, o - i, i); e.offset -= i; this._position = e; return Gp("text", s, t, e, i) } else { e.path.pop(); this._position = e; this._visitedParent = n.parent; return Gp("elementStart", n, t, e, 1) } } } function Gp(t, e, n, i, o) { return { done: false, value: { type: t, item: e, previousPosition: n, nextPosition: i, length: o } } } class qp extends Op { constructor(t, e, n = "toNone") { super(); if (!t.is("element") && !t.is("documentFragment")) { throw new z("model-position-root-invalid", t) } if (!(e instanceof Array) || e.length === 0) { throw new z("model-position-path-incorrect-format", t, { path: e }) } if (t.is("rootElement")) { e = e.slice() } else { e = [...t.getPath(), ...e]; t = t.root } this.root = t; this.path = e; this.stickiness = n } get offset() { return this.path[this.path.length - 1] } set offset(t) { this.path[this.path.length - 1] = t } get parent() { let t = this.root; for (let e = 0; e < this.path.length - 1; e++) { t = t.getChild(t.offsetToIndex(this.path[e])); if (!t) { throw new z("model-position-path-incorrect", this, { position: this }) } } if (t.is("$text")) { throw new z("model-position-path-incorrect", this, { position: this }) } return t } get index() { return this.parent.offsetToIndex(this.offset) } get textNode() { return Yp(this, this.parent) } get nodeAfter() { const t = this.parent; return $p(this, t, Yp(this, t)) } get nodeBefore() { const t = this.parent; return Qp(this, t, Yp(this, t)) } get isAtStart() { return this.offset === 0 } get isAtEnd() { return this.offset == this.parent.maxOffset } compareWith(t) { if (this.root != t.root) { return "different" } const e = Et(this.path, t.path); switch (e) { case "same": return "same"; case "prefix": return "before"; case "extension": return "after"; default: return this.path[e] < t.path[e] ? "before" : "after" } } getLastMatchingPosition(t, e = {}) { e.startPosition = this; const n = new Wp(e); n.skip(t); return n.position } getParentPath() { return this.path.slice(0, -1) } getAncestors() { const t = this.parent; if (t.is("documentFragment")) { return [t] } else { return t.getAncestors({ includeSelf: true }) } } findAncestor(t) { const e = this.parent; if (e.is("element")) { return e.findAncestor(t, { includeSelf: true }) } return null } getCommonPath(t) { if (this.root != t.root) { return [] } const e = Et(this.path, t.path); const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e; return this.path.slice(0, n) } getCommonAncestor(t) { const e = this.getAncestors(); const n = t.getAncestors(); let i = 0; while (e[i] == n[i] && e[i]) { i++ } return i === 0 ? null : e[i - 1] } getShiftedBy(t) { const e = this.clone(); const n = e.offset + t; e.offset = n < 0 ? 0 : n; return e } isAfter(t) { return this.compareWith(t) == "after" } isBefore(t) { return this.compareWith(t) == "before" } isEqual(t) { return this.compareWith(t) == "same" } isTouching(t) { if (this.root !== t.root) { return false } const e = Math.min(this.path.length, t.path.length); for (let n = 0; n < e; n++) { const e = this.path[n] - t.path[n]; if (e < -1 || e > 1) { return false } else if (e === 1) { return Kp(t, this, n) } else if (e === -1) { return Kp(this, t, n) } } if (this.path.length === t.path.length) { return true } else if (this.path.length > t.path.length) { return Zp(this.path, e) } else { return Zp(t.path, e) } } hasSameParentAs(t) { if (this.root !== t.root) { return false } const e = this.getParentPath(); const n = t.getParentPath(); return Et(e, n) == "same" } getTransformedByOperation(t) { let e; switch (t.type) { case "insert": e = this._getTransformedByInsertOperation(t); break; case "move": case "remove": case "reinsert": e = this._getTransformedByMoveOperation(t); break; case "split": e = this._getTransformedBySplitOperation(t); break; case "merge": e = this._getTransformedByMergeOperation(t); break; default: e = qp._createAt(this); break }return e } _getTransformedByInsertOperation(t) { return this._getTransformedByInsertion(t.position, t.howMany) } _getTransformedByMoveOperation(t) { return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany) } _getTransformedBySplitOperation(t) { const e = t.movedRange; const n = e.containsPosition(this) || e.start.isEqual(this) && this.stickiness == "toNext"; if (n) { return this._getCombined(t.splitPosition, t.moveTargetPosition) } else { if (t.graveyardPosition) { return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1) } else { return this._getTransformedByInsertion(t.insertionPosition, 1) } } } _getTransformedByMergeOperation(t) { const e = t.movedRange; const n = e.containsPosition(this) || e.start.isEqual(this); let i; if (n) { i = this._getCombined(t.sourcePosition, t.targetPosition); if (t.sourcePosition.isBefore(t.targetPosition)) { i = i._getTransformedByDeletion(t.deletionPosition, 1) } } else if (this.isEqual(t.deletionPosition)) { i = qp._createAt(t.deletionPosition) } else { i = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1) } return i } _getTransformedByDeletion(t, e) { const n = qp._createAt(this); if (this.root != t.root) { return n } if (Et(t.getParentPath(), this.getParentPath()) == "same") { if (t.offset < this.offset) { if (t.offset + e > this.offset) { return null } else { n.offset -= e } } } else if (Et(t.getParentPath(), this.getParentPath()) == "prefix") { const i = t.path.length - 1; if (t.offset <= this.path[i]) { if (t.offset + e > this.path[i]) { return null } else { n.path[i] -= e } } } return n } _getTransformedByInsertion(t, e) { const n = qp._createAt(this); if (this.root != t.root) { return n } if (Et(t.getParentPath(), this.getParentPath()) == "same") { if (t.offset < this.offset || t.offset == this.offset && this.stickiness != "toPrevious") { n.offset += e } } else if (Et(t.getParentPath(), this.getParentPath()) == "prefix") { const i = t.path.length - 1; if (t.offset <= this.path[i]) { n.path[i] += e } } return n } _getTransformedByMove(t, e, n) { e = e._getTransformedByDeletion(t, n); if (t.isEqual(e)) { return qp._createAt(this) } const i = this._getTransformedByDeletion(t, n); const o = i === null || t.isEqual(this) && this.stickiness == "toNext" || t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious"; if (o) { return this._getCombined(t, e) } else { return i._getTransformedByInsertion(e, n) } } _getCombined(t, e) { const n = t.path.length - 1; const i = qp._createAt(e); i.stickiness = this.stickiness; i.offset = i.offset + this.path[n] - t.offset; i.path = [...i.path, ...this.path.slice(n + 1)]; return i } toJSON() { return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness } } clone() { return new this.constructor(this.root, this.path, this.stickiness) } static _createAt(t, e, n = "toNone") { if (t instanceof qp) { return new qp(t.root, t.path, t.stickiness) } else { const i = t; if (e == "end") { e = i.maxOffset } else if (e == "before") { return this._createBefore(i, n) } else if (e == "after") { return this._createAfter(i, n) } else if (e !== 0 && !e) { throw new z("model-createpositionat-offset-required", [this, t]) } if (!i.is("element") && !i.is("documentFragment")) { throw new z("model-position-parent-incorrect", [this, t]) } const o = i.getPath(); o.push(e); return new this(i.root, o, n) } } static _createAfter(t, e) { if (!t.parent) { throw new z("model-position-after-root", [this, t], { root: t }) } return this._createAt(t.parent, t.endOffset, e) } static _createBefore(t, e) { if (!t.parent) { throw new z("model-position-before-root", t, { root: t }) } return this._createAt(t.parent, t.startOffset, e) } static fromJSON(t, e) { if (t.root === "$graveyard") { const n = new qp(e.graveyard, t.path); n.stickiness = t.stickiness; return n } if (!e.getRoot(t.root)) { throw new z("model-position-fromjson-no-root", e, { rootName: t.root }) } return new qp(e.getRoot(t.root), t.path, t.stickiness) } } qp.prototype.is = function (t) { return t === "position" || t === "model:position" }; function Yp(t, e) { const n = e.getChild(e.offsetToIndex(t.offset)); if (n && n.is("$text") && n.startOffset < t.offset) { return n } return null } function $p(t, e, n) { if (n !== null) { return null } return e.getChild(e.offsetToIndex(t.offset)) } function Qp(t, e, n) { if (n !== null) { return null } return e.getChild(e.offsetToIndex(t.offset) - 1) } function Kp(t, e, n) { if (n + 1 === t.path.length) { return false } if (!Zp(e.path, n + 1)) { return false } if (!Jp(t, n + 1)) { return false } return true } function Zp(t, e) { while (e < t.length) { if (t[e] !== 0) { return false } e++ } return true } function Jp(t, e) { let n = t.parent; let i = t.path.length - 1; let o = 0; while (i >= e) { if (t.path[i] + o !== n.maxOffset) { return false } o = 1; i--; n = n.parent } return true } class Xp extends Op { constructor(t, e) { super(); this.start = qp._createAt(t); this.end = e ? qp._createAt(e) : qp._createAt(t); this.start.stickiness = this.isCollapsed ? "toNone" : "toNext"; this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious" } *[Symbol.iterator]() { yield* new Wp({ boundaries: this, ignoreElementEnd: true }) } get isCollapsed() { return this.start.isEqual(this.end) } get isFlat() { const t = this.start.getParentPath(); const e = this.end.getParentPath(); return Et(t, e) == "same" } get root() { return this.start.root } containsPosition(t) { return t.isAfter(this.start) && t.isBefore(this.end) } containsRange(t, e = false) { if (t.isCollapsed) { e = false } const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start); const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end); return n && i } containsItem(t) { const e = qp._createBefore(t); return this.containsPosition(e) || this.start.isEqual(e) } isEqual(t) { return this.start.isEqual(t.start) && this.end.isEqual(t.end) } isIntersecting(t) { return this.start.isBefore(t.end) && this.end.isAfter(t.start) } getDifference(t) { const e = []; if (this.isIntersecting(t)) { if (this.containsPosition(t.start)) { e.push(new Xp(this.start, t.start)) } if (this.containsPosition(t.end)) { e.push(new Xp(t.end, this.end)) } } else { e.push(new Xp(this.start, this.end)) } return e } getIntersection(t) { if (this.isIntersecting(t)) { let e = this.start; let n = this.end; if (this.containsPosition(t.start)) { e = t.start } if (this.containsPosition(t.end)) { n = t.end } return new Xp(e, n) } return null } getJoined(t, e = false) { let n = this.isIntersecting(t); if (!n) { if (this.start.isBefore(t.start)) { n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start) } else { n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start) } } if (!n) { return null } let i = this.start; let o = this.end; if (t.start.isBefore(i)) { i = t.start } if (t.end.isAfter(o)) { o = t.end } return new Xp(i, o) } getMinimalFlatRanges() { const t = []; const e = this.start.getCommonPath(this.end).length; const n = qp._createAt(this.start); let i = n.parent; while (n.path.length > e + 1) { const e = i.maxOffset - n.offset; if (e !== 0) { t.push(new Xp(n, n.getShiftedBy(e))) } n.path = n.path.slice(0, -1); n.offset++; i = i.parent } while (n.path.length <= this.end.path.length) { const e = this.end.path[n.path.length - 1]; const i = e - n.offset; if (i !== 0) { t.push(new Xp(n, n.getShiftedBy(i))) } n.offset = e; n.path.push(0) } return t } getWalker(t = {}) { t.boundaries = this; return new Wp(t) } *getItems(t = {}) { t.boundaries = this; t.ignoreElementEnd = true; const e = new Wp(t); for (const t of e) { yield t.item } } *getPositions(t = {}) { t.boundaries = this; const e = new Wp(t); yield e.position; for (const t of e) { yield t.nextPosition } } getTransformedByOperation(t) { switch (t.type) { case "insert": return this._getTransformedByInsertOperation(t); case "move": case "remove": case "reinsert": return this._getTransformedByMoveOperation(t); case "split": return [this._getTransformedBySplitOperation(t)]; case "merge": return [this._getTransformedByMergeOperation(t)] }return [new Xp(this.start, this.end)] } getTransformedByOperations(t) { const e = [new Xp(this.start, this.end)]; for (const n of t) { for (let t = 0; t < e.length; t++) { const i = e[t].getTransformedByOperation(n); e.splice(t, 1, ...i); t += i.length - 1 } } for (let t = 0; t < e.length; t++) { const n = e[t]; for (let i = t + 1; i < e.length; i++) { const t = e[i]; if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) { e.splice(i, 1) } } } return e } getCommonAncestor() { return this.start.getCommonAncestor(this.end) } getContainedElement() { if (this.isCollapsed) { return null } const t = this.start.nodeAfter; const e = this.end.nodeBefore; if (t && t.is("element") && t === e) { return t } return null } toJSON() { return { start: this.start.toJSON(), end: this.end.toJSON() } } clone() { return new this.constructor(this.start, this.end) } _getTransformedByInsertOperation(t, e = false) { return this._getTransformedByInsertion(t.position, t.howMany, e) } _getTransformedByMoveOperation(t, e = false) { const n = t.sourcePosition; const i = t.howMany; const o = t.targetPosition; return this._getTransformedByMove(n, o, i, e) } _getTransformedBySplitOperation(t) { const e = this.start._getTransformedBySplitOperation(t); let n = this.end._getTransformedBySplitOperation(t); if (this.end.isEqual(t.insertionPosition)) { n = this.end.getShiftedBy(1) } if (e.root != n.root) { n = this.end.getShiftedBy(-1) } return new Xp(e, n) } _getTransformedByMergeOperation(t) { if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) { return new Xp(this.start) } let e = this.start._getTransformedByMergeOperation(t); let n = this.end._getTransformedByMergeOperation(t); if (e.root != n.root) { n = this.end.getShiftedBy(-1) } if (e.isAfter(n)) { if (t.sourcePosition.isBefore(t.targetPosition)) { e = qp._createAt(n); e.offset = 0 } else { if (!t.deletionPosition.isEqual(e)) { n = t.deletionPosition } e = t.targetPosition } return new Xp(e, n) } return new Xp(e, n) } _getTransformedByInsertion(t, e, n = false) { if (n && this.containsPosition(t)) { return [new Xp(this.start, t), new Xp(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))] } else { const n = new Xp(this.start, this.end); n.start = n.start._getTransformedByInsertion(t, e); n.end = n.end._getTransformedByInsertion(t, e); return [n] } } _getTransformedByMove(t, e, n, i = false) { if (this.isCollapsed) { const i = this.start._getTransformedByMove(t, e, n); return [new Xp(i)] } const o = Xp._createFromPositionAndShift(t, n); const r = e._getTransformedByDeletion(t, n); if (this.containsPosition(e) && !i) { if (o.containsPosition(this.start) || o.containsPosition(this.end)) { const i = this.start._getTransformedByMove(t, e, n); const o = this.end._getTransformedByMove(t, e, n); return [new Xp(i, o)] } } let s; const a = this.getDifference(o); let c = null; const l = this.getIntersection(o); if (a.length == 1) { c = new Xp(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n)) } else if (a.length == 2) { c = new Xp(this.start, this.end._getTransformedByDeletion(t, n)) } if (c) { s = c._getTransformedByInsertion(r, n, l !== null || i) } else { s = [] } if (l) { const t = new Xp(l.start._getCombined(o.start, r), l.end._getCombined(o.start, r)); if (s.length == 2) { s.splice(1, 0, t) } else { s.push(t) } } return s } _getTransformedByDeletion(t, e) { let n = this.start._getTransformedByDeletion(t, e); let i = this.end._getTransformedByDeletion(t, e); if (n == null && i == null) { return null } if (n == null) { n = t } if (i == null) { i = t } return new Xp(n, i) } static _createFromPositionAndShift(t, e) { const n = t; const i = t.getShiftedBy(e); return e > 0 ? new this(n, i) : new this(i, n) } static _createIn(t) { return new this(qp._createAt(t, 0), qp._createAt(t, t.maxOffset)) } static _createOn(t) { return this._createFromPositionAndShift(qp._createBefore(t), t.offsetSize) } static _createFromRanges(t) { if (t.length === 0) { throw new z("range-create-from-ranges-empty-array", null) } else if (t.length == 1) { return t[0].clone() } const e = t[0]; t.sort(((t, e) => t.start.isAfter(e.start) ? 1 : -1)); const n = t.indexOf(e); const i = new this(e.start, e.end); if (n > 0) { for (let e = n - 1; true; e++) { if (t[e].end.isEqual(i.start)) { i.start = qp._createAt(t[e].start) } else { break } } } for (let e = n + 1; e < t.length; e++) { if (t[e].start.isEqual(i.end)) { i.end = qp._createAt(t[e].end) } else { break } } return i } static fromJSON(t, e) { return new this(qp.fromJSON(t.start, e), qp.fromJSON(t.end, e)) } } Xp.prototype.is = function (t) { return t === "range" || t === "model:range" }; class tk extends (Y()) { constructor() { super(); this._modelToViewMapping = new WeakMap; this._viewToModelMapping = new WeakMap; this._viewToModelLengthCallbacks = new Map; this._markerNameToElements = new Map; this._elementToMarkerNames = new Map; this._deferredBindingRemovals = new Map; this._unboundMarkerNames = new Set; this.on("modelToViewPosition", ((t, e) => { if (e.viewPosition) { return } const n = this._modelToViewMapping.get(e.modelPosition.parent); if (!n) { throw new z("mapping-model-position-view-parent-not-found", this, { modelPosition: e.modelPosition }) } e.viewPosition = this.findPositionIn(n, e.modelPosition.offset) }), { priority: "low" }); this.on("viewToModelPosition", ((t, e) => { if (e.modelPosition) { return } const n = this.findMappedViewAncestor(e.viewPosition); const i = this._viewToModelMapping.get(n); const o = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n); e.modelPosition = qp._createAt(i, o) }), { priority: "low" }) } bindElements(t, e) { this._modelToViewMapping.set(t, e); this._viewToModelMapping.set(e, t) } unbindViewElement(t, e = {}) { const n = this.toModelElement(t); if (this._elementToMarkerNames.has(t)) { for (const e of this._elementToMarkerNames.get(t)) { this._unboundMarkerNames.add(e) } } if (e.defer) { this._deferredBindingRemovals.set(t, t.root) } else { this._viewToModelMapping.delete(t); if (this._modelToViewMapping.get(n) == t) { this._modelToViewMapping.delete(n) } } } unbindModelElement(t) { const e = this.toViewElement(t); this._modelToViewMapping.delete(t); if (this._viewToModelMapping.get(e) == t) { this._viewToModelMapping.delete(e) } } bindElementToMarker(t, e) { const n = this._markerNameToElements.get(e) || new Set; n.add(t); const i = this._elementToMarkerNames.get(t) || new Set; i.add(e); this._markerNameToElements.set(e, n); this._elementToMarkerNames.set(t, i) } unbindElementFromMarkerName(t, e) { const n = this._markerNameToElements.get(e); if (n) { n.delete(t); if (n.size == 0) { this._markerNameToElements.delete(e) } } const i = this._elementToMarkerNames.get(t); if (i) { i.delete(e); if (i.size == 0) { this._elementToMarkerNames.delete(t) } } } flushUnboundMarkerNames() { const t = Array.from(this._unboundMarkerNames); this._unboundMarkerNames.clear(); return t } flushDeferredBindings() { for (const [t, e] of this._deferredBindingRemovals) { if (t.root == e) { this.unbindViewElement(t) } } this._deferredBindingRemovals = new Map } clearBindings() { this._modelToViewMapping = new WeakMap; this._viewToModelMapping = new WeakMap; this._markerNameToElements = new Map; this._elementToMarkerNames = new Map; this._unboundMarkerNames = new Set; this._deferredBindingRemovals = new Map } toModelElement(t) { return this._viewToModelMapping.get(t) } toViewElement(t) { return this._modelToViewMapping.get(t) } toModelRange(t) { return new Xp(this.toModelPosition(t.start), this.toModelPosition(t.end)) } toViewRange(t) { return new zf(this.toViewPosition(t.start), this.toViewPosition(t.end)) } toModelPosition(t) { const e = { viewPosition: t, mapper: this }; this.fire("viewToModelPosition", e); return e.modelPosition } toViewPosition(t, e = {}) { const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom }; this.fire("modelToViewPosition", n); return n.viewPosition } markerNameToElements(t) { const e = this._markerNameToElements.get(t); if (!e) { return null } const n = new Set; for (const t of e) { if (t.is("attributeElement")) { for (const e of t.getElementsWithSameId()) { n.add(e) } } else { n.add(t) } } return n } registerViewToModelLength(t, e) { this._viewToModelLengthCallbacks.set(t, e) } findMappedViewAncestor(t) { let e = t.parent; while (!this._viewToModelMapping.has(e)) { e = e.parent } return e } _toModelOffset(t, e, n) { if (n != t) { const i = this._toModelOffset(t.parent, t.index, n); const o = this._toModelOffset(t, e, t); return i + o } if (t.is("$text")) { return e } let i = 0; for (let n = 0; n < e; n++) { i += this.getModelLength(t.getChild(n)) } return i } getModelLength(t) { if (this._viewToModelLengthCallbacks.get(t.name)) { const e = this._viewToModelLengthCallbacks.get(t.name); return e(t) } else if (this._viewToModelMapping.has(t)) { return 1 } else if (t.is("$text")) { return t.data.length } else if (t.is("uiElement")) { return 0 } else { let e = 0; for (const n of t.getChildren()) { e += this.getModelLength(n) } return e } } findPositionIn(t, e) { let n; let i = 0; let o = 0; let r = 0; if (t.is("$text")) { return new Bf(t, e) } while (o < e) { n = t.getChild(r); i = this.getModelLength(n); o += i; r++ } if (o == e) { return this._moveViewPositionToTextNode(new Bf(t, r)) } else { return this.findPositionIn(n, e - (o - i)) } } _moveViewPositionToTextNode(t) { const e = t.nodeBefore; const n = t.nodeAfter; if (e instanceof Cu) { return new Bf(e, e.data.length) } else if (n instanceof Cu) { return new Bf(n, 0) } return t } } class ek { constructor() { this._consumable = new Map; this._textProxyRegistry = new Map } add(t, e) { e = nk(e); if (t instanceof Fp) { t = this._getSymbolForTextProxy(t) } if (!this._consumable.has(t)) { this._consumable.set(t, new Map) } this._consumable.get(t).set(e, true) } consume(t, e) { e = nk(e); if (t instanceof Fp) { t = this._getSymbolForTextProxy(t) } if (this.test(t, e)) { this._consumable.get(t).set(e, false); return true } else { return false } } test(t, e) { e = nk(e); if (t instanceof Fp) { t = this._getSymbolForTextProxy(t) } const n = this._consumable.get(t); if (n === undefined) { return null } const i = n.get(e); if (i === undefined) { return null } return i } revert(t, e) { e = nk(e); if (t instanceof Fp) { t = this._getSymbolForTextProxy(t) } const n = this.test(t, e); if (n === false) { this._consumable.get(t).set(e, true); return true } else if (n === true) { return false } return null } verifyAllConsumed(t) { const e = []; for (const [n, i] of this._consumable) { for (const [o, r] of i) { const i = o.split(":")[0]; if (r && t == i) { e.push({ event: o, item: n.name || n.description }) } } } if (e.length) { throw new z("conversion-model-consumable-not-consumed", null, { items: e }) } } _getSymbolForTextProxy(t) { let e = null; const n = this._textProxyRegistry.get(t.startOffset); if (n) { const i = n.get(t.endOffset); if (i) { e = i.get(t.parent) } } if (!e) { e = this._addSymbolForTextProxy(t) } return e } _addSymbolForTextProxy(t) { const e = t.startOffset; const n = t.endOffset; const i = t.parent; const o = Symbol("$textProxy:" + t.data); let r; let s; r = this._textProxyRegistry.get(e); if (!r) { r = new Map; this._textProxyRegistry.set(e, r) } s = r.get(n); if (!s) { s = new Map; r.set(n, s) } s.set(i, o); return o } } function nk(t) { const e = t.split(":"); if (e[0] == "insert") { return e[0] } if (e[0] == "addMarker" || e[0] == "removeMarker") { return t } return e.length > 1 ? e[0] + ":" + e[1] : e[0] } class ik extends (Y()) { constructor(t) { super(); this._conversionApi = { dispatcher: this, ...t }; this._firedEventsMap = new WeakMap } convertChanges(t, e, n) { const i = this._createConversionApi(n, t.getRefreshedItems()); for (const e of t.getMarkersToRemove()) { this._convertMarkerRemove(e.name, e.range, i) } const o = this._reduceChanges(t.getChanges()); for (const t of o) { if (t.type === "insert") { this._convertInsert(Xp._createFromPositionAndShift(t.position, t.length), i) } else if (t.type === "reinsert") { this._convertReinsert(Xp._createFromPositionAndShift(t.position, t.length), i) } else if (t.type === "remove") { this._convertRemove(t.position, t.length, t.name, i) } else { this._convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, i) } } for (const t of i.mapper.flushUnboundMarkerNames()) { const n = e.get(t).getRange(); this._convertMarkerRemove(t, n, i); this._convertMarkerAdd(t, n, i) } for (const e of t.getMarkersToAdd()) { this._convertMarkerAdd(e.name, e.range, i) } i.mapper.flushDeferredBindings(); i.consumable.verifyAllConsumed("insert") } convert(t, e, n, i = {}) { const o = this._createConversionApi(n, undefined, i); this._convertInsert(t, o); for (const [t, n] of e) { this._convertMarkerAdd(t, n, o) } o.consumable.verifyAllConsumed("insert") } convertSelection(t, e, n) { const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition())); const o = this._createConversionApi(n); this._addConsumablesForSelection(o.consumable, t, i); this.fire("selection", { selection: t }, o); if (!t.isCollapsed) { return } for (const e of i) { const n = e.getRange(); if (!ok(t.getFirstPosition(), e, o.mapper)) { continue } const i = { item: t, markerName: e.name, markerRange: n }; if (o.consumable.test(t, "addMarker:" + e.name)) { this.fire(`addMarker:${e.name}`, i, o) } } for (const e of t.getAttributeKeys()) { const n = { item: t, range: t.getFirstRange(), attributeKey: e, attributeOldValue: null, attributeNewValue: t.getAttribute(e) }; if (o.consumable.test(t, "attribute:" + n.attributeKey)) { this.fire(`attribute:${n.attributeKey}:$text`, n, o) } } } _convertInsert(t, e, n = {}) { if (!n.doNotAddConsumables) { this._addConsumablesForInsert(e.consumable, Array.from(t)) } for (const n of Array.from(t.getWalker({ shallow: true })).map(sk)) { this._testAndFire("insert", n, e) } } _convertRemove(t, e, n, i) { this.fire(`remove:${n}`, { position: t, length: e }, i) } _convertAttribute(t, e, n, i, o) { this._addConsumablesForRange(o.consumable, t, `attribute:${e}`); for (const r of t) { const t = { item: r.item, range: Xp._createFromPositionAndShift(r.previousPosition, r.length), attributeKey: e, attributeOldValue: n, attributeNewValue: i }; this._testAndFire(`attribute:${e}`, t, o) } } _convertReinsert(t, e) { const n = Array.from(t.getWalker({ shallow: true })); this._addConsumablesForInsert(e.consumable, n); for (const t of n.map(sk)) { this._testAndFire("insert", { ...t, reconversion: true }, e) } } _convertMarkerAdd(t, e, n) { if (e.root.rootName == "$graveyard") { return } const i = `addMarker:${t}`; n.consumable.add(e, i); this.fire(i, { markerName: t, markerRange: e }, n); if (!n.consumable.consume(e, i)) { return } this._addConsumablesForRange(n.consumable, e, i); for (const o of e.getItems()) { if (!n.consumable.test(o, i)) { continue } const r = { item: o, range: Xp._createOn(o), markerName: t, markerRange: e }; this.fire(i, r, n) } } _convertMarkerRemove(t, e, n) { if (e.root.rootName == "$graveyard") { return } this.fire(`removeMarker:${t}`, { markerName: t, markerRange: e }, n) } _reduceChanges(t) { const e = { changes: t }; this.fire("reduceChanges", e); return e.changes } _addConsumablesForInsert(t, e) { for (const n of e) { const e = n.item; if (t.test(e, "insert") === null) { t.add(e, "insert"); for (const n of e.getAttributeKeys()) { t.add(e, "attribute:" + n) } } } return t } _addConsumablesForRange(t, e, n) { for (const i of e.getItems()) { t.add(i, n) } return t } _addConsumablesForSelection(t, e, n) { t.add(e, "selection"); for (const i of n) { t.add(e, "addMarker:" + i.name) } for (const n of e.getAttributeKeys()) { t.add(e, "attribute:" + n) } return t } _testAndFire(t, e, n) { const i = rk(t, e); const o = e.item.is("$textProxy") ? n.consumable._getSymbolForTextProxy(e.item) : e.item; const r = this._firedEventsMap.get(n); const s = r.get(o); if (!s) { r.set(o, new Set([i])) } else if (!s.has(i)) { s.add(i) } else { return } this.fire(i, e, n) } _testAndFireAddAttributes(t, e) { const n = { item: t, range: Xp._createOn(t) }; for (const t of n.item.getAttributeKeys()) { n.attributeKey = t; n.attributeOldValue = null; n.attributeNewValue = n.item.getAttribute(t); this._testAndFire(`attribute:${t}`, n, e) } } _createConversionApi(t, e = new Set, n = {}) { const i = { ...this._conversionApi, consumable: new ek, writer: t, options: n, convertItem: t => this._convertInsert(Xp._createOn(t), i), convertChildren: t => this._convertInsert(Xp._createIn(t), i, { doNotAddConsumables: true }), convertAttributes: t => this._testAndFireAddAttributes(t, i), canReuseView: t => !e.has(i.mapper.toModelElement(t)) }; this._firedEventsMap.set(i, new Map); return i } } function ok(t, e, n) { const i = e.getRange(); const o = Array.from(t.getAncestors()); o.shift(); o.reverse(); const r = o.some((t => { if (i.containsItem(t)) { const e = n.toViewElement(t); return !!e.getCustomProperty("addHighlight") } })); return !r } function rk(t, e) { const n = e.item.is("element") ? e.item.name : "$text"; return `${t}:${n}` } function sk(t) { const e = t.item; const n = Xp._createFromPositionAndShift(t.previousPosition, t.length); return { item: e, range: n } } class ak extends (Y(Op)) { constructor(...t) { super(); this._lastRangeBackward = false; this._attrs = new Map; this._ranges = []; if (t.length) { this.setTo(...t) } } get anchor() { if (this._ranges.length > 0) { const t = this._ranges[this._ranges.length - 1]; return this._lastRangeBackward ? t.end : t.start } return null } get focus() { if (this._ranges.length > 0) { const t = this._ranges[this._ranges.length - 1]; return this._lastRangeBackward ? t.start : t.end } return null } get isCollapsed() { const t = this._ranges.length; if (t === 1) { return this._ranges[0].isCollapsed } else { return false } } get rangeCount() { return this._ranges.length } get isBackward() { return !this.isCollapsed && this._lastRangeBackward } isEqual(t) { if (this.rangeCount != t.rangeCount) { return false } else if (this.rangeCount === 0) { return true } if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) { return false } for (const e of this._ranges) { let n = false; for (const i of t._ranges) { if (e.isEqual(i)) { n = true; break } } if (!n) { return false } } return true } *getRanges() { for (const t of this._ranges) { yield new Xp(t.start, t.end) } } getFirstRange() { let t = null; for (const e of this._ranges) { if (!t || e.start.isBefore(t.start)) { t = e } } return t ? new Xp(t.start, t.end) : null } getLastRange() { let t = null; for (const e of this._ranges) { if (!t || e.end.isAfter(t.end)) { t = e } } return t ? new Xp(t.start, t.end) : null } getFirstPosition() { const t = this.getFirstRange(); return t ? t.start.clone() : null } getLastPosition() { const t = this.getLastRange(); return t ? t.end.clone() : null } setTo(...t) { let [e, n, i] = t; if (typeof n == "object") { i = n; n = undefined } if (e === null) { this._setRanges([]) } else if (e instanceof ak) { this._setRanges(e.getRanges(), e.isBackward) } else if (e && typeof e.getRanges == "function") { this._setRanges(e.getRanges(), e.isBackward) } else if (e instanceof Xp) { this._setRanges([e], !!i && !!i.backward) } else if (e instanceof qp) { this._setRanges([new Xp(e)]) } else if (e instanceof Rp) { const t = !!i && !!i.backward; let o; if (n == "in") { o = Xp._createIn(e) } else if (n == "on") { o = Xp._createOn(e) } else if (n !== undefined) { o = new Xp(qp._createAt(e, n)) } else { throw new z("model-selection-setto-required-second-parameter", [this, e]) } this._setRanges([o], t) } else if (Dt(e)) { this._setRanges(e, i && !!i.backward) } else { throw new z("model-selection-setto-not-selectable", [this, e]) } } _setRanges(t, e = false) { const n = Array.from(t); const i = n.some((e => { if (!(e instanceof Xp)) { throw new z("model-selection-set-ranges-not-range", [this, t]) } return this._ranges.every((t => !t.isEqual(e))) })); if (n.length === this._ranges.length && !i) { return } this._replaceAllRanges(n); this._lastRangeBackward = !!e; this.fire("change:range", { directChange: true }) } setFocus(t, e) { if (this.anchor === null) { throw new z("model-selection-setfocus-no-ranges", [this, t]) } const n = qp._createAt(t, e); if (n.compareWith(this.focus) == "same") { return } const i = this.anchor; if (this._ranges.length) { this._popRange() } if (n.compareWith(i) == "before") { this._pushRange(new Xp(n, i)); this._lastRangeBackward = true } else { this._pushRange(new Xp(i, n)); this._lastRangeBackward = false } this.fire("change:range", { directChange: true }) } getAttribute(t) { return this._attrs.get(t) } getAttributes() { return this._attrs.entries() } getAttributeKeys() { return this._attrs.keys() } hasAttribute(t) { return this._attrs.has(t) } removeAttribute(t) { if (this.hasAttribute(t)) { this._attrs.delete(t); this.fire("change:attribute", { attributeKeys: [t], directChange: true }) } } setAttribute(t, e) { if (this.getAttribute(t) !== e) { this._attrs.set(t, e); this.fire("change:attribute", { attributeKeys: [t], directChange: true }) } } getSelectedElement() { if (this.rangeCount !== 1) { return null } return this.getFirstRange().getContainedElement() } *getSelectedBlocks() { const t = new WeakSet; for (const e of this.getRanges()) { const n = dk(e.start, t); if (hk(n, e)) { yield n } for (const n of e.getWalker()) { const i = n.item; if (n.type == "elementEnd" && lk(i, t, e)) { yield i } } const i = dk(e.end, t); if (fk(i, e)) { yield i } } } containsEntireContent(t = this.anchor.root) { const e = qp._createAt(t, 0); const n = qp._createAt(t, "end"); return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition()) } _pushRange(t) { this._checkRange(t); this._ranges.push(new Xp(t.start, t.end)) } _checkRange(t) { for (let e = 0; e < this._ranges.length; e++) { if (t.isIntersecting(this._ranges[e])) { throw new z("model-selection-range-intersects", [this, t], { addedRange: t, intersectingRange: this._ranges[e] }) } } } _replaceAllRanges(t) { this._removeAllRanges(); for (const e of t) { this._pushRange(e) } } _removeAllRanges() { while (this._ranges.length > 0) { this._popRange() } } _popRange() { this._ranges.pop() } } ak.prototype.is = function (t) { return t === "selection" || t === "model:selection" }; function ck(t, e) { if (e.has(t)) { return false } e.add(t); return t.root.document.model.schema.isBlock(t) && !!t.parent } function lk(t, e, n) { return ck(t, e) && uk(t, n) } function dk(t, e) { const n = t.parent; const i = n.root.document.model.schema; const o = t.parent.getAncestors({ parentFirst: true, includeSelf: true }); let r = false; const s = o.find((t => { if (r) { return false } r = i.isLimit(t); return !r && ck(t, e) })); o.forEach((t => e.add(t))); return s } function uk(t, e) { const n = gk(t); if (!n) { return true } const i = e.containsRange(Xp._createOn(n), true); return !i } function hk(t, e) { if (!t) { return false } if (e.isCollapsed || t.isEmpty) { return true } if (e.start.isTouching(qp._createAt(t, t.maxOffset))) { return false } return uk(t, e) } function fk(t, e) { if (!t) { return false } if (e.isCollapsed || t.isEmpty) { return true } if (e.end.isTouching(qp._createAt(t, 0))) { return false } return uk(t, e) } function gk(t) { const e = t.root.document.model.schema; let n = t.parent; while (n) { if (e.isBlock(n)) { return n } n = n.parent } } class mk extends (Y(Xp)) { constructor(t, e) { super(t, e); pk.call(this) } detach() { this.stopListening() } toRange() { return new Xp(this.start, this.end) } static fromRange(t) { return new mk(t.start, t.end) } } mk.prototype.is = function (t) { return t === "liveRange" || t === "model:liveRange" || t == "range" || t === "model:range" }; function pk() { this.listenTo(this.root.document.model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation) { return } kk.call(this, n) }), { priority: "low" }) } function kk(t) { const e = this.getTransformedByOperation(t); const n = Xp._createFromRanges(e); const i = !n.isEqual(this); const o = bk(this, t); let r = null; if (i) { if (n.root.rootName == "$graveyard") { if (t.type == "remove") { r = t.sourcePosition } else { r = t.deletionPosition } } const e = this.toRange(); this.start = n.start; this.end = n.end; this.fire("change:range", e, { deletionPosition: r }) } else if (o) { this.fire("change:content", this.toRange(), { deletionPosition: r }) } } function bk(t, e) { switch (e.type) { case "insert": return t.containsPosition(e.position); case "move": case "remove": case "reinsert": case "merge": return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition); case "split": return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition) }return false } const wk = "selection:"; class _k extends (Y(Op)) { constructor(t) { super(); this._selection = new Ak(t); this._selection.delegate("change:range").to(this); this._selection.delegate("change:attribute").to(this); this._selection.delegate("change:marker").to(this) } get isCollapsed() { return this._selection.isCollapsed } get anchor() { return this._selection.anchor } get focus() { return this._selection.focus } get rangeCount() { return this._selection.rangeCount } get hasOwnRange() { return this._selection.hasOwnRange } get isBackward() { return this._selection.isBackward } get isGravityOverridden() { return this._selection.isGravityOverridden } get markers() { return this._selection.markers } get _ranges() { return this._selection._ranges } getRanges() { return this._selection.getRanges() } getFirstPosition() { return this._selection.getFirstPosition() } getLastPosition() { return this._selection.getLastPosition() } getFirstRange() { return this._selection.getFirstRange() } getLastRange() { return this._selection.getLastRange() } getSelectedBlocks() { return this._selection.getSelectedBlocks() } getSelectedElement() { return this._selection.getSelectedElement() } containsEntireContent(t) { return this._selection.containsEntireContent(t) } destroy() { this._selection.destroy() } getAttributeKeys() { return this._selection.getAttributeKeys() } getAttributes() { return this._selection.getAttributes() } getAttribute(t) { return this._selection.getAttribute(t) } hasAttribute(t) { return this._selection.hasAttribute(t) } refresh() { this._selection.updateMarkers(); this._selection._updateAttributes(false) } observeMarkers(t) { this._selection.observeMarkers(t) } _setFocus(t, e) { this._selection.setFocus(t, e) } _setTo(...t) { this._selection.setTo(...t) } _setAttribute(t, e) { this._selection.setAttribute(t, e) } _removeAttribute(t) { this._selection.removeAttribute(t) } _getStoredAttributes() { return this._selection.getStoredAttributes() } _overrideGravity() { return this._selection.overrideGravity() } _restoreGravity(t) { this._selection.restoreGravity(t) } static _getStoreAttributeKey(t) { return wk + t } static _isStoreAttributeKey(t) { return t.startsWith(wk) } } _k.prototype.is = function (t) { return t === "selection" || t == "model:selection" || t == "documentSelection" || t == "model:documentSelection" }; class Ak extends ak { constructor(t) { super(); this.markers = new cl({ idProperty: "name" }); this._attributePriority = new Map; this._selectionRestorePosition = null; this._hasChangedRange = false; this._overriddenGravityRegister = new Set; this._observedMarkers = new Set; this._model = t.model; this._document = t; this.listenTo(this._model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation || n.type == "marker" || n.type == "rename" || n.type == "noop") { return } if (this._ranges.length == 0 && this._selectionRestorePosition) { this._fixGraveyardSelection(this._selectionRestorePosition) } this._selectionRestorePosition = null; if (this._hasChangedRange) { this._hasChangedRange = false; this.fire("change:range", { directChange: false }) } }), { priority: "lowest" }); this.on("change:range", (() => { this._validateSelectionRanges(this.getRanges()) })); this.listenTo(this._model.markers, "update", ((t, e, n, i) => { this._updateMarker(e, i) })); this.listenTo(this._document, "change", ((t, e) => { vk(this._model, e) })) } get isCollapsed() { const t = this._ranges.length; return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed } get anchor() { return super.anchor || this._document._getDefaultRange().start } get focus() { return super.focus || this._document._getDefaultRange().end } get rangeCount() { return this._ranges.length ? this._ranges.length : 1 } get hasOwnRange() { return this._ranges.length > 0 } get isGravityOverridden() { return !!this._overriddenGravityRegister.size } destroy() { for (let t = 0; t < this._ranges.length; t++) { this._ranges[t].detach() } this.stopListening() } *getRanges() { if (this._ranges.length) { yield* super.getRanges() } else { yield this._document._getDefaultRange() } } getFirstRange() { return super.getFirstRange() || this._document._getDefaultRange() } getLastRange() { return super.getLastRange() || this._document._getDefaultRange() } setTo(...t) { super.setTo(...t); this._updateAttributes(true); this.updateMarkers() } setFocus(t, e) { super.setFocus(t, e); this._updateAttributes(true); this.updateMarkers() } setAttribute(t, e) { if (this._setAttribute(t, e)) { const e = [t]; this.fire("change:attribute", { attributeKeys: e, directChange: true }) } } removeAttribute(t) { if (this._removeAttribute(t)) { const e = [t]; this.fire("change:attribute", { attributeKeys: e, directChange: true }) } } overrideGravity() { const t = T(); this._overriddenGravityRegister.add(t); if (this._overriddenGravityRegister.size === 1) { this._updateAttributes(true) } return t } restoreGravity(t) { if (!this._overriddenGravityRegister.has(t)) { throw new z("document-selection-gravity-wrong-restore", this, { uid: t }) } this._overriddenGravityRegister.delete(t); if (!this.isGravityOverridden) { this._updateAttributes(true) } } observeMarkers(t) { this._observedMarkers.add(t); this.updateMarkers() } _replaceAllRanges(t) { this._validateSelectionRanges(t); super._replaceAllRanges(t) } _popRange() { this._ranges.pop().detach() } _pushRange(t) { const e = this._prepareRange(t); if (e) { this._ranges.push(e) } } _validateSelectionRanges(t) { for (const e of t) { if (!this._document._validateSelectionRange(e)) { throw new z("document-selection-wrong-position", this, { range: e }) } } } _prepareRange(t) { this._checkRange(t); if (t.root == this._document.graveyard) { return } const e = mk.fromRange(t); e.on("change:range", ((t, n, i) => { this._hasChangedRange = true; if (e.root == this._document.graveyard) { this._selectionRestorePosition = i.deletionPosition; const t = this._ranges.indexOf(e); this._ranges.splice(t, 1); e.detach() } })); return e } updateMarkers() { if (!this._observedMarkers.size) { return } const t = []; let e = false; for (const e of this._model.markers) { const n = e.name.split(":", 1)[0]; if (!this._observedMarkers.has(n)) { continue } const i = e.getRange(); for (const n of this.getRanges()) { if (i.containsRange(n, !n.isCollapsed)) { t.push(e) } } } const n = Array.from(this.markers); for (const n of t) { if (!this.markers.has(n)) { this.markers.add(n); e = true } } for (const n of Array.from(this.markers)) { if (!t.includes(n)) { this.markers.remove(n); e = true } } if (e) { this.fire("change:marker", { oldMarkers: n, directChange: false }) } } _updateMarker(t, e) { const n = t.name.split(":", 1)[0]; if (!this._observedMarkers.has(n)) { return } let i = false; const o = Array.from(this.markers); const r = this.markers.has(t); if (!e) { if (r) { this.markers.remove(t); i = true } } else { let n = false; for (const t of this.getRanges()) { if (e.containsRange(t, !t.isCollapsed)) { n = true; break } } if (n && !r) { this.markers.add(t); i = true } else if (!n && r) { this.markers.remove(t); i = true } } if (i) { this.fire("change:marker", { oldMarkers: o, directChange: false }) } } _updateAttributes(t) { const e = fl(this._getSurroundingAttributes()); const n = fl(this.getAttributes()); if (t) { this._attributePriority = new Map; this._attrs = new Map } else { for (const [t, e] of this._attributePriority) { if (e == "low") { this._attrs.delete(t); this._attributePriority.delete(t) } } } this._setAttributesTo(e); const i = []; for (const [t, e] of this.getAttributes()) { if (!n.has(t) || n.get(t) !== e) { i.push(t) } } for (const [t] of n) { if (!this.hasAttribute(t)) { i.push(t) } } if (i.length > 0) { this.fire("change:attribute", { attributeKeys: i, directChange: false }) } } _setAttribute(t, e, n = true) { const i = n ? "normal" : "low"; if (i == "low" && this._attributePriority.get(t) == "normal") { return false } const o = super.getAttribute(t); if (o === e) { return false } this._attrs.set(t, e); this._attributePriority.set(t, i); return true } _removeAttribute(t, e = true) { const n = e ? "normal" : "low"; if (n == "low" && this._attributePriority.get(t) == "normal") { return false } this._attributePriority.set(t, n); if (!super.hasAttribute(t)) { return false } this._attrs.delete(t); return true } _setAttributesTo(t) { const e = new Set; for (const [e, n] of this.getAttributes()) { if (t.get(e) === n) { continue } this._removeAttribute(e, false) } for (const [n, i] of t) { const t = this._setAttribute(n, i, false); if (t) { e.add(n) } } return e } *getStoredAttributes() { const t = this.getFirstPosition().parent; if (this.isCollapsed && t.isEmpty) { for (const e of t.getAttributeKeys()) { if (e.startsWith(wk)) { const n = e.substr(wk.length); yield [n, t.getAttribute(e)] } } } } _getSurroundingAttributes() { const t = this.getFirstPosition(); const e = this._model.schema; let n = null; if (!this.isCollapsed) { const t = this.getFirstRange(); for (const i of t) { if (i.item.is("element") && e.isObject(i.item)) { break } if (i.type == "text") { n = i.item.getAttributes(); break } } } else { const i = t.textNode ? t.textNode : t.nodeBefore; const o = t.textNode ? t.textNode : t.nodeAfter; if (!this.isGravityOverridden) { n = Ck(i) } if (!n) { n = Ck(o) } if (!this.isGravityOverridden && !n) { let t = i; while (t && !e.isInline(t) && !n) { t = t.previousSibling; n = Ck(t) } } if (!n) { let t = o; while (t && !e.isInline(t) && !n) { t = t.nextSibling; n = Ck(t) } } if (!n) { n = this.getStoredAttributes() } } return n } _fixGraveyardSelection(t) { const e = this._model.schema.getNearestSelectionRange(t); if (e) { this._pushRange(e) } } } function Ck(t) { if (t instanceof Fp || t instanceof Vp) { return t.getAttributes() } return null } function vk(t, e) { const n = t.document.differ; for (const i of n.getChanges()) { if (i.type != "insert") { continue } const n = i.position.parent; const o = i.length === n.maxOffset; if (o) { t.enqueueChange(e, (t => { const e = Array.from(n.getAttributeKeys()).filter((t => t.startsWith(wk))); for (const i of e) { t.removeAttribute(i, n) } })) } } } class yk { constructor(t) { this._dispatchers = t } add(t) { for (const e of this._dispatchers) { t(e) } return this } } var xk = 1, Ek = 4; function Dk(t) { return Ra(t, xk | Ek) } const Ik = Dk; class Tk extends yk { elementToElement(t) { return this.add(Zk(t)) } elementToStructure(t) { return this.add(Jk(t)) } attributeToElement(t) { return this.add(Xk(t)) } attributeToAttribute(t) { return this.add(tb(t)) } markerToElement(t) { return this.add(eb(t)) } markerToHighlight(t) { return this.add(ib(t)) } markerToData(t) { return this.add(nb(t)) } } function Mk() { return (t, e, n) => { if (!n.consumable.consume(e.item, t.name)) { return } const i = n.writer; const o = n.mapper.toViewPosition(e.range.start); const r = i.createText(e.item.data); i.insert(o, r) } } function Sk() { return (t, e, n) => { n.convertAttributes(e.item); if (!e.reconversion && e.item.is("element") && !e.item.isEmpty) { n.convertChildren(e.item) } } } function Nk() { return (t, e, n) => { const i = n.mapper.toViewPosition(e.position); const o = e.position.getShiftedBy(e.length); const r = n.mapper.toViewPosition(o, { isPhantom: true }); const s = n.writer.createRange(i, r); const a = n.writer.remove(s.getTrimmed()); for (const t of n.writer.createRangeIn(a).getItems()) { n.mapper.unbindViewElement(t, { defer: true }) } } } function Bk(t, e) { const n = t.createAttributeElement("span", e.attributes); if (e.classes) { n._addClass(e.classes) } if (typeof e.priority === "number") { n._priority = e.priority } n._id = e.id; return n } function zk() { return (t, e, n) => { const i = e.selection; if (i.isCollapsed) { return } if (!n.consumable.consume(i, "selection")) { return } const o = []; for (const t of i.getRanges()) { o.push(n.mapper.toViewRange(t)) } n.writer.setSelection(o, { backward: i.isBackward }) } } function Pk() { return (t, e, n) => { const i = e.selection; if (!i.isCollapsed) { return } if (!n.consumable.consume(i, "selection")) { return } const o = n.writer; const r = i.getFirstPosition(); const s = n.mapper.toViewPosition(r); const a = o.breakAttributes(s); o.setSelection(a) } } function Lk() { return (t, e, n) => { const i = n.writer; const o = i.document.selection; for (const t of o.getRanges()) { if (t.isCollapsed) { if (t.end.parent.isAttached()) { n.writer.mergeAttributes(t.start) } } } i.setSelection(null) } } function Ok(t) { return (e, n, i) => { if (!i.consumable.test(n.item, e.name)) { return } const o = t(n.attributeOldValue, i, n); const r = t(n.attributeNewValue, i, n); if (!o && !r) { return } i.consumable.consume(n.item, e.name); const s = i.writer; const a = s.document.selection; if (n.item instanceof ak || n.item instanceof _k) { s.wrap(a.getFirstRange(), r) } else { let t = i.mapper.toViewRange(n.range); if (n.attributeOldValue !== null && o) { t = s.unwrap(t, o) } if (n.attributeNewValue !== null && r) { s.wrap(t, r) } } } } function Rk(t, e = bb) { return (n, i, o) => { if (!e(i.item, o.consumable, { preflight: true })) { return } const r = t(i.item, o, i); if (!r) { return } e(i.item, o.consumable); const s = o.mapper.toViewPosition(i.range.start); o.mapper.bindElements(i.item, r); o.writer.insert(s, r); o.convertAttributes(i.item); pb(r, i.item.getChildren(), o, { reconversion: i.reconversion }) } } function jk(t, e) { return (n, i, o) => { if (!e(i.item, o.consumable, { preflight: true })) { return } const r = new Map; o.writer._registerSlotFactory(fb(i.item, r, o)); const s = t(i.item, o, i); o.writer._clearSlotFactory(); if (!s) { return } gb(i.item, r, o); e(i.item, o.consumable); const a = o.mapper.toViewPosition(i.range.start); o.mapper.bindElements(i.item, s); o.writer.insert(a, s); o.convertAttributes(i.item); mb(s, r, o, { reconversion: i.reconversion }) } } function Vk(t) { return (e, n, i) => { n.isOpening = true; const o = t(n, i); n.isOpening = false; const r = t(n, i); if (!o || !r) { return } const s = n.markerRange; if (s.isCollapsed && !i.consumable.consume(s, e.name)) { return } for (const t of s) { if (!i.consumable.consume(t.item, e.name)) { return } } const a = i.mapper; const c = i.writer; c.insert(a.toViewPosition(s.start), o); i.mapper.bindElementToMarker(o, n.markerName); if (!s.isCollapsed) { c.insert(a.toViewPosition(s.end), r); i.mapper.bindElementToMarker(r, n.markerName) } e.stop() } } function Fk() { return (t, e, n) => { const i = n.mapper.markerNameToElements(e.markerName); if (!i) { return } for (const t of i) { n.mapper.unbindElementFromMarkerName(t, e.markerName); n.writer.clear(n.writer.createRangeOn(t), t) } n.writer.clearClonedElementsGroup(e.markerName); t.stop() } } function Hk(t) { return (e, n, i) => { const o = t(n.markerName, i); if (!o) { return } const r = n.markerRange; if (!i.consumable.consume(r, e.name)) { return } Uk(r, false, i, n, o); Uk(r, true, i, n, o); e.stop() } } function Uk(t, e, n, i, o) { const r = e ? t.start : t.end; const s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null; const a = r.nodeBefore && r.nodeBefore.is("element") ? r.nodeBefore : null; if (s || a) { let t; let r; if (e && s || !e && !a) { t = s; r = true } else { t = a; r = false } const c = n.mapper.toViewElement(t); if (c) { Wk(c, e, r, n, i, o); return } } const c = n.mapper.toViewPosition(r); Gk(c, e, n, i, o) } function Wk(t, e, n, i, o, r) { const s = `data-${r.group}-${e ? "start" : "end"}-${n ? "before" : "after"}`; const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : []; a.unshift(r.name); i.writer.setAttribute(s, a.join(","), t); i.mapper.bindElementToMarker(t, o.markerName) } function Gk(t, e, n, i, o) { const r = `${o.group}-${e ? "start" : "end"}`; const s = o.name ? { name: o.name } : null; const a = n.writer.createUIElement(r, s); n.writer.insert(t, a); n.mapper.bindElementToMarker(a, i.markerName) } function qk(t) { return (e, n, i) => { const o = t(n.markerName, i); if (!o) { return } const r = i.mapper.markerNameToElements(n.markerName); if (!r) { return } for (const t of r) { i.mapper.unbindElementFromMarkerName(t, n.markerName); if (t.is("containerElement")) { s(`data-${o.group}-start-before`, t); s(`data-${o.group}-start-after`, t); s(`data-${o.group}-end-before`, t); s(`data-${o.group}-end-after`, t) } else { i.writer.clear(i.writer.createRangeOn(t), t) } } i.writer.clearClonedElementsGroup(n.markerName); e.stop(); function s(t, e) { if (e.hasAttribute(t)) { const n = new Set(e.getAttribute(t).split(",")); n.delete(o.name); if (n.size == 0) { i.writer.removeAttribute(t, e) } else { i.writer.setAttribute(t, Array.from(n).join(","), e) } } } } } function Yk(t) { return (e, n, i) => { if (!i.consumable.test(n.item, e.name)) { return } const o = t(n.attributeOldValue, i, n); const r = t(n.attributeNewValue, i, n); if (!o && !r) { return } i.consumable.consume(n.item, e.name); const s = i.mapper.toViewElement(n.item); const a = i.writer; if (!s) { throw new z("conversion-attribute-to-attribute-on-text", i.dispatcher, n) } if (n.attributeOldValue !== null && o) { if (o.key == "class") { const t = tl(o.value); for (const e of t) { a.removeClass(e, s) } } else if (o.key == "style") { const t = Object.keys(o.value); for (const e of t) { a.removeStyle(e, s) } } else { a.removeAttribute(o.key, s) } } if (n.attributeNewValue !== null && r) { if (r.key == "class") { const t = tl(r.value); for (const e of t) { a.addClass(e, s) } } else if (r.key == "style") { const t = Object.keys(r.value); for (const e of t) { a.setStyle(e, r.value[e], s) } } else { a.setAttribute(r.key, r.value, s) } } } } function $k(t) { return (e, n, i) => { if (!n.item) { return } if (!(n.item instanceof ak || n.item instanceof _k) && !n.item.is("$textProxy")) { return } const o = lb(t, n, i); if (!o) { return } if (!i.consumable.consume(n.item, e.name)) { return } const r = i.writer; const s = Bk(r, o); const a = r.document.selection; if (n.item instanceof ak || n.item instanceof _k) { r.wrap(a.getFirstRange(), s) } else { const t = i.mapper.toViewRange(n.range); const e = r.wrap(t, s); for (const t of e.getItems()) { if (t.is("attributeElement") && t.isSimilar(s)) { i.mapper.bindElementToMarker(t, n.markerName); break } } } } } function Qk(t) { return (e, n, i) => { if (!n.item) { return } if (!(n.item instanceof Hp)) { return } const o = lb(t, n, i); if (!o) { return } if (!i.consumable.test(n.item, e.name)) { return } const r = i.mapper.toViewElement(n.item); if (r && r.getCustomProperty("addHighlight")) { i.consumable.consume(n.item, e.name); for (const t of Xp._createIn(n.item)) { i.consumable.consume(t.item, e.name) } const t = r.getCustomProperty("addHighlight"); t(r, o, i.writer); i.mapper.bindElementToMarker(r, n.markerName) } } } function Kk(t) { return (e, n, i) => { if (n.markerRange.isCollapsed) { return } const o = lb(t, n, i); if (!o) { return } const r = Bk(i.writer, o); const s = i.mapper.markerNameToElements(n.markerName); if (!s) { return } for (const t of s) { i.mapper.unbindElementFromMarkerName(t, n.markerName); if (t.is("attributeElement")) { i.writer.unwrap(i.writer.createRangeOn(t), r) } else { const e = t.getCustomProperty("removeHighlight"); e(t, o.id, i.writer) } } i.writer.clearClonedElementsGroup(n.markerName); e.stop() } } function Zk(t) { const e = ob(t.model); const n = rb(t.view, "container"); if (e.attributes.length) { e.children = true } return i => { i.on(`insert:${e.name}`, Rk(n, hb(e)), { priority: t.converterPriority || "normal" }); if (e.children || e.attributes.length) { i.on("reduceChanges", ub(e), { priority: "low" }) } } } function Jk(t) { const e = ob(t.model); const n = rb(t.view, "container"); e.children = true; return i => { if (i._conversionApi.schema.checkChild(e.name, "$text")) { throw new z("conversion-element-to-structure-disallowed-text", i, { elementName: e.name }) } i.on(`insert:${e.name}`, jk(n, hb(e)), { priority: t.converterPriority || "normal" }); i.on("reduceChanges", ub(e), { priority: "low" }) } } function Xk(t) { t = Ik(t); let e = t.model; if (typeof e == "string") { e = { key: e } } let n = `attribute:${e.key}`; if (e.name) { n += ":" + e.name } if (e.values) { for (const n of e.values) { t.view[n] = rb(t.view[n], "attribute") } } else { t.view = rb(t.view, "attribute") } const i = ab(t); return e => { e.on(n, Ok(i), { priority: t.converterPriority || "normal" }) } } function tb(t) { t = Ik(t); let e = t.model; if (typeof e == "string") { e = { key: e } } let n = `attribute:${e.key}`; if (e.name) { n += ":" + e.name } if (e.values) { for (const n of e.values) { t.view[n] = cb(t.view[n]) } } else { t.view = cb(t.view) } const i = ab(t); return e => { e.on(n, Yk(i), { priority: t.converterPriority || "normal" }) } } function eb(t) { const e = rb(t.view, "ui"); return n => { n.on(`addMarker:${t.model}`, Vk(e), { priority: t.converterPriority || "normal" }); n.on(`removeMarker:${t.model}`, Fk(), { priority: t.converterPriority || "normal" }) } } function nb(t) { t = Ik(t); const e = t.model; let n = t.view; if (!n) { n = n => ({ group: e, name: n.substr(t.model.length + 1) }) } return i => { i.on(`addMarker:${e}`, Hk(n), { priority: t.converterPriority || "normal" }); i.on(`removeMarker:${e}`, qk(n), { priority: t.converterPriority || "normal" }) } } function ib(t) { return e => { e.on(`addMarker:${t.model}`, $k(t.view), { priority: t.converterPriority || "normal" }); e.on(`addMarker:${t.model}`, Qk(t.view), { priority: t.converterPriority || "normal" }); e.on(`removeMarker:${t.model}`, Kk(t.view), { priority: t.converterPriority || "normal" }) } } function ob(t) { if (typeof t == "string") { t = { name: t } } if (!t.attributes) { t.attributes = [] } else if (!Array.isArray(t.attributes)) { t.attributes = [t.attributes] } t.children = !!t.children; return t } function rb(t, e) { if (typeof t == "function") { return t } return (n, i) => sb(t, i, e) } function sb(t, e, n) { if (typeof t == "string") { t = { name: t } } let i; const o = e.writer; const r = Object.assign({}, t.attributes); if (n == "container") { i = o.createContainerElement(t.name, r) } else if (n == "attribute") { const e = { priority: t.priority || $f.DEFAULT_PRIORITY }; i = o.createAttributeElement(t.name, r, e) } else { i = o.createUIElement(t.name, r) } if (t.styles) { const e = Object.keys(t.styles); for (const n of e) { o.setStyle(n, t.styles[n], i) } } if (t.classes) { const e = t.classes; if (typeof e == "string") { o.addClass(e, i) } else { for (const t of e) { o.addClass(t, i) } } } return i } function ab(t) { if (t.model.values) { return (e, n, i) => { const o = t.view[e]; if (o) { return o(e, n, i) } return null } } else { return t.view } } function cb(t) { if (typeof t == "string") { return e => ({ key: t, value: e }) } else if (typeof t == "object") { if (t.value) { return () => t } else { return e => ({ key: t.key, value: e }) } } else { return t } } function lb(t, e, n) { const i = typeof t == "function" ? t(e, n) : t; if (!i) { return null } if (!i.priority) { i.priority = 10 } if (!i.id) { i.id = e.markerName } return i } function db(t) { return (e, n) => { if (!e.is("element", t.name)) { return false } if (n.type == "attribute") { if (t.attributes.includes(n.attributeKey)) { return true } } else { if (t.children) { return true } } return false } } function ub(t) { const e = db(t); return (t, n) => { const i = []; if (!n.reconvertedElements) { n.reconvertedElements = new Set } for (const t of n.changes) { const o = t.type == "attribute" ? t.range.start.nodeAfter : t.position.parent; if (!o || !e(o, t)) { i.push(t); continue } if (!n.reconvertedElements.has(o)) { n.reconvertedElements.add(o); const t = qp._createBefore(o); let e = i.length; for (let n = i.length - 1; n >= 0; n--) { const o = i[n]; const r = o.type == "attribute" ? o.range.start : o.position; const s = r.compareWith(t); if (s == "before" || o.type == "remove" && s == "same") { break } e = n } i.splice(e, 0, { type: "remove", name: o.name, position: t, length: 1 }, { type: "reinsert", name: o.name, position: t, length: 1 }) } } n.changes = i } } function hb(t) { return (e, n, i = {}) => { const o = ["insert"]; for (const n of t.attributes) { if (e.hasAttribute(n)) { o.push(`attribute:${n}`) } } if (!o.every((t => n.test(e, t)))) { return false } if (!i.preflight) { o.forEach((t => n.consume(e, t))) } return true } } function fb(t, e, n) { return (i, o) => { const r = i.createContainerElement("$slot"); let s = null; if (o === "children") { s = Array.from(t.getChildren()) } else if (typeof o == "function") { s = Array.from(t.getChildren()).filter((t => o(t))) } else { throw new z("conversion-slot-mode-unknown", n.dispatcher, { modeOrFilter: o }) } e.set(r, s); return r } } function gb(t, e, n) { const i = Array.from(e.values()).flat(); const o = new Set(i); if (o.size != i.length) { throw new z("conversion-slot-filter-overlap", n.dispatcher, { element: t }) } if (o.size != t.childCount) { throw new z("conversion-slot-filter-incomplete", n.dispatcher, { element: t }) } } function mb(t, e, n, i) { n.mapper.on("modelToViewPosition", s, { priority: "highest" }); let o = null; let r = null; for ([o, r] of e) { pb(t, r, n, i); n.writer.move(n.writer.createRangeIn(o), n.writer.createPositionBefore(o)); n.writer.remove(o) } n.mapper.off("modelToViewPosition", s); function s(t, e) { const n = e.modelPosition.nodeAfter; const i = r.indexOf(n); if (i < 0) { return } e.viewPosition = e.mapper.findPositionIn(o, i) } } function pb(t, e, n, i) { for (const o of e) { if (!kb(t.root, o, n, i)) { n.convertItem(o) } } } function kb(t, e, n, i) { const { writer: o, mapper: r } = n; if (!i.reconversion) { return false } const s = r.toViewElement(e); if (!s || s.root == t) { return false } if (!n.canReuseView(s)) { return false } o.move(o.createRangeOn(s), r.toViewPosition(qp._createBefore(e))); return true } function bb(t, e, { preflight: n } = {}) { if (n) { return e.test(t, "insert") } else { return e.consume(t, "insert") } } function wb(t) { const { schema: e, document: n } = t.model; for (const i of n.getRootNames()) { const o = n.getRoot(i); if (o.isEmpty && !e.checkChild(o, "$text")) { if (e.checkChild(o, "paragraph")) { t.insertElement("paragraph", o); return true } } } return false } function _b(t, e, n) { const i = n.createContext(t); if (!n.checkChild(i, "paragraph")) { return false } if (!n.checkChild(i.push("paragraph"), e)) { return false } return true } function Ab(t, e) { const n = e.createElement("paragraph"); e.insert(n, t); return e.createPositionAt(n, 0) } class Cb extends yk { elementToElement(t) { return this.add(Eb(t)) } elementToAttribute(t) { return this.add(Db(t)) } attributeToAttribute(t) { return this.add(Ib(t)) } elementToMarker(t) { return this.add(Tb(t)) } dataToMarker(t) { return this.add(Mb(t)) } } function vb() { return (t, e, n) => { if (!e.modelRange && n.consumable.consume(e.viewItem, { name: true })) { const { modelRange: t, modelCursor: i } = n.convertChildren(e.viewItem, e.modelCursor); e.modelRange = t; e.modelCursor = i } } } function yb() { return (t, e, { schema: n, consumable: i, writer: o }) => { let r = e.modelCursor; if (!i.test(e.viewItem)) { return } if (!n.checkChild(r, "$text")) { if (!_b(r, "$text", n)) { return } if (e.viewItem.data.trim().length == 0) { return } const t = r.nodeBefore; r = Ab(r, o); if (t && t.is("element", "$marker")) { o.move(o.createRangeOn(t), r); r = o.createPositionAfter(t) } } i.consume(e.viewItem); const s = o.createText(e.viewItem.data); o.insert(s, r); e.modelRange = o.createRange(r, r.getShiftedBy(s.offsetSize)); e.modelCursor = e.modelRange.end } } function xb(t, e) { return (n, i) => { const o = i.newSelection; const r = []; for (const t of o.getRanges()) { r.push(e.toModelRange(t)) } const s = t.createSelection(r, { backward: o.isBackward }); if (!s.isEqual(t.document.selection)) { t.change((t => { t.setSelection(s) })) } } } function Eb(t) { t = Ik(t); const e = Bb(t); const n = Nb(t.view); const i = n ? `element:${n}` : "element"; return n => { n.on(i, e, { priority: t.converterPriority || "normal" }) } } function Db(t) { t = Ik(t); Lb(t); const e = Ob(t, false); const n = Nb(t.view); const i = n ? `element:${n}` : "element"; return n => { n.on(i, e, { priority: t.converterPriority || "low" }) } } function Ib(t) { t = Ik(t); let e = null; if (typeof t.view == "string" || t.view.key) { e = Pb(t) } Lb(t, e); const n = Ob(t, true); return e => { e.on("element", n, { priority: t.converterPriority || "low" }) } } function Tb(t) { const e = Vb(t.model); return Eb({ ...t, model: e }) } function Mb(t) { t = Ik(t); if (!t.model) { t.model = e => e ? t.view + ":" + e : t.view } const e = { view: t.view, model: t.model }; const n = Bb(Fb(e, "start")); const i = Bb(Fb(e, "end")); return o => { o.on(`element:${t.view}-start`, n, { priority: t.converterPriority || "normal" }); o.on(`element:${t.view}-end`, i, { priority: t.converterPriority || "normal" }); const r = S.get("low"); const s = S.get("highest"); const a = S.get(t.converterPriority) / s; o.on("element", Sb(e), { priority: r + a }) } } function Sb(t) { return (e, n, i) => { const o = `data-${t.view}`; if (!i.consumable.test(n.viewItem, { attributes: o + "-end-after" }) && !i.consumable.test(n.viewItem, { attributes: o + "-start-after" }) && !i.consumable.test(n.viewItem, { attributes: o + "-end-before" }) && !i.consumable.test(n.viewItem, { attributes: o + "-start-before" })) { return } if (!n.modelRange) { Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor)) } if (i.consumable.consume(n.viewItem, { attributes: o + "-end-after" })) { r(n.modelRange.end, n.viewItem.getAttribute(o + "-end-after").split(",")) } if (i.consumable.consume(n.viewItem, { attributes: o + "-start-after" })) { r(n.modelRange.end, n.viewItem.getAttribute(o + "-start-after").split(",")) } if (i.consumable.consume(n.viewItem, { attributes: o + "-end-before" })) { r(n.modelRange.start, n.viewItem.getAttribute(o + "-end-before").split(",")) } if (i.consumable.consume(n.viewItem, { attributes: o + "-start-before" })) { r(n.modelRange.start, n.viewItem.getAttribute(o + "-start-before").split(",")) } function r(e, o) { for (const r of o) { const o = t.model(r, i); const s = i.writer.createElement("$marker", { "data-name": o }); i.writer.insert(s, e); if (n.modelCursor.isEqual(e)) { n.modelCursor = n.modelCursor.getShiftedBy(1) } else { n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1) } n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0] } } } } function Nb(t) { if (typeof t == "string") { return t } if (typeof t == "object" && typeof t.name == "string") { return t.name } return null } function Bb(t) { const e = new yu(t.view); return (n, i, o) => { const r = e.match(i.viewItem); if (!r) { return } const s = r.match; s.name = true; if (!o.consumable.test(i.viewItem, s)) { return } const a = zb(t.model, i.viewItem, o); if (!a) { return } if (!o.safeInsert(a, i.modelCursor)) { return } o.consumable.consume(i.viewItem, s); o.convertChildren(i.viewItem, a); o.updateConversionResult(a, i) } } function zb(t, e, n) { if (t instanceof Function) { return t(e, n) } else { return n.writer.createElement(t) } } function Pb(t) { if (typeof t.view == "string") { t.view = { key: t.view } } const e = t.view.key; let n; if (e == "class" || e == "style") { const i = e == "class" ? "classes" : "styles"; n = { [i]: t.view.value } } else { const i = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value; n = { attributes: { [e]: i } } } if (t.view.name) { n.name = t.view.name } t.view = n; return e } function Lb(t, e = null) { const n = e === null ? true : t => t.getAttribute(e); const i = typeof t.model != "object" ? t.model : t.model.key; const o = typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value; t.model = { key: i, value: o } } function Ob(t, e) { const n = new yu(t.view); return (i, o, r) => { if (!o.modelRange && e) { return } const s = n.match(o.viewItem); if (!s) { return } if (Rb(t.view, o.viewItem)) { s.match.name = true } else { delete s.match.name } if (!r.consumable.test(o.viewItem, s.match)) { return } const a = t.model.key; const c = typeof t.model.value == "function" ? t.model.value(o.viewItem, r) : t.model.value; if (c === null) { return } if (!o.modelRange) { Object.assign(o, r.convertChildren(o.viewItem, o.modelCursor)) } const l = jb(o.modelRange, { key: a, value: c }, e, r); if (l) { if (r.consumable.test(o.viewItem, { name: true })) { s.match.name = true } r.consumable.consume(o.viewItem, s.match) } } } function Rb(t, e) { const n = typeof t == "function" ? t(e) : t; if (typeof n == "object" && !Nb(n)) { return false } return !n.classes && !n.attributes && !n.styles } function jb(t, e, n, i) { let o = false; for (const r of Array.from(t.getItems({ shallow: n }))) { if (!i.schema.checkAttribute(r, e.key)) { continue } o = true; if (r.hasAttribute(e.key)) { continue } i.writer.setAttribute(e.key, e.value, r) } return o } function Vb(t) { return (e, n) => { const i = typeof t == "string" ? t : t(e, n); return n.writer.createElement("$marker", { "data-name": i }) } } function Fb(t, e) { const n = (e, n) => { const i = e.getAttribute("name"); const o = t.model(i, n); return n.writer.createElement("$marker", { "data-name": o }) }; return { view: `${t.view}-${e}`, model: n } } function Hb(t) { t.document.registerPostFixer((e => Ub(e, t))) } function Ub(t, e) { const n = e.document.selection; const i = e.schema; const o = []; let r = false; for (const t of n.getRanges()) { const e = Wb(t, i); if (e && !e.isEqual(t)) { o.push(e); r = true } else { o.push(t) } } if (r) { t.setSelection(Qb(o), { backward: n.isBackward }) } return false } function Wb(t, e) { if (t.isCollapsed) { return Gb(t, e) } return qb(t, e) } function Gb(t, e) { const n = t.start; const i = e.getNearestSelectionRange(n); if (!i) { const t = n.getAncestors().reverse().find((t => e.isObject(t))); if (t) { return Xp._createOn(t) } return null } if (!i.isCollapsed) { return i } const o = i.start; if (n.isEqual(o)) { return null } return new Xp(o) } function qb(t, e) { const { start: n, end: i } = t; const o = e.checkChild(n, "$text"); const r = e.checkChild(i, "$text"); const s = e.getLimitElement(n); const a = e.getLimitElement(i); if (s === a) { if (o && r) { return null } if ($b(n, i, e)) { const t = n.nodeAfter && e.isSelectable(n.nodeAfter); const o = t ? null : e.getNearestSelectionRange(n, "forward"); const r = i.nodeBefore && e.isSelectable(i.nodeBefore); const s = r ? null : e.getNearestSelectionRange(i, "backward"); const a = o ? o.start : n; const c = s ? s.end : i; return new Xp(a, c) } } const c = s && !s.is("rootElement"); const l = a && !a.is("rootElement"); if (c || l) { const t = n.nodeAfter && i.nodeBefore && n.nodeAfter.parent === i.nodeBefore.parent; const o = c && (!t || !Kb(n.nodeAfter, e)); const r = l && (!t || !Kb(i.nodeBefore, e)); let d = n; let u = i; if (o) { d = qp._createBefore(Yb(s, e)) } if (r) { u = qp._createAfter(Yb(a, e)) } return new Xp(d, u) } return null } function Yb(t, e) { let n = t; let i = n; while (e.isLimit(i) && i.parent) { n = i; i = i.parent } return n } function $b(t, e, n) { const i = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text"); const o = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text"); return i || o } function Qb(t) { const e = [...t]; const n = new Set; let i = 1; while (i < e.length) { const t = e[i]; const o = e.slice(0, i); for (const [r, s] of o.entries()) { if (n.has(r)) { continue } if (t.isEqual(s)) { n.add(r) } else if (t.isIntersecting(s)) { n.add(r); n.add(i); const o = t.getJoined(s); e.push(o) } } i++ } const o = e.filter(((t, e) => !n.has(e))); return o } function Kb(t, e) { return t && e.isSelectable(t) } class Zb extends (ft()) { constructor(t, e) { super(); this.model = t; this.view = new Lp(e); this.mapper = new tk; this.downcastDispatcher = new ik({ mapper: this.mapper, schema: t.schema }); const n = this.model.document; const i = n.selection; const o = this.model.markers; this.listenTo(this.model, "_beforeChanges", (() => { this.view._disableRendering(true) }), { priority: "highest" }); this.listenTo(this.model, "_afterChanges", (() => { this.view._disableRendering(false) }), { priority: "lowest" }); this.listenTo(n, "change", (() => { this.view.change((t => { this.downcastDispatcher.convertChanges(n.differ, o, t); this.downcastDispatcher.convertSelection(i, o, t) })) }), { priority: "low" }); this.listenTo(this.view.document, "selectionChange", xb(this.model, this.mapper)); this.listenTo(this.view.document, "beforeinput", Jb(this.mapper, this.model.schema, this.view), { priority: "high" }); this.downcastDispatcher.on("insert:$text", Mk(), { priority: "lowest" }); this.downcastDispatcher.on("insert", Sk(), { priority: "lowest" }); this.downcastDispatcher.on("remove", Nk(), { priority: "low" }); this.downcastDispatcher.on("selection", Lk(), { priority: "high" }); this.downcastDispatcher.on("selection", zk(), { priority: "low" }); this.downcastDispatcher.on("selection", Pk(), { priority: "low" }); this.view.document.roots.bindTo(this.model.document.roots).using((t => { if (t.rootName == "$graveyard") { return null } const e = new Sf(this.view.document, t.name); e.rootName = t.rootName; this.mapper.bindElements(t, e); return e })) } destroy() { this.view.destroy(); this.stopListening() } reconvertMarker(t) { const e = typeof t == "string" ? t : t.name; const n = this.model.markers.get(e); if (!n) { throw new z("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: e }) } this.model.change((() => { this.model.markers._refresh(n) })) } reconvertItem(t) { this.model.change((() => { this.model.document.differ._refreshItem(t) })) } } function Jb(t, e, n) { return (i, o) => { if (n.document.isComposing && !l.isAndroid) { return } for (let n = 0; n < o.targetRanges.length; n++) { const i = o.targetRanges[n]; const r = t.toModelRange(i); const s = Wb(r, e); if (!s || s.isEqual(r)) { continue } o.targetRanges[n] = t.toViewRange(s) } } } class Xb { constructor() { this._consumables = new Map } add(t, e) { let n; if (t.is("$text") || t.is("documentFragment")) { this._consumables.set(t, true); return } if (!this._consumables.has(t)) { n = new ew(t); this._consumables.set(t, n) } else { n = this._consumables.get(t) } n.add(e) } test(t, e) { const n = this._consumables.get(t); if (n === undefined) { return null } if (t.is("$text") || t.is("documentFragment")) { return n } return n.test(e) } consume(t, e) { if (this.test(t, e)) { if (t.is("$text") || t.is("documentFragment")) { this._consumables.set(t, false) } else { this._consumables.get(t).consume(e) } return true } return false } revert(t, e) { const n = this._consumables.get(t); if (n !== undefined) { if (t.is("$text") || t.is("documentFragment")) { this._consumables.set(t, true) } else { n.revert(e) } } } static consumablesFromElement(t) { const e = { element: t, name: true, attributes: [], classes: [], styles: [] }; const n = t.getAttributeKeys(); for (const t of n) { if (t == "style" || t == "class") { continue } e.attributes.push(t) } const i = t.getClassNames(); for (const t of i) { e.classes.push(t) } const o = t.getStyleNames(); for (const t of o) { e.styles.push(t) } return e } static createFrom(t, e) { if (!e) { e = new Xb } if (t.is("$text")) { e.add(t); return e } if (t.is("element")) { e.add(t, Xb.consumablesFromElement(t)) } if (t.is("documentFragment")) { e.add(t) } for (const n of t.getChildren()) { e = Xb.createFrom(n, e) } return e } } const tw = ["attributes", "classes", "styles"]; class ew { constructor(t) { this.element = t; this._canConsumeName = null; this._consumables = { attributes: new Map, styles: new Map, classes: new Map } } add(t) { if (t.name) { this._canConsumeName = true } for (const e of tw) { if (e in t) { this._add(e, t[e]) } } } test(t) { if (t.name && !this._canConsumeName) { return this._canConsumeName } for (const e of tw) { if (e in t) { const n = this._test(e, t[e]); if (n !== true) { return n } } } return true } consume(t) { if (t.name) { this._canConsumeName = false } for (const e of tw) { if (e in t) { this._consume(e, t[e]) } } } revert(t) { if (t.name) { this._canConsumeName = true } for (const e of tw) { if (e in t) { this._revert(e, t[e]) } } } _add(t, e) { const n = Zt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { throw new z("viewconsumable-invalid-attribute", this) } i.set(e, true); if (t === "styles") { for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) { i.set(t, true) } } } } _test(t, e) { const n = Zt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { const t = e == "class" ? "classes" : "styles"; const n = this._test(t, [...this._consumables[t].keys()]); if (n !== true) { return n } } else { const t = i.get(e); if (t === undefined) { return null } if (!t) { return false } } } return true } _consume(t, e) { const n = Zt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { const t = e == "class" ? "classes" : "styles"; this._consume(t, [...this._consumables[t].keys()]) } else { i.set(e, false); if (t == "styles") { for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) { i.set(t, false) } } } } } _revert(t, e) { const n = Zt(e) ? e : [e]; const i = this._consumables[t]; for (const e of n) { if (t === "attributes" && (e === "class" || e === "style")) { const t = e == "class" ? "classes" : "styles"; this._revert(t, [...this._consumables[t].keys()]) } else { const t = i.get(e); if (t === false) { i.set(e, true) } } } } } class nw extends (ft()) { constructor() { super(); this._sourceDefinitions = {}; this._attributeProperties = {}; this.decorate("checkChild"); this.decorate("checkAttribute"); this.on("checkAttribute", ((t, e) => { e[0] = new iw(e[0]) }), { priority: "highest" }); this.on("checkChild", ((t, e) => { e[0] = new iw(e[0]); e[1] = this.getDefinition(e[1]) }), { priority: "highest" }) } register(t, e) { if (this._sourceDefinitions[t]) { throw new z("schema-cannot-register-item-twice", this, { itemName: t }) } this._sourceDefinitions[t] = [Object.assign({}, e)]; this._clearCache() } extend(t, e) { if (!this._sourceDefinitions[t]) { throw new z("schema-cannot-extend-missing-item", this, { itemName: t }) } this._sourceDefinitions[t].push(Object.assign({}, e)); this._clearCache() } getDefinitions() { if (!this._compiledDefinitions) { this._compile() } return this._compiledDefinitions } getDefinition(t) { let e; if (typeof t == "string") { e = t } else if ("is" in t && (t.is("$text") || t.is("$textProxy"))) { e = "$text" } else { e = t.name } return this.getDefinitions()[e] } isRegistered(t) { return !!this.getDefinition(t) } isBlock(t) { const e = this.getDefinition(t); return !!(e && e.isBlock) } isLimit(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isLimit || e.isObject) } isObject(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isObject || e.isLimit && e.isSelectable && e.isContent) } isInline(t) { const e = this.getDefinition(t); return !!(e && e.isInline) } isSelectable(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isSelectable || e.isObject) } isContent(t) { const e = this.getDefinition(t); if (!e) { return false } return !!(e.isContent || e.isObject) } checkChild(t, e) { if (!e) { return false } return this._checkContextMatch(e, t) } checkAttribute(t, e) { const n = this.getDefinition(t.last); if (!n) { return false } return n.allowAttributes.includes(e) } checkMerge(t, e) { if (t instanceof qp) { const e = t.nodeBefore; const n = t.nodeAfter; if (!(e instanceof Hp)) { throw new z("schema-check-merge-no-element-before", this) } if (!(n instanceof Hp)) { throw new z("schema-check-merge-no-element-after", this) } return this.checkMerge(e, n) } for (const n of e.getChildren()) { if (!this.checkChild(t, n)) { return false } } return true } addChildCheck(t) { this.on("checkChild", ((e, [n, i]) => { if (!i) { return } const o = t(n, i); if (typeof o == "boolean") { e.stop(); e.return = o } }), { priority: "high" }) } addAttributeCheck(t) { this.on("checkAttribute", ((e, [n, i]) => { const o = t(n, i); if (typeof o == "boolean") { e.stop(); e.return = o } }), { priority: "high" }) } setAttributeProperties(t, e) { this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e) } getAttributeProperties(t) { return this._attributeProperties[t] || {} } getLimitElement(t) { let e; if (t instanceof qp) { e = t.parent } else { const n = t instanceof Xp ? [t] : Array.from(t.getRanges()); e = n.reduce(((t, e) => { const n = e.getCommonAncestor(); if (!t) { return n } return t.getCommonAncestor(n, { includeSelf: true }) }), null) } while (!this.isLimit(e)) { if (e.parent) { e = e.parent } else { break } } return e } checkAttributeInSelection(t, e) { if (t.isCollapsed) { const n = t.getFirstPosition(); const i = [...n.getAncestors(), new Vp("", t.getAttributes())]; return this.checkAttribute(i, e) } else { const n = t.getRanges(); for (const t of n) { for (const n of t) { if (this.checkAttribute(n.item, e)) { return true } } } } return false } *getValidRanges(t, e) { t = _w(t); for (const n of t) { yield* this._getValidRangesForRange(n, e) } } getNearestSelectionRange(t, e = "both") { if (this.checkChild(t, "$text")) { return new Xp(t) } let n, i; const o = t.getAncestors().reverse().find((t => this.isLimit(t))) || t.root; if (e == "both" || e == "backward") { n = new Wp({ boundaries: Xp._createIn(o), startPosition: t, direction: "backward" }) } if (e == "both" || e == "forward") { i = new Wp({ boundaries: Xp._createIn(o), startPosition: t }) } for (const t of ww(n, i)) { const e = t.walker == n ? "elementEnd" : "elementStart"; const i = t.value; if (i.type == e && this.isObject(i.item)) { return Xp._createOn(i.item) } if (this.checkChild(i.nextPosition, "$text")) { return new Xp(i.nextPosition) } } return null } findAllowedParent(t, e) { let n = t.parent; while (n) { if (this.checkChild(n, e)) { return n } if (this.isLimit(n)) { return null } n = n.parent } return null } setAllowedAttributes(t, e, n) { const i = n.model; for (const [o, r] of Object.entries(e)) { if (i.schema.checkAttribute(t, o)) { n.setAttribute(o, r, t) } } } removeDisallowedAttributes(t, e) { for (const n of t) { if (n.is("$text")) { Aw(this, n, e) } else { const t = Xp._createIn(n); const i = t.getPositions(); for (const t of i) { const n = t.nodeBefore || t.parent; Aw(this, n, e) } } } } getAttributesWithProperty(t, e, n) { const i = {}; for (const [o, r] of t.getAttributes()) { const t = this.getAttributeProperties(o); if (t[e] === undefined) { continue } if (n === undefined || n === t[e]) { i[o] = r } } return i } createContext(t) { return new iw(t) } _clearCache() { this._compiledDefinitions = null } _compile() { const t = {}; const e = this._sourceDefinitions; const n = Object.keys(e); for (const i of n) { t[i] = ow(e[i], i) } for (const e of n) { rw(t, e) } for (const e of n) { sw(t, e) } for (const e of n) { aw(t, e) } for (const e of n) { cw(t, e); lw(t, e) } for (const e of n) { dw(t, e); uw(t, e); hw(t, e) } this._compiledDefinitions = t } _checkContextMatch(t, e, n = e.length - 1) { const i = e.getItem(n); if (t.allowIn.includes(i.name)) { if (n == 0) { return true } else { const t = this.getDefinition(i); return this._checkContextMatch(t, e, n - 1) } } else { return false } } *_getValidRangesForRange(t, e) { let n = t.start; let i = t.start; for (const o of t.getItems({ shallow: true })) { if (o.is("element")) { yield* this._getValidRangesForRange(Xp._createIn(o), e) } if (!this.checkAttribute(o, e)) { if (!n.isEqual(i)) { yield new Xp(n, i) } n = qp._createAfter(o) } i = qp._createAfter(o) } if (!n.isEqual(i)) { yield new Xp(n, i) } } } class iw { constructor(t) { if (t instanceof iw) { return t } let e; if (typeof t == "string") { e = [t] } else if (!Array.isArray(t)) { e = t.getAncestors({ includeSelf: true }) } else { e = t } this._items = e.map(bw) } get length() { return this._items.length } get last() { return this._items[this._items.length - 1] } [Symbol.iterator]() { return this._items[Symbol.iterator]() } push(t) { const e = new iw([t]); e._items = [...this._items, ...e._items]; return e } getItem(t) { return this._items[t] } *getNames() { yield* this._items.map((t => t.name)) } endsWith(t) { return Array.from(this.getNames()).join(" ").endsWith(t) } startsWith(t) { return Array.from(this.getNames()).join(" ").startsWith(t) } } function ow(t, e) { const n = { name: e, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] }; fw(t, n); gw(t, n, "allowIn"); gw(t, n, "allowContentOf"); gw(t, n, "allowWhere"); gw(t, n, "allowAttributes"); gw(t, n, "allowAttributesOf"); gw(t, n, "allowChildren"); gw(t, n, "inheritTypesFrom"); mw(t, n); return n } function rw(t, e) { const n = t[e]; for (const i of n.allowChildren) { const n = t[i]; if (!n) { continue } n.allowIn.push(e) } n.allowChildren.length = 0 } function sw(t, e) { for (const n of t[e].allowContentOf) { if (t[n]) { const i = pw(t, n); i.forEach((t => { t.allowIn.push(e) })) } } delete t[e].allowContentOf } function aw(t, e) { for (const n of t[e].allowWhere) { const i = t[n]; if (i) { const n = i.allowIn; t[e].allowIn.push(...n) } } delete t[e].allowWhere } function cw(t, e) { for (const n of t[e].allowAttributesOf) { const i = t[n]; if (i) { const n = i.allowAttributes; t[e].allowAttributes.push(...n) } } delete t[e].allowAttributesOf } function lw(t, e) { const n = t[e]; for (const e of n.inheritTypesFrom) { const i = t[e]; if (i) { const t = Object.keys(i).filter((t => t.startsWith("is"))); for (const e of t) { if (!(e in n)) { n[e] = i[e] } } } } delete n.inheritTypesFrom } function dw(t, e) { const n = t[e]; const i = n.allowIn.filter((e => t[e])); n.allowIn = Array.from(new Set(i)) } function uw(t, e) { const n = t[e]; for (const i of n.allowIn) { const n = t[i]; n.allowChildren.push(e) } } function hw(t, e) { const n = t[e]; n.allowAttributes = Array.from(new Set(n.allowAttributes)) } function fw(t, e) { for (const n of t) { const t = Object.keys(n).filter((t => t.startsWith("is"))); for (const i of t) { e[i] = !!n[i] } } } function gw(t, e, n) { for (const i of t) { const t = i[n]; if (typeof t == "string") { e[n].push(t) } else if (Array.isArray(t)) { e[n].push(...t) } } } function mw(t, e) { for (const n of t) { const t = n.inheritAllFrom; if (t) { e.allowContentOf.push(t); e.allowWhere.push(t); e.allowAttributesOf.push(t); e.inheritTypesFrom.push(t) } } } function pw(t, e) { const n = t[e]; return kw(t).filter((t => t.allowIn.includes(n.name))) } function kw(t) { return Object.keys(t).map((e => t[e])) } function bw(t) { if (typeof t == "string" || t.is("documentFragment")) { return { name: typeof t == "string" ? t : "$documentFragment", *getAttributeKeys() { }, getAttribute() { } } } else { return { name: t.is("element") ? t.name : "$text", *getAttributeKeys() { yield* t.getAttributeKeys() }, getAttribute(e) { return t.getAttribute(e) } } } } function* ww(t, e) { let n = false; while (!n) { n = true; if (t) { const e = t.next(); if (!e.done) { n = false; yield { walker: t, value: e.value } } } if (e) { const t = e.next(); if (!t.done) { n = false; yield { walker: e, value: t.value } } } } } function* _w(t) { for (const e of t) { yield* e.getMinimalFlatRanges() } } function Aw(t, e, n) { for (const i of e.getAttributeKeys()) { if (!t.checkAttribute(e, i)) { n.removeAttribute(i, e) } } } class Cw extends (Y()) { constructor(t) { super(); this._splitParts = new Map; this._cursorParents = new Map; this._modelCursor = null; this._emptyElementsToKeep = new Set; this.conversionApi = { ...t, consumable: null, writer: null, store: null, convertItem: (t, e) => this._convertItem(t, e), convertChildren: (t, e) => this._convertChildren(t, e), safeInsert: (t, e) => this._safeInsert(t, e), updateConversionResult: (t, e) => this._updateConversionResult(t, e), splitToAllowedParent: (t, e) => this._splitToAllowedParent(t, e), getSplitParts: t => this._getSplitParts(t), keepEmptyElement: t => this._keepEmptyElement(t) } } convert(t, e, n = ["$root"]) { this.fire("viewCleanup", t); this._modelCursor = yw(n, e); this.conversionApi.writer = e; this.conversionApi.consumable = Xb.createFrom(t); this.conversionApi.store = {}; const { modelRange: i } = this._convertItem(t, this._modelCursor); const o = e.createDocumentFragment(); if (i) { this._removeEmptyElements(); for (const t of Array.from(this._modelCursor.parent.getChildren())) { e.append(t, o) } o.markers = vw(o, e) } this._modelCursor = null; this._splitParts.clear(); this._cursorParents.clear(); this._emptyElementsToKeep.clear(); this.conversionApi.writer = null; this.conversionApi.store = null; return o } _convertItem(t, e) { const n = { viewItem: t, modelCursor: e, modelRange: null }; if (t.is("element")) { this.fire(`element:${t.name}`, n, this.conversionApi) } else if (t.is("$text")) { this.fire("text", n, this.conversionApi) } else { this.fire("documentFragment", n, this.conversionApi) } if (n.modelRange && !(n.modelRange instanceof Xp)) { throw new z("view-conversion-dispatcher-incorrect-result", this) } return { modelRange: n.modelRange, modelCursor: n.modelCursor } } _convertChildren(t, e) { let n = e.is("position") ? e : qp._createAt(e, 0); const i = new Xp(n); for (const e of Array.from(t.getChildren())) { const t = this._convertItem(e, n); if (t.modelRange instanceof Xp) { i.end = t.modelRange.end; n = t.modelCursor } } return { modelRange: i, modelCursor: n } } _safeInsert(t, e) { const n = this._splitToAllowedParent(t, e); if (!n) { return false } this.conversionApi.writer.insert(t, n.position); return true } _updateConversionResult(t, e) { const n = this._getSplitParts(t); const i = this.conversionApi.writer; if (!e.modelRange) { e.modelRange = i.createRange(i.createPositionBefore(t), i.createPositionAfter(n[n.length - 1])) } const o = this._cursorParents.get(t); if (o) { e.modelCursor = i.createPositionAt(o, 0) } else { e.modelCursor = e.modelRange.end } } _splitToAllowedParent(t, e) { const { schema: n, writer: i } = this.conversionApi; let o = n.findAllowedParent(e, t); if (o) { if (o === e.parent) { return { position: e } } if (this._modelCursor.parent.getAncestors().includes(o)) { o = null } } if (!o) { if (!_b(e, t, n)) { return null } return { position: Ab(e, i) } } const r = this.conversionApi.writer.split(e, o); const s = []; for (const t of r.range.getWalker()) { if (t.type == "elementEnd") { s.push(t.item) } else { const e = s.pop(); const n = t.item; this._registerSplitPair(e, n) } } const a = r.range.end.parent; this._cursorParents.set(t, a); return { position: r.position, cursorParent: a } } _registerSplitPair(t, e) { if (!this._splitParts.has(t)) { this._splitParts.set(t, [t]) } const n = this._splitParts.get(t); this._splitParts.set(e, n); n.push(e) } _getSplitParts(t) { let e; if (!this._splitParts.has(t)) { e = [t] } else { e = this._splitParts.get(t) } return e } _keepEmptyElement(t) { this._emptyElementsToKeep.add(t) } _removeEmptyElements() { let t = false; for (const e of this._splitParts.keys()) { if (e.isEmpty && !this._emptyElementsToKeep.has(e)) { this.conversionApi.writer.remove(e); this._splitParts.delete(e); t = true } } if (t) { this._removeEmptyElements() } } } function vw(t, e) { const n = new Set; const i = new Map; const o = Xp._createIn(t).getItems(); for (const t of o) { if (t.is("element", "$marker")) { n.add(t) } } for (const t of n) { const n = t.getAttribute("data-name"); const o = e.createPositionBefore(t); if (!i.has(n)) { i.set(n, new Xp(o.clone())) } else { i.get(n).end = o.clone() } e.remove(t) } return i } function yw(t, e) { let n; for (const i of new iw(t)) { const t = {}; for (const e of i.getAttributeKeys()) { t[e] = i.getAttribute(e) } const o = e.createElement(i.name, t); if (n) { e.insert(o, n) } n = qp._createAt(o, 0) } return n } class xw { getHtml(t) { const e = document.implementation.createHTMLDocument(""); const n = e.createElement("div"); n.appendChild(t); return n.innerHTML } } class Ew { constructor(t) { this.skipComments = true; this.domParser = new DOMParser; this.domConverter = new $g(t, { renderingMode: "data" }); this.htmlWriter = new xw } toData(t) { const e = this.domConverter.viewToDom(t); return this.htmlWriter.getHtml(e) } toView(t) { const e = this._toDom(t); return this.domConverter.domToView(e, { skipComments: this.skipComments }) } registerRawContentMatcher(t) { this.domConverter.registerRawContentMatcher(t) } useFillerType(t) { this.domConverter.blockFillerMode = t == "marked" ? "markedNbsp" : "nbsp" } _toDom(t) { if (!t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) { t = `<body>${t}</body>` } const e = this.domParser.parseFromString(t, "text/html"); const n = e.createDocumentFragment(); const i = e.body.childNodes; while (i.length > 0) { n.appendChild(i[0]) } return n } } class Dw extends (Y()) { constructor(t, e) { super(); this.model = t; this.mapper = new tk; this.downcastDispatcher = new ik({ mapper: this.mapper, schema: t.schema }); this.downcastDispatcher.on("insert:$text", Mk(), { priority: "lowest" }); this.downcastDispatcher.on("insert", Sk(), { priority: "lowest" }); this.upcastDispatcher = new Cw({ schema: t.schema }); this.viewDocument = new qf(e); this.stylesProcessor = e; this.htmlProcessor = new Ew(this.viewDocument); this.processor = this.htmlProcessor; this._viewWriter = new ag(this.viewDocument); this.upcastDispatcher.on("text", yb(), { priority: "lowest" }); this.upcastDispatcher.on("element", vb(), { priority: "lowest" }); this.upcastDispatcher.on("documentFragment", vb(), { priority: "lowest" }); ft().prototype.decorate.call(this, "init"); ft().prototype.decorate.call(this, "set"); ft().prototype.decorate.call(this, "get"); ft().prototype.decorate.call(this, "toView"); ft().prototype.decorate.call(this, "toModel"); this.on("init", (() => { this.fire("ready") }), { priority: "lowest" }); this.on("ready", (() => { this.model.enqueueChange({ isUndoable: false }, wb) }), { priority: "lowest" }) } get(t = {}) { const { rootName: e = "main", trim: n = "empty" } = t; if (!this._checkIfRootsExists([e])) { throw new z("datacontroller-get-non-existent-root", this) } const i = this.model.document.getRoot(e); if (!i.isAttached()) { P("datacontroller-get-detached-root", this) } if (n === "empty" && !this.model.hasContent(i, { ignoreWhitespaces: true })) { return "" } return this.stringify(i, t) } stringify(t, e = {}) { const n = this.toView(t, e); return this.processor.toData(n) } toView(t, e = {}) { const n = this.viewDocument; const i = this._viewWriter; this.mapper.clearBindings(); const o = Xp._createIn(t); const r = new rg(n); this.mapper.bindElements(t, r); const s = t.is("documentFragment") ? t.markers : Iw(t); this.downcastDispatcher.convert(o, s, i, e); return r } init(t) { if (this.model.document.version) { throw new z("datacontroller-init-document-not-empty", this) } let e = {}; if (typeof t === "string") { e.main = t } else { e = t } if (!this._checkIfRootsExists(Object.keys(e))) { throw new z("datacontroller-init-non-existent-root", this) } this.model.enqueueChange({ isUndoable: false }, (t => { for (const n of Object.keys(e)) { const i = this.model.document.getRoot(n); t.insert(this.parse(e[n], i), i, 0) } })); return Promise.resolve() } set(t, e = {}) { let n = {}; if (typeof t === "string") { n.main = t } else { n = t } if (!this._checkIfRootsExists(Object.keys(n))) { throw new z("datacontroller-set-non-existent-root", this) } this.model.enqueueChange(e.batchType || {}, (t => { t.setSelection(null); t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys()); for (const e of Object.keys(n)) { const i = this.model.document.getRoot(e); t.remove(t.createRangeIn(i)); t.insert(this.parse(n[e], i), i, 0) } })) } parse(t, e = "$root") { const n = this.processor.toView(t); return this.toModel(n, e) } toModel(t, e = "$root") { return this.model.change((n => this.upcastDispatcher.convert(t, n, e))) } addStyleProcessorRules(t) { t(this.stylesProcessor) } registerRawContentMatcher(t) { if (this.processor && this.processor !== this.htmlProcessor) { this.processor.registerRawContentMatcher(t) } this.htmlProcessor.registerRawContentMatcher(t) } destroy() { this.stopListening() } _checkIfRootsExists(t) { for (const e of t) { if (!this.model.document.getRoot(e)) { return false } } return true } } function Iw(t) { const e = []; const n = t.root.document; if (!n) { return new Map } const i = Xp._createIn(t); for (const t of n.model.markers) { const n = t.getRange(); const o = n.isCollapsed; const r = n.start.isEqual(i.start) || n.end.isEqual(i.end); if (o && r) { e.push([t.name, n]) } else { const o = i.getIntersection(n); if (o) { e.push([t.name, o]) } } } e.sort((([t, e], [n, i]) => { if (e.end.compareWith(i.start) !== "after") { return 1 } else if (e.start.compareWith(i.end) !== "before") { return -1 } else { switch (e.start.compareWith(i.start)) { case "before": return 1; case "after": return -1; default: switch (e.end.compareWith(i.end)) { case "before": return 1; case "after": return -1; default: return n.localeCompare(t) } } } })); return new Map(e) } class Tw { constructor(t, e) { this._helpers = new Map; this._downcast = tl(t); this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true }); this._upcast = tl(e); this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false }) } addAlias(t, e) { const n = this._downcast.includes(e); const i = this._upcast.includes(e); if (!i && !n) { throw new z("conversion-add-alias-dispatcher-not-registered", this) } this._createConversionHelpers({ name: t, dispatchers: [e], isDowncast: n }) } for(t) { if (!this._helpers.has(t)) { throw new z("conversion-for-unknown-group", this) } return this._helpers.get(t) } elementToElement(t) { this.for("downcast").elementToElement(t); for (const { model: e, view: n } of Mw(t)) { this.for("upcast").elementToElement({ model: e, view: n, converterPriority: t.converterPriority }) } } attributeToElement(t) { this.for("downcast").attributeToElement(t); for (const { model: e, view: n } of Mw(t)) { this.for("upcast").elementToAttribute({ view: n, model: e, converterPriority: t.converterPriority }) } } attributeToAttribute(t) { this.for("downcast").attributeToAttribute(t); for (const { model: e, view: n } of Mw(t)) { this.for("upcast").attributeToAttribute({ view: n, model: e }) } } _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) { if (this._helpers.has(t)) { throw new z("conversion-group-exists", this) } const i = n ? new Tk(e) : new Cb(e); this._helpers.set(t, i) } } function* Mw(t) { if (t.model.values) { for (const e of t.model.values) { const n = { key: t.model.key, value: e }; const i = t.view[e]; const o = t.upcastAlso ? t.upcastAlso[e] : undefined; yield* Sw(n, i, o) } } else { yield* Sw(t.model, t.view, t.upcastAlso) } } function* Sw(t, e, n) { yield { model: t, view: e }; if (n) { for (const e of tl(n)) { yield { model: t, view: e } } } } class Nw { constructor(t) { this.baseVersion = t; this.isDocumentOperation = this.baseVersion !== null; this.batch = null } _validate() { } toJSON() { const t = Object.assign({}, this); t.__className = this.constructor.className; delete t.batch; delete t.isDocumentOperation; return t } static get className() { return "Operation" } static fromJSON(t, e) { return new this(t.baseVersion) } } function Bw(t, e) { const n = Ow(e); const i = n.reduce(((t, e) => t + e.offsetSize), 0); const o = t.parent; jw(t); const r = t.index; o._insertChild(r, n); Rw(o, r + n.length); Rw(o, r); return new Xp(t, t.getShiftedBy(i)) } function zw(t) { if (!t.isFlat) { throw new z("operation-utils-remove-range-not-flat", this) } const e = t.start.parent; jw(t.start); jw(t.end); const n = e._removeChildren(t.start.index, t.end.index - t.start.index); Rw(e, t.start.index); return n } function Pw(t, e) { if (!t.isFlat) { throw new z("operation-utils-move-range-not-flat", this) } const n = zw(t); e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset); return Bw(e, n) } function Lw(t, e, n) { jw(t.start); jw(t.end); for (const i of t.getItems({ shallow: true })) { const t = i.is("$textProxy") ? i.textNode : i; if (n !== null) { t._setAttribute(e, n) } else { t._removeAttribute(e) } Rw(t.parent, t.index) } Rw(t.end.parent, t.end.index) } function Ow(t) { const e = []; function n(t) { if (typeof t == "string") { e.push(new Vp(t)) } else if (t instanceof Fp) { e.push(new Vp(t.data, t.getAttributes())) } else if (t instanceof Rp) { e.push(t) } else if (Dt(t)) { for (const e of t) { n(e) } } } n(t); for (let t = 1; t < e.length; t++) { const n = e[t]; const i = e[t - 1]; if (n instanceof Vp && i instanceof Vp && Vw(n, i)) { e.splice(t - 1, 2, new Vp(i.data + n.data, i.getAttributes())); t-- } } return e } function Rw(t, e) { const n = t.getChild(e - 1); const i = t.getChild(e); if (n && i && n.is("$text") && i.is("$text") && Vw(n, i)) { const o = new Vp(n.data + i.data, n.getAttributes()); t._removeChildren(e - 1, 2); t._insertChild(e - 1, o) } } function jw(t) { const e = t.textNode; const n = t.parent; if (e) { const i = t.offset - e.startOffset; const o = e.index; n._removeChildren(o, 1); const r = new Vp(e.data.substr(0, i), e.getAttributes()); const s = new Vp(e.data.substr(i), e.getAttributes()); n._insertChild(o, [r, s]) } } function Vw(t, e) { const n = t.getAttributes(); const i = e.getAttributes(); for (const t of n) { if (t[1] !== e.getAttribute(t[0])) { return false } i.next() } return i.next().done } class Fw extends Nw { constructor(t, e, n, i) { super(i); this.sourcePosition = t.clone(); this.sourcePosition.stickiness = "toNext"; this.howMany = e; this.targetPosition = n.clone(); this.targetPosition.stickiness = "toNone" } get type() { if (this.targetPosition.root.rootName == "$graveyard") { return "remove" } else if (this.sourcePosition.root.rootName == "$graveyard") { return "reinsert" } return "move" } clone() { return new Fw(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion) } getMovedRangeStart() { return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany) } getReversed() { const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany); return new Fw(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1) } _validate() { const t = this.sourcePosition.parent; const e = this.targetPosition.parent; const n = this.sourcePosition.offset; const i = this.targetPosition.offset; if (n + this.howMany > t.maxOffset) { throw new z("move-operation-nodes-do-not-exist", this) } else if (t === e && n < i && i < n + this.howMany) { throw new z("move-operation-range-into-itself", this) } else if (this.sourcePosition.root == this.targetPosition.root) { if (Et(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") { const t = this.sourcePosition.path.length - 1; if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) { throw new z("move-operation-node-into-itself", this) } } } } _execute() { Pw(Xp._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition) } toJSON() { const t = super.toJSON(); t.sourcePosition = this.sourcePosition.toJSON(); t.targetPosition = this.targetPosition.toJSON(); return t } static get className() { return "MoveOperation" } static fromJSON(t, e) { const n = qp.fromJSON(t.sourcePosition, e); const i = qp.fromJSON(t.targetPosition, e); return new this(n, t.howMany, i, t.baseVersion) } } class Hw extends Nw { constructor(t, e, n) { super(n); this.position = t.clone(); this.position.stickiness = "toNone"; this.nodes = new jp(Ow(e)); this.shouldReceiveAttributes = false } get type() { return "insert" } get howMany() { return this.nodes.maxOffset } clone() { const t = new jp([...this.nodes].map((t => t._clone(true)))); const e = new Hw(this.position, t, this.baseVersion); e.shouldReceiveAttributes = this.shouldReceiveAttributes; return e } getReversed() { const t = this.position.root.document.graveyard; const e = new qp(t, [0]); return new Fw(this.position, this.nodes.maxOffset, e, this.baseVersion + 1) } _validate() { const t = this.position.parent; if (!t || t.maxOffset < this.position.offset) { throw new z("insert-operation-position-invalid", this) } } _execute() { const t = this.nodes; this.nodes = new jp([...t].map((t => t._clone(true)))); Bw(this.position, t) } toJSON() { const t = super.toJSON(); t.position = this.position.toJSON(); t.nodes = this.nodes.toJSON(); return t } static get className() { return "InsertOperation" } static fromJSON(t, e) { const n = []; for (const e of t.nodes) { if (e.name) { n.push(Hp.fromJSON(e)) } else { n.push(Vp.fromJSON(e)) } } const i = new Hw(qp.fromJSON(t.position, e), n, t.baseVersion); i.shouldReceiveAttributes = t.shouldReceiveAttributes; return i } } class Uw extends Nw { constructor(t, e, n, i, o) { super(o); this.splitPosition = t.clone(); this.splitPosition.stickiness = "toNext"; this.howMany = e; this.insertionPosition = n; this.graveyardPosition = i ? i.clone() : null; if (this.graveyardPosition) { this.graveyardPosition.stickiness = "toNext" } } get type() { return "split" } get moveTargetPosition() { const t = this.insertionPosition.path.slice(); t.push(0); return new qp(this.insertionPosition.root, t) } get movedRange() { const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY); return new Xp(this.splitPosition, t) } clone() { return new Uw(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion) } getReversed() { const t = this.splitPosition.root.document.graveyard; const e = new qp(t, [0]); return new Ww(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1) } _validate() { const t = this.splitPosition.parent; const e = this.splitPosition.offset; if (!t || t.maxOffset < e) { throw new z("split-operation-position-invalid", this) } else if (!t.parent) { throw new z("split-operation-split-in-root", this) } else if (this.howMany != t.maxOffset - this.splitPosition.offset) { throw new z("split-operation-how-many-invalid", this) } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) { throw new z("split-operation-graveyard-position-invalid", this) } } _execute() { const t = this.splitPosition.parent; if (this.graveyardPosition) { Pw(Xp._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition) } else { const e = t._clone(); Bw(this.insertionPosition, e) } const e = new Xp(qp._createAt(t, this.splitPosition.offset), qp._createAt(t, t.maxOffset)); Pw(e, this.moveTargetPosition) } toJSON() { const t = super.toJSON(); t.splitPosition = this.splitPosition.toJSON(); t.insertionPosition = this.insertionPosition.toJSON(); if (this.graveyardPosition) { t.graveyardPosition = this.graveyardPosition.toJSON() } return t } static get className() { return "SplitOperation" } static getInsertionPosition(t) { const e = t.path.slice(0, -1); e[e.length - 1]++; return new qp(t.root, e, "toPrevious") } static fromJSON(t, e) { const n = qp.fromJSON(t.splitPosition, e); const i = qp.fromJSON(t.insertionPosition, e); const o = t.graveyardPosition ? qp.fromJSON(t.graveyardPosition, e) : null; return new this(n, t.howMany, i, o, t.baseVersion) } } class Ww extends Nw { constructor(t, e, n, i, o) { super(o); this.sourcePosition = t.clone(); this.sourcePosition.stickiness = "toPrevious"; this.howMany = e; this.targetPosition = n.clone(); this.targetPosition.stickiness = "toNext"; this.graveyardPosition = i.clone() } get type() { return "merge" } get deletionPosition() { return new qp(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1)) } get movedRange() { const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY); return new Xp(this.sourcePosition, t) } clone() { return new Ww(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion) } getReversed() { const t = this.targetPosition._getTransformedByMergeOperation(this); const e = this.sourcePosition.path.slice(0, -1); const n = new qp(this.sourcePosition.root, e)._getTransformedByMergeOperation(this); return new Uw(t, this.howMany, n, this.graveyardPosition, this.baseVersion + 1) } _validate() { const t = this.sourcePosition.parent; const e = this.targetPosition.parent; if (!t.parent) { throw new z("merge-operation-source-position-invalid", this) } else if (!e.parent) { throw new z("merge-operation-target-position-invalid", this) } else if (this.howMany != t.maxOffset) { throw new z("merge-operation-how-many-invalid", this) } } _execute() { const t = this.sourcePosition.parent; const e = Xp._createIn(t); Pw(e, this.targetPosition); Pw(Xp._createOn(t), this.graveyardPosition) } toJSON() { const t = super.toJSON(); t.sourcePosition = t.sourcePosition.toJSON(); t.targetPosition = t.targetPosition.toJSON(); t.graveyardPosition = t.graveyardPosition.toJSON(); return t } static get className() { return "MergeOperation" } static fromJSON(t, e) { const n = qp.fromJSON(t.sourcePosition, e); const i = qp.fromJSON(t.targetPosition, e); const o = qp.fromJSON(t.graveyardPosition, e); return new this(n, t.howMany, i, o, t.baseVersion) } } class Gw extends Nw { constructor(t, e, n, i, o, r) { super(r); this.name = t; this.oldRange = e ? e.clone() : null; this.newRange = n ? n.clone() : null; this.affectsData = o; this._markers = i } get type() { return "marker" } clone() { return new Gw(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion) } getReversed() { return new Gw(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1) } _execute() { if (this.newRange) { this._markers._set(this.name, this.newRange, true, this.affectsData) } else { this._markers._remove(this.name) } } toJSON() { const t = super.toJSON(); if (this.oldRange) { t.oldRange = this.oldRange.toJSON() } if (this.newRange) { t.newRange = this.newRange.toJSON() } delete t._markers; return t } static get className() { return "MarkerOperation" } static fromJSON(t, e) { return new Gw(t.name, t.oldRange ? Xp.fromJSON(t.oldRange, e) : null, t.newRange ? Xp.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion) } } function qw(t, e) { return vp(t, e) } const Yw = qw; class $w extends Nw { constructor(t, e, n, i, o) { super(o); this.range = t.clone(); this.key = e; this.oldValue = n === undefined ? null : n; this.newValue = i === undefined ? null : i } get type() { if (this.oldValue === null) { return "addAttribute" } else if (this.newValue === null) { return "removeAttribute" } else { return "changeAttribute" } } clone() { return new $w(this.range, this.key, this.oldValue, this.newValue, this.baseVersion) } getReversed() { return new $w(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1) } toJSON() { const t = super.toJSON(); t.range = this.range.toJSON(); return t } _validate() { if (!this.range.isFlat) { throw new z("attribute-operation-range-not-flat", this) } for (const t of this.range.getItems({ shallow: true })) { if (this.oldValue !== null && !Yw(t.getAttribute(this.key), this.oldValue)) { throw new z("attribute-operation-wrong-old-value", this, { item: t, key: this.key, value: this.oldValue }) } if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) { throw new z("attribute-operation-attribute-exists", this, { node: t, key: this.key }) } } } _execute() { if (!Yw(this.oldValue, this.newValue)) { Lw(this.range, this.key, this.newValue) } } static get className() { return "AttributeOperation" } static fromJSON(t, e) { return new $w(Xp.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion) } } class Qw extends Nw { get type() { return "noop" } clone() { return new Qw(this.baseVersion) } getReversed() { return new Qw(this.baseVersion + 1) } _execute() { } static get className() { return "NoOperation" } } class Kw extends Nw { constructor(t, e, n, i) { super(i); this.position = t; this.position.stickiness = "toNext"; this.oldName = e; this.newName = n } get type() { return "rename" } clone() { return new Kw(this.position.clone(), this.oldName, this.newName, this.baseVersion) } getReversed() { return new Kw(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1) } _validate() { const t = this.position.nodeAfter; if (!(t instanceof Hp)) { throw new z("rename-operation-wrong-position", this) } else if (t.name !== this.oldName) { throw new z("rename-operation-wrong-name", this) } } _execute() { const t = this.position.nodeAfter; t.name = this.newName } toJSON() { const t = super.toJSON(); t.position = this.position.toJSON(); return t } static get className() { return "RenameOperation" } static fromJSON(t, e) { return new Kw(qp.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion) } } class Zw extends Nw { constructor(t, e, n, i, o) { super(o); this.root = t; this.key = e; this.oldValue = n === undefined ? null : n; this.newValue = i === undefined ? null : i } get type() { if (this.oldValue === null) { return "addRootAttribute" } else if (this.newValue === null) { return "removeRootAttribute" } else { return "changeRootAttribute" } } clone() { return new Zw(this.root, this.key, this.oldValue, this.newValue, this.baseVersion) } getReversed() { return new Zw(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1) } _validate() { if (this.root != this.root.root || this.root.is("documentFragment")) { throw new z("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key }) } if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) { throw new z("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key }) } if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) { throw new z("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key }) } } _execute() { if (this.newValue !== null) { this.root._setAttribute(this.key, this.newValue) } else { this.root._removeAttribute(this.key) } } toJSON() { const t = super.toJSON(); t.root = this.root.toJSON(); return t } static get className() { return "RootAttributeOperation" } static fromJSON(t, e) { if (!e.getRoot(t.root)) { throw new z("rootattribute-operation-fromjson-no-root", this, { rootName: t.root }) } return new Zw(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion) } } class Jw extends Nw { constructor(t, e, n, i, o) { super(o); this.rootName = t; this.elementName = e; this.isAdd = n; this._document = i; if (!this._document.getRoot(this.rootName)) { const t = this._document.createRoot(this.elementName, this.rootName); t._isAttached = false } } get type() { return this.isAdd ? "addRoot" : "detachRoot" } clone() { return new Jw(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion) } getReversed() { return new Jw(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1) } _validate() { const t = this._document.getRoot(this.rootName); if (t.isAttached() && this.isAdd) { throw new z("root-operation-root-attached", this) } else if (!t.isAttached() && !this.isAdd) { throw new z("root-operation-root-detached", this) } } _execute() { this._document.getRoot(this.rootName)._isAttached = this.isAdd } toJSON() { const t = super.toJSON(); delete t._document; return t } static get className() { return "RootOperation" } static fromJSON(t, e) { return new Jw(t.rootName, t.elementName, t.isAdd, e, t.baseVersion) } } const Xw = {}; Xw[$w.className] = $w; Xw[Hw.className] = Hw; Xw[Gw.className] = Gw; Xw[Fw.className] = Fw; Xw[Qw.className] = Qw; Xw[Nw.className] = Nw; Xw[Kw.className] = Kw; Xw[Zw.className] = Zw; Xw[Jw.className] = Jw; Xw[Uw.className] = Uw; Xw[Ww.className] = Ww; class t_ { static fromJSON(t, e) { return Xw[t.__className].fromJSON(t, e) } } const e_ = new Map; function n_(t, e, n) { let i = e_.get(t); if (!i) { i = new Map; e_.set(t, i) } i.set(e, n) } function i_(t, e) { const n = e_.get(t); if (n && n.has(e)) { return n.get(e) } return o_ } function o_(t) { return [t] } function r_(t, e, n = {}) { const i = i_(t.constructor, e.constructor); try { t = t.clone(); return i(t, e, n) } catch (t) { throw t } } function s_(t, e, n) { t = t.slice(); e = e.slice(); const i = new a_(n.document, n.useRelations, n.forceWeakRemove); i.setOriginalOperations(t); i.setOriginalOperations(e); const o = i.originalOperations; if (t.length == 0 || e.length == 0) { return { operationsA: t, operationsB: e, originalOperations: o } } const r = new WeakMap; for (const e of t) { r.set(e, 0) } const s = { nextBaseVersionA: t[t.length - 1].baseVersion + 1, nextBaseVersionB: e[e.length - 1].baseVersion + 1, originalOperationsACount: t.length, originalOperationsBCount: e.length }; let a = 0; while (a < t.length) { const n = t[a]; const o = r.get(n); if (o == e.length) { a++; continue } const s = e[o]; const c = r_(n, s, i.getContext(n, s, true)); const l = r_(s, n, i.getContext(s, n, false)); i.updateRelation(n, s); i.setOriginalOperations(c, n); i.setOriginalOperations(l, s); for (const t of c) { r.set(t, o + l.length) } t.splice(a, 1, ...c); e.splice(o, 1, ...l) } if (n.padWithNoOps) { const n = t.length - s.originalOperationsACount; const i = e.length - s.originalOperationsBCount; l_(t, i - n); l_(e, n - i) } c_(t, s.nextBaseVersionB); c_(e, s.nextBaseVersionA); return { operationsA: t, operationsB: e, originalOperations: o } } class a_ { constructor(t, e, n = false) { this.originalOperations = new Map; this._history = t.history; this._useRelations = e; this._forceWeakRemove = !!n; this._relations = new Map } setOriginalOperations(t, e = null) { const n = e ? this.originalOperations.get(e) : null; for (const e of t) { this.originalOperations.set(e, n || e) } } updateRelation(t, e) { if (t instanceof Fw) { if (e instanceof Ww) { if (t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)) { this._setRelation(t, e, "insertAtSource") } else if (t.targetPosition.isEqual(e.deletionPosition)) { this._setRelation(t, e, "insertBetween") } else if (t.targetPosition.isAfter(e.sourcePosition)) { this._setRelation(t, e, "moveTargetAfter") } } else if (e instanceof Fw) { if (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)) { this._setRelation(t, e, "insertBefore") } else { this._setRelation(t, e, "insertAfter") } } } else if (t instanceof Uw) { if (e instanceof Ww) { if (t.splitPosition.isBefore(e.sourcePosition)) { this._setRelation(t, e, "splitBefore") } } else if (e instanceof Fw) { if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) { this._setRelation(t, e, "splitBefore") } else { const n = Xp._createFromPositionAndShift(e.sourcePosition, e.howMany); if (t.splitPosition.hasSameParentAs(e.sourcePosition) && n.containsPosition(t.splitPosition)) { const i = n.end.offset - t.splitPosition.offset; const o = t.splitPosition.offset - n.start.offset; this._setRelation(t, e, { howMany: i, offset: o }) } } } } else if (t instanceof Ww) { if (e instanceof Ww) { if (!t.targetPosition.isEqual(e.sourcePosition)) { this._setRelation(t, e, "mergeTargetNotMoved") } if (t.sourcePosition.isEqual(e.targetPosition)) { this._setRelation(t, e, "mergeSourceNotMoved") } if (t.sourcePosition.isEqual(e.sourcePosition)) { this._setRelation(t, e, "mergeSameElement") } } else if (e instanceof Uw) { if (t.sourcePosition.isEqual(e.splitPosition)) { this._setRelation(t, e, "splitAtSource") } } } else if (t instanceof Gw) { const n = t.newRange; if (!n) { return } if (e instanceof Fw) { const i = Xp._createFromPositionAndShift(e.sourcePosition, e.howMany); const o = i.containsPosition(n.start) || i.start.isEqual(n.start); const r = i.containsPosition(n.end) || i.end.isEqual(n.end); if ((o || r) && !i.containsRange(n)) { this._setRelation(t, e, { side: o ? "left" : "right", path: o ? n.start.path.slice() : n.end.path.slice() }) } } else if (e instanceof Ww) { const i = n.start.isEqual(e.targetPosition); const o = n.start.isEqual(e.deletionPosition); const r = n.end.isEqual(e.deletionPosition); const s = n.end.isEqual(e.sourcePosition); if (i || o || r || s) { this._setRelation(t, e, { wasInLeftElement: i, wasStartBeforeMergedElement: o, wasEndBeforeMergedElement: r, wasInRightElement: s }) } } } } getContext(t, e, n) { return { aIsStrong: n, aWasUndone: this._wasUndone(t), bWasUndone: this._wasUndone(e), abRelation: this._useRelations ? this._getRelation(t, e) : null, baRelation: this._useRelations ? this._getRelation(e, t) : null, forceWeakRemove: this._forceWeakRemove } } _wasUndone(t) { const e = this.originalOperations.get(t); return e.wasUndone || this._history.isUndoneOperation(e) } _getRelation(t, e) { const n = this.originalOperations.get(e); const i = this._history.getUndoneOperation(n); if (!i) { return null } const o = this.originalOperations.get(t); const r = this._relations.get(o); if (r) { return r.get(i) || null } return null } _setRelation(t, e, n) { const i = this.originalOperations.get(t); const o = this.originalOperations.get(e); let r = this._relations.get(i); if (!r) { r = new Map; this._relations.set(i, r) } r.set(o, n) } } function c_(t, e) { for (const n of t) { n.baseVersion = e++ } } function l_(t, e) { for (let n = 0; n < e; n++) { t.push(new Qw(0)) } } n_($w, $w, ((t, e, n) => { if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) { const i = t.range.getDifference(e.range).map((e => new $w(e, t.key, t.oldValue, t.newValue, 0))); const o = t.range.getIntersection(e.range); if (o) { if (n.aIsStrong) { i.push(new $w(o, e.key, e.newValue, t.newValue, 0)) } } if (i.length == 0) { return [new Qw(0)] } return i } else { return [t] } })); n_($w, Hw, ((t, e) => { if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) { const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes); const i = n.map((e => new $w(e, t.key, t.oldValue, t.newValue, t.baseVersion))); if (e.shouldReceiveAttributes) { const n = d_(e, t.key, t.oldValue); if (n) { i.unshift(n) } } return i } t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0]; return [t] })); function d_(t, e, n) { const i = t.nodes; const o = i.getNode(0).getAttribute(e); if (o == n) { return null } const r = new Xp(t.position, t.position.getShiftedBy(t.howMany)); return new $w(r, e, o, n, 0) } n_($w, Ww, ((t, e) => { const n = []; if (t.range.start.hasSameParentAs(e.deletionPosition)) { if (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) { n.push(Xp._createFromPositionAndShift(e.graveyardPosition, 1)) } } const i = t.range._getTransformedByMergeOperation(e); if (!i.isCollapsed) { n.push(i) } return n.map((e => new $w(e, t.key, t.oldValue, t.newValue, t.baseVersion))) })); n_($w, Fw, ((t, e) => { const n = u_(t.range, e); return n.map((e => new $w(e, t.key, t.oldValue, t.newValue, t.baseVersion))) })); function u_(t, e) { const n = Xp._createFromPositionAndShift(e.sourcePosition, e.howMany); let i = null; let o = []; if (n.containsRange(t, true)) { i = t } else if (t.start.hasSameParentAs(n.start)) { o = t.getDifference(n); i = t.getIntersection(n) } else { o = [t] } const r = []; for (let t of o) { t = t._getTransformedByDeletion(e.sourcePosition, e.howMany); const n = e.getMovedRangeStart(); const i = t.start.hasSameParentAs(n); const o = t._getTransformedByInsertion(n, e.howMany, i); r.push(...o) } if (i) { r.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0]) } return r } n_($w, Uw, ((t, e) => { if (t.range.end.isEqual(e.insertionPosition)) { if (!e.graveyardPosition) { t.range.end.offset++ } return [t] } if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) { const n = t.clone(); n.range = new Xp(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)); t.range.end = e.splitPosition.clone(); t.range.end.stickiness = "toPrevious"; return [t, n] } t.range = t.range._getTransformedBySplitOperation(e); return [t] })); n_(Hw, $w, ((t, e) => { const n = [t]; if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) { const i = d_(t, e.key, e.newValue); if (i) { n.push(i) } } return n })); n_(Hw, Hw, ((t, e, n) => { if (t.position.isEqual(e.position) && n.aIsStrong) { return [t] } t.position = t.position._getTransformedByInsertOperation(e); return [t] })); n_(Hw, Fw, ((t, e) => { t.position = t.position._getTransformedByMoveOperation(e); return [t] })); n_(Hw, Uw, ((t, e) => { t.position = t.position._getTransformedBySplitOperation(e); return [t] })); n_(Hw, Ww, ((t, e) => { t.position = t.position._getTransformedByMergeOperation(e); return [t] })); n_(Gw, Hw, ((t, e) => { if (t.oldRange) { t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0] } if (t.newRange) { t.newRange = t.newRange._getTransformedByInsertOperation(e)[0] } return [t] })); n_(Gw, Gw, ((t, e, n) => { if (t.name == e.name) { if (n.aIsStrong) { t.oldRange = e.newRange ? e.newRange.clone() : null } else { return [new Qw(0)] } } return [t] })); n_(Gw, Ww, ((t, e) => { if (t.oldRange) { t.oldRange = t.oldRange._getTransformedByMergeOperation(e) } if (t.newRange) { t.newRange = t.newRange._getTransformedByMergeOperation(e) } return [t] })); n_(Gw, Fw, ((t, e, n) => { if (t.oldRange) { t.oldRange = Xp._createFromRanges(t.oldRange._getTransformedByMoveOperation(e)) } if (t.newRange) { if (n.abRelation) { const i = Xp._createFromRanges(t.newRange._getTransformedByMoveOperation(e)); if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) { t.newRange.end = i.end; t.newRange.start.path = n.abRelation.path; return [t] } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) { t.newRange.start = i.start; t.newRange.end.path = n.abRelation.path; return [t] } } t.newRange = Xp._createFromRanges(t.newRange._getTransformedByMoveOperation(e)) } return [t] })); n_(Gw, Uw, ((t, e, n) => { if (t.oldRange) { t.oldRange = t.oldRange._getTransformedBySplitOperation(e) } if (t.newRange) { if (n.abRelation) { const i = t.newRange._getTransformedBySplitOperation(e); if (t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement) { t.newRange.start = qp._createAt(e.insertionPosition) } else if (t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement) { t.newRange.start = qp._createAt(e.moveTargetPosition) } if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) { t.newRange.end = qp._createAt(e.moveTargetPosition) } else if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement) { t.newRange.end = qp._createAt(e.insertionPosition) } else { t.newRange.end = i.end } return [t] } t.newRange = t.newRange._getTransformedBySplitOperation(e) } return [t] })); n_(Ww, Hw, ((t, e) => { if (t.sourcePosition.hasSameParentAs(e.position)) { t.howMany += e.howMany } t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e); t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e); return [t] })); n_(Ww, Ww, ((t, e, n) => { if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) { if (!n.bWasUndone) { return [new Qw(0)] } else { const n = e.graveyardPosition.path.slice(); n.push(0); t.sourcePosition = new qp(e.graveyardPosition.root, n); t.howMany = 0; return [t] } } if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && n.abRelation != "splitAtSource") { const i = t.targetPosition.root.rootName == "$graveyard"; const o = e.targetPosition.root.rootName == "$graveyard"; const r = i && !o; const s = o && !i; const a = s || !r && n.aIsStrong; if (a) { const n = e.targetPosition._getTransformedByMergeOperation(e); const i = t.targetPosition._getTransformedByMergeOperation(e); return [new Fw(n, t.howMany, i, 0)] } else { return [new Qw(0)] } } if (t.sourcePosition.hasSameParentAs(e.targetPosition)) { t.howMany += e.howMany } t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e); t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e); if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) { t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e) } return [t] })); n_(Ww, Fw, ((t, e, n) => { const i = Xp._createFromPositionAndShift(e.sourcePosition, e.howMany); if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) { if (t.deletionPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.sourcePosition)) { return [new Qw(0)] } } if (t.sourcePosition.hasSameParentAs(e.targetPosition)) { t.howMany += e.howMany } if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) { t.howMany -= e.howMany } t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e); t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e); if (!t.graveyardPosition.isEqual(e.targetPosition)) { t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e) } return [t] })); n_(Ww, Uw, ((t, e, n) => { if (e.graveyardPosition) { t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1); if (t.deletionPosition.isEqual(e.graveyardPosition)) { t.howMany = e.howMany } } if (t.targetPosition.isEqual(e.splitPosition)) { const i = e.howMany != 0; const o = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition); if (i || o || n.abRelation == "mergeTargetNotMoved") { t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e); return [t] } } if (t.sourcePosition.isEqual(e.splitPosition)) { if (n.abRelation == "mergeSourceNotMoved") { t.howMany = 0; t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e); return [t] } if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) { t.sourcePosition = e.moveTargetPosition.clone(); t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e); return [t] } } if (t.sourcePosition.hasSameParentAs(e.splitPosition)) { t.howMany = e.splitPosition.offset } t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e); t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e); return [t] })); n_(Fw, Hw, ((t, e) => { const n = Xp._createFromPositionAndShift(t.sourcePosition, t.howMany); const i = n._getTransformedByInsertOperation(e, false)[0]; t.sourcePosition = i.start; t.howMany = i.end.offset - i.start.offset; if (!t.targetPosition.isEqual(e.position)) { t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e) } return [t] })); n_(Fw, Fw, ((t, e, n) => { const i = Xp._createFromPositionAndShift(t.sourcePosition, t.howMany); const o = Xp._createFromPositionAndShift(e.sourcePosition, e.howMany); let r = n.aIsStrong; let s = !n.aIsStrong; if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") { s = true } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") { s = false } let a; if (t.targetPosition.isEqual(e.targetPosition) && s) { a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) } else { a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany) } if (h_(t, e) && h_(e, t)) { return [e.getReversed()] } const c = i.containsPosition(e.targetPosition); if (c && i.containsRange(o, true)) { i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); return f_([i], a) } const l = o.containsPosition(t.targetPosition); if (l && o.containsRange(i, true)) { i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart()); i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart()); return f_([i], a) } const d = Et(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath()); if (d == "prefix" || d == "extension") { i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany); return f_([i], a) } if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) { r = true } else if (t.type != "remove" && e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) { r = false } const u = []; const h = i.getDifference(o); for (const t of h) { t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany); t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany); const n = Et(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same"; const i = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n); u.push(...i) } const f = i.getIntersection(o); if (f !== null && r) { f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart()); f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart()); if (u.length === 0) { u.push(f) } else if (u.length == 1) { if (o.start.isBefore(i.start) || o.start.isEqual(i.start)) { u.unshift(f) } else { u.push(f) } } else { u.splice(1, 0, f) } } if (u.length === 0) { return [new Qw(t.baseVersion)] } return f_(u, a) })); n_(Fw, Uw, ((t, e, n) => { let i = t.targetPosition.clone(); if (!t.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || n.abRelation == "moveTargetAfter") { i = t.targetPosition._getTransformedBySplitOperation(e) } const o = Xp._createFromPositionAndShift(t.sourcePosition, t.howMany); if (o.end.isEqual(e.insertionPosition)) { if (!e.graveyardPosition) { t.howMany++ } t.targetPosition = i; return [t] } if (o.start.hasSameParentAs(e.splitPosition) && o.containsPosition(e.splitPosition)) { let t = new Xp(e.splitPosition, o.end); t = t._getTransformedBySplitOperation(e); const n = [new Xp(o.start, e.splitPosition), t]; return f_(n, i) } if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") { i = e.moveTargetPosition } if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") { i = t.targetPosition } const r = o._getTransformedBySplitOperation(e); const s = [r]; if (e.graveyardPosition) { const i = o.start.isEqual(e.graveyardPosition) || o.containsPosition(e.graveyardPosition); if (t.howMany > 1 && i && !n.aWasUndone) { s.push(Xp._createFromPositionAndShift(e.insertionPosition, 1)) } } return f_(s, i) })); n_(Fw, Ww, ((t, e, n) => { const i = Xp._createFromPositionAndShift(t.sourcePosition, t.howMany); if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.sourcePosition)) { if (t.type == "remove" && !n.forceWeakRemove) { if (!n.aWasUndone) { const n = []; let i = e.graveyardPosition.clone(); let o = e.targetPosition._getTransformedByMergeOperation(e); if (t.howMany > 1) { n.push(new Fw(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)); i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1); o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1) } const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition); const s = new Fw(i, 1, r, 0); const a = s.getMovedRangeStart().path.slice(); a.push(0); const c = new qp(s.targetPosition.root, a); o = o._getTransformedByMove(i, r, 1); const l = new Fw(o, e.howMany, c, 0); n.push(s); n.push(l); return n } } else { if (t.howMany == 1) { if (!n.bWasUndone) { return [new Qw(0)] } else { t.sourcePosition = e.graveyardPosition.clone(); t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e); return [t] } } } } const o = Xp._createFromPositionAndShift(t.sourcePosition, t.howMany); const r = o._getTransformedByMergeOperation(e); t.sourcePosition = r.start; t.howMany = r.end.offset - r.start.offset; t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e); return [t] })); n_(Kw, Hw, ((t, e) => { t.position = t.position._getTransformedByInsertOperation(e); return [t] })); n_(Kw, Ww, ((t, e) => { if (t.position.isEqual(e.deletionPosition)) { t.position = e.graveyardPosition.clone(); t.position.stickiness = "toNext"; return [t] } t.position = t.position._getTransformedByMergeOperation(e); return [t] })); n_(Kw, Fw, ((t, e) => { t.position = t.position._getTransformedByMoveOperation(e); return [t] })); n_(Kw, Kw, ((t, e, n) => { if (t.position.isEqual(e.position)) { if (n.aIsStrong) { t.oldName = e.newName } else { return [new Qw(0)] } } return [t] })); n_(Kw, Uw, ((t, e) => { const n = t.position.path; const i = e.splitPosition.getParentPath(); if (Et(n, i) == "same" && !e.graveyardPosition) { const e = new Kw(t.position.getShiftedBy(1), t.oldName, t.newName, 0); return [t, e] } t.position = t.position._getTransformedBySplitOperation(e); return [t] })); n_(Zw, Zw, ((t, e, n) => { if (t.root === e.root && t.key === e.key) { if (!n.aIsStrong || t.newValue === e.newValue) { return [new Qw(0)] } else { t.oldValue = e.newValue } } return [t] })); n_(Jw, Jw, ((t, e, n) => { if (t.rootName === e.rootName && t.isAdd === e.isAdd && !n.bWasUndone) { return [new Qw(0)] } return [t] })); n_(Uw, Hw, ((t, e) => { if (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset) { t.howMany += e.howMany } t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e); t.insertionPosition = t.insertionPosition._getTransformedByInsertOperation(e); return [t] })); n_(Uw, Ww, ((t, e, n) => { if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) { const n = e.graveyardPosition.path.slice(); n.push(0); const i = new qp(e.graveyardPosition.root, n); const o = Uw.getInsertionPosition(new qp(e.graveyardPosition.root, n)); const r = new Uw(i, 0, o, null, 0); t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e); t.insertionPosition = Uw.getInsertionPosition(t.splitPosition); t.graveyardPosition = r.insertionPosition.clone(); t.graveyardPosition.stickiness = "toNext"; return [r, t] } if (t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition)) { t.howMany-- } if (t.splitPosition.hasSameParentAs(e.targetPosition)) { t.howMany += e.howMany } t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e); t.insertionPosition = Uw.getInsertionPosition(t.splitPosition); if (t.graveyardPosition) { t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e) } return [t] })); n_(Uw, Fw, ((t, e, n) => { const i = Xp._createFromPositionAndShift(e.sourcePosition, e.howMany); if (t.graveyardPosition) { const o = i.start.isEqual(t.graveyardPosition) || i.containsPosition(t.graveyardPosition); if (!n.bWasUndone && o) { const n = t.splitPosition._getTransformedByMoveOperation(e); const i = t.graveyardPosition._getTransformedByMoveOperation(e); const o = i.path.slice(); o.push(0); const r = new qp(i.root, o); const s = new Fw(n, t.howMany, r, 0); return [s] } t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e) } const o = t.splitPosition.isEqual(e.targetPosition); if (o && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) { t.howMany += e.howMany; t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany); t.insertionPosition = Uw.getInsertionPosition(t.splitPosition); return [t] } if (o && n.abRelation && n.abRelation.howMany) { const { howMany: e, offset: i } = n.abRelation; t.howMany += e; t.splitPosition = t.splitPosition.getShiftedBy(i); return [t] } if (t.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.splitPosition)) { const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset); t.howMany -= n; if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) { t.howMany += e.howMany } t.splitPosition = e.sourcePosition.clone(); t.insertionPosition = Uw.getInsertionPosition(t.splitPosition); return [t] } if (!e.sourcePosition.isEqual(e.targetPosition)) { if (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset) { t.howMany -= e.howMany } if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) { t.howMany += e.howMany } } t.splitPosition.stickiness = "toNone"; t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e); t.splitPosition.stickiness = "toNext"; if (t.graveyardPosition) { t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e) } else { t.insertionPosition = Uw.getInsertionPosition(t.splitPosition) } return [t] })); n_(Uw, Uw, ((t, e, n) => { if (t.splitPosition.isEqual(e.splitPosition)) { if (!t.graveyardPosition && !e.graveyardPosition) { return [new Qw(0)] } if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) { return [new Qw(0)] } if (n.abRelation == "splitBefore") { t.howMany = 0; t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e); return [t] } } if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) { const i = t.splitPosition.root.rootName == "$graveyard"; const o = e.splitPosition.root.rootName == "$graveyard"; const r = i && !o; const s = o && !i; const a = s || !r && n.aIsStrong; if (a) { const n = []; if (e.howMany) { n.push(new Fw(e.moveTargetPosition, e.howMany, e.splitPosition, 0)) } if (t.howMany) { n.push(new Fw(t.splitPosition, t.howMany, t.moveTargetPosition, 0)) } return n } else { return [new Qw(0)] } } if (t.graveyardPosition) { t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e) } if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") { t.howMany++; return [t] } if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") { const n = e.insertionPosition.path.slice(); n.push(0); const i = new qp(e.insertionPosition.root, n); const o = new Fw(t.insertionPosition, 1, i, 0); return [t, o] } if (t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset) { t.howMany -= e.howMany } t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e); t.insertionPosition = Uw.getInsertionPosition(t.splitPosition); return [t] })); function h_(t, e) { return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null } function f_(t, e) { const n = []; for (let i = 0; i < t.length; i++) { const o = t[i]; const r = new Fw(o.start, o.end.offset - o.start.offset, e, 0); n.push(r); for (let e = i + 1; e < t.length; e++) { t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0] } e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany) } return n } class g_ extends (Y(qp)) { constructor(t, e, n = "toNone") { super(t, e, n); if (!this.root.is("rootElement")) { throw new z("model-liveposition-root-not-rootelement", t) } m_.call(this) } detach() { this.stopListening() } toPosition() { return new qp(this.root, this.path.slice(), this.stickiness) } static fromPosition(t, e) { return new this(t.root, t.path.slice(), e ? e : t.stickiness) } } g_.prototype.is = function (t) { return t === "livePosition" || t === "model:livePosition" || t == "position" || t === "model:position" }; function m_() { this.listenTo(this.root.document.model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation) { return } p_.call(this, n) }), { priority: "low" }) } function p_(t) { const e = this.getTransformedByOperation(t); if (!this.isEqual(e)) { const t = this.toPosition(); this.path = e.path; this.root = e.root; this.fire("change", t) } } class k_ { constructor(t = {}) { if (typeof t === "string") { t = t === "transparent" ? { isUndoable: false } : {}; P("batch-constructor-deprecated-string-type") } const { isUndoable: e = true, isLocal: n = true, isUndo: i = false, isTyping: o = false } = t; this.operations = []; this.isUndoable = e; this.isLocal = n; this.isUndo = i; this.isTyping = o } get type() { P("batch-type-deprecated"); return "default" } get baseVersion() { for (const t of this.operations) { if (t.baseVersion !== null) { return t.baseVersion } } return null } addOperation(t) { t.batch = this; this.operations.push(t); return t } } class b_ { constructor(t) { this._changesInElement = new Map; this._elementSnapshots = new Map; this._changedMarkers = new Map; this._changedRoots = new Map; this._changeCount = 0; this._cachedChanges = null; this._cachedChangesWithGraveyard = null; this._refreshedItems = new Set; this._markerCollection = t } get isEmpty() { return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0 } bufferOperation(t) { const e = t; switch (e.type) { case "insert": { if (this._isInInsertedElement(e.position.parent)) { return } this._markInsert(e.position.parent, e.position.offset, e.nodes.maxOffset); break } case "addAttribute": case "removeAttribute": case "changeAttribute": { for (const t of e.range.getItems({ shallow: true })) { if (this._isInInsertedElement(t.parent)) { continue } this._markAttribute(t) } break } case "remove": case "move": case "reinsert": { if (e.sourcePosition.isEqual(e.targetPosition) || e.sourcePosition.getShiftedBy(e.howMany).isEqual(e.targetPosition)) { return } const t = this._isInInsertedElement(e.sourcePosition.parent); const n = this._isInInsertedElement(e.targetPosition.parent); if (!t) { this._markRemove(e.sourcePosition.parent, e.sourcePosition.offset, e.howMany) } if (!n) { this._markInsert(e.targetPosition.parent, e.getMovedRangeStart().offset, e.howMany) } break } case "rename": { if (this._isInInsertedElement(e.position.parent)) { return } this._markRemove(e.position.parent, e.position.offset, 1); this._markInsert(e.position.parent, e.position.offset, 1); const t = Xp._createFromPositionAndShift(e.position, 1); for (const e of this._markerCollection.getMarkersIntersectingRange(t)) { const t = e.getData(); this.bufferMarkerChange(e.name, t, t) } break } case "split": { const t = e.splitPosition.parent; if (!this._isInInsertedElement(t)) { this._markRemove(t, e.splitPosition.offset, e.howMany) } if (!this._isInInsertedElement(e.insertionPosition.parent)) { this._markInsert(e.insertionPosition.parent, e.insertionPosition.offset, 1) } if (e.graveyardPosition) { this._markRemove(e.graveyardPosition.parent, e.graveyardPosition.offset, 1) } break } case "merge": { const t = e.sourcePosition.parent; if (!this._isInInsertedElement(t.parent)) { this._markRemove(t.parent, t.startOffset, 1) } const n = e.graveyardPosition.parent; this._markInsert(n, e.graveyardPosition.offset, 1); const i = e.targetPosition.parent; if (!this._isInInsertedElement(i)) { this._markInsert(i, e.targetPosition.offset, t.maxOffset) } break } case "detachRoot": case "addRoot": { this._bufferRootStateChange(e.rootName, e.isAdd); break } case "addRootAttribute": case "removeRootAttribute": case "changeRootAttribute": { const t = e.root.rootName; this._bufferRootAttributeChange(t, e.key, e.oldValue, e.newValue); break } }this._cachedChanges = null } bufferMarkerChange(t, e, n) { const i = this._changedMarkers.get(t); if (!i) { this._changedMarkers.set(t, { newMarkerData: n, oldMarkerData: e }) } else { i.newMarkerData = n; if (i.oldMarkerData.range == null && n.range == null) { this._changedMarkers.delete(t) } } } getMarkersToRemove() { const t = []; for (const [e, n] of this._changedMarkers) { if (n.oldMarkerData.range != null) { t.push({ name: e, range: n.oldMarkerData.range }) } } return t } getMarkersToAdd() { const t = []; for (const [e, n] of this._changedMarkers) { if (n.newMarkerData.range != null) { t.push({ name: e, range: n.newMarkerData.range }) } } return t } getChangedMarkers() { return Array.from(this._changedMarkers).map((([t, e]) => ({ name: t, data: { oldRange: e.oldMarkerData.range, newRange: e.newMarkerData.range } }))) } hasDataChanges() { if (this._changesInElement.size > 0) { return true } if (this._changedRoots.size > 0) { return true } for (const { newMarkerData: t, oldMarkerData: e } of this._changedMarkers.values()) { if (t.affectsData !== e.affectsData) { return true } if (t.affectsData) { const n = t.range && !e.range; const i = !t.range && e.range; const o = t.range && e.range && !t.range.isEqual(e.range); if (n || i || o) { return true } } } return false } getChanges(t = {}) { if (this._cachedChanges) { if (t.includeChangesInGraveyard) { return this._cachedChangesWithGraveyard.slice() } else { return this._cachedChanges.slice() } } let e = []; for (const t of this._changesInElement.keys()) { const n = this._changesInElement.get(t).sort(((t, e) => { if (t.offset === e.offset) { if (t.type != e.type) { return t.type == "remove" ? -1 : 1 } return 0 } return t.offset < e.offset ? -1 : 1 })); const i = this._elementSnapshots.get(t); const o = w_(t.getChildren()); const r = __(i.length, n); let s = 0; let a = 0; for (const n of r) { if (n === "i") { e.push(this._getInsertDiff(t, s, o[s])); s++ } else if (n === "r") { e.push(this._getRemoveDiff(t, s, i[a])); a++ } else if (n === "a") { const n = o[s].attributes; const r = i[a].attributes; let c; if (o[s].name == "$text") { c = new Xp(qp._createAt(t, s), qp._createAt(t, s + 1)) } else { const e = t.offsetToIndex(s); c = new Xp(qp._createAt(t, s), qp._createAt(t.getChild(e), 0)) } e.push(...this._getAttributesDiff(c, r, n)); s++; a++ } else { s++; a++ } } } e.sort(((t, e) => { if (t.position.root != e.position.root) { return t.position.root.rootName < e.position.root.rootName ? -1 : 1 } if (t.position.isEqual(e.position)) { return t.changeCount - e.changeCount } return t.position.isBefore(e.position) ? -1 : 1 })); for (let t = 1, n = 0; t < e.length; t++) { const i = e[n]; const o = e[t]; const r = i.type == "remove" && o.type == "remove" && i.name == "$text" && o.name == "$text" && i.position.isEqual(o.position); const s = i.type == "insert" && o.type == "insert" && i.name == "$text" && o.name == "$text" && i.position.parent == o.position.parent && i.position.offset + i.length == o.position.offset; const a = i.type == "attribute" && o.type == "attribute" && i.position.parent == o.position.parent && i.range.isFlat && o.range.isFlat && i.position.offset + i.length == o.position.offset && i.attributeKey == o.attributeKey && i.attributeOldValue == o.attributeOldValue && i.attributeNewValue == o.attributeNewValue; if (r || s || a) { i.length++; if (a) { i.range.end = i.range.end.getShiftedBy(1) } e[t] = null } else { n = t } } e = e.filter((t => t)); for (const t of e) { delete t.changeCount; if (t.type == "attribute") { delete t.position; delete t.length } } this._changeCount = 0; this._cachedChangesWithGraveyard = e; this._cachedChanges = e.filter(A_); if (t.includeChangesInGraveyard) { return this._cachedChangesWithGraveyard.slice() } else { return this._cachedChanges.slice() } } getChangedRoots() { return Array.from(this._changedRoots.values()).map((t => { const e = { ...t }; if (e.state !== undefined) { delete e.attributes } return e })) } getRefreshedItems() { return new Set(this._refreshedItems) } reset() { this._changesInElement.clear(); this._elementSnapshots.clear(); this._changedMarkers.clear(); this._changedRoots.clear(); this._refreshedItems = new Set; this._cachedChanges = null } _bufferRootStateChange(t, e) { if (!this._changedRoots.has(t)) { this._changedRoots.set(t, { name: t, state: e ? "attached" : "detached" }); return } const n = this._changedRoots.get(t); if (n.state !== undefined) { delete n.state; if (n.attributes === undefined) { this._changedRoots.delete(t) } } else { n.state = e ? "attached" : "detached" } } _bufferRootAttributeChange(t, e, n, i) { const o = this._changedRoots.get(t) || { name: t }; const r = o.attributes || {}; if (r[e]) { const t = r[e]; if (i === t.oldValue) { delete r[e] } else { t.newValue = i } } else { r[e] = { oldValue: n, newValue: i } } if (Object.entries(r).length === 0) { delete o.attributes; if (o.state === undefined) { this._changedRoots.delete(t) } } else { o.attributes = r; this._changedRoots.set(t, o) } } _refreshItem(t) { if (this._isInInsertedElement(t.parent)) { return } this._markRemove(t.parent, t.startOffset, t.offsetSize); this._markInsert(t.parent, t.startOffset, t.offsetSize); this._refreshedItems.add(t); const e = Xp._createOn(t); for (const t of this._markerCollection.getMarkersIntersectingRange(e)) { const e = t.getData(); this.bufferMarkerChange(t.name, e, e) } this._cachedChanges = null } _markInsert(t, e, n) { const i = { type: "insert", offset: e, howMany: n, count: this._changeCount++ }; this._markChange(t, i) } _markRemove(t, e, n) { const i = { type: "remove", offset: e, howMany: n, count: this._changeCount++ }; this._markChange(t, i); this._removeAllNestedChanges(t, e, n) } _markAttribute(t) { const e = { type: "attribute", offset: t.startOffset, howMany: t.offsetSize, count: this._changeCount++ }; this._markChange(t.parent, e) } _markChange(t, e) { this._makeSnapshot(t); const n = this._getChangesForElement(t); this._handleChange(e, n); n.push(e); for (let t = 0; t < n.length; t++) { if (n[t].howMany < 1) { n.splice(t, 1); t-- } } } _getChangesForElement(t) { let e; if (this._changesInElement.has(t)) { e = this._changesInElement.get(t) } else { e = []; this._changesInElement.set(t, e) } return e } _makeSnapshot(t) { if (!this._elementSnapshots.has(t)) { this._elementSnapshots.set(t, w_(t.getChildren())) } } _handleChange(t, e) { t.nodesToHandle = t.howMany; for (const n of e) { const i = t.offset + t.howMany; const o = n.offset + n.howMany; if (t.type == "insert") { if (n.type == "insert") { if (t.offset <= n.offset) { n.offset += t.howMany } else if (t.offset < o) { n.howMany += t.nodesToHandle; t.nodesToHandle = 0 } } if (n.type == "remove") { if (t.offset < n.offset) { n.offset += t.howMany } } if (n.type == "attribute") { if (t.offset <= n.offset) { n.offset += t.howMany } else if (t.offset < o) { const o = n.howMany; n.howMany = t.offset - n.offset; e.unshift({ type: "attribute", offset: i, howMany: o - n.howMany, count: this._changeCount++ }) } } } if (t.type == "remove") { if (n.type == "insert") { if (i <= n.offset) { n.offset -= t.howMany } else if (i <= o) { if (t.offset < n.offset) { const e = i - n.offset; n.offset = t.offset; n.howMany -= e; t.nodesToHandle -= e } else { n.howMany -= t.nodesToHandle; t.nodesToHandle = 0 } } else { if (t.offset <= n.offset) { t.nodesToHandle -= n.howMany; n.howMany = 0 } else if (t.offset < o) { const e = o - t.offset; n.howMany -= e; t.nodesToHandle -= e } } } if (n.type == "remove") { if (i <= n.offset) { n.offset -= t.howMany } else if (t.offset < n.offset) { t.nodesToHandle += n.howMany; n.howMany = 0 } } if (n.type == "attribute") { if (i <= n.offset) { n.offset -= t.howMany } else if (t.offset < n.offset) { const e = i - n.offset; n.offset = t.offset; n.howMany -= e } else if (t.offset < o) { if (i <= o) { const i = n.howMany; n.howMany = t.offset - n.offset; const o = i - n.howMany - t.nodesToHandle; e.unshift({ type: "attribute", offset: t.offset, howMany: o, count: this._changeCount++ }) } else { n.howMany -= o - t.offset } } } } if (t.type == "attribute") { if (n.type == "insert") { if (t.offset < n.offset && i > n.offset) { if (i > o) { const t = { type: "attribute", offset: o, howMany: i - o, count: this._changeCount++ }; this._handleChange(t, e); e.push(t) } t.nodesToHandle = n.offset - t.offset; t.howMany = t.nodesToHandle } else if (t.offset >= n.offset && t.offset < o) { if (i > o) { t.nodesToHandle = i - o; t.offset = o } else { t.nodesToHandle = 0 } } } if (n.type == "remove") { if (t.offset < n.offset && i > n.offset) { const o = { type: "attribute", offset: n.offset, howMany: i - n.offset, count: this._changeCount++ }; this._handleChange(o, e); e.push(o); t.nodesToHandle = n.offset - t.offset; t.howMany = t.nodesToHandle } } if (n.type == "attribute") { if (t.offset >= n.offset && i <= o) { t.nodesToHandle = 0; t.howMany = 0; t.offset = 0 } else if (t.offset <= n.offset && i >= o) { n.howMany = 0 } } } } t.howMany = t.nodesToHandle; delete t.nodesToHandle } _getInsertDiff(t, e, n) { return { type: "insert", position: qp._createAt(t, e), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ } } _getRemoveDiff(t, e, n) { return { type: "remove", position: qp._createAt(t, e), name: n.name, attributes: new Map(n.attributes), length: 1, changeCount: this._changeCount++ } } _getAttributesDiff(t, e, n) { const i = []; n = new Map(n); for (const [o, r] of e) { const e = n.has(o) ? n.get(o) : null; if (e !== r) { i.push({ type: "attribute", position: t.start, range: t.clone(), length: 1, attributeKey: o, attributeOldValue: r, attributeNewValue: e, changeCount: this._changeCount++ }) } n.delete(o) } for (const [e, o] of n) { i.push({ type: "attribute", position: t.start, range: t.clone(), length: 1, attributeKey: e, attributeOldValue: null, attributeNewValue: o, changeCount: this._changeCount++ }) } return i } _isInInsertedElement(t) { const e = t.parent; if (!e) { return false } const n = this._changesInElement.get(e); const i = t.startOffset; if (n) { for (const t of n) { if (t.type == "insert" && i >= t.offset && i < t.offset + t.howMany) { return true } } } return this._isInInsertedElement(e) } _removeAllNestedChanges(t, e, n) { const i = new Xp(qp._createAt(t, e), qp._createAt(t, e + n)); for (const t of i.getItems({ shallow: true })) { if (t.is("element")) { this._elementSnapshots.delete(t); this._changesInElement.delete(t); this._removeAllNestedChanges(t, 0, t.maxOffset) } } } } function w_(t) { const e = []; for (const n of t) { if (n.is("$text")) { for (let t = 0; t < n.data.length; t++) { e.push({ name: "$text", attributes: new Map(n.getAttributes()) }) } } else { e.push({ name: n.name, attributes: new Map(n.getAttributes()) }) } } return e } function __(t, e) { const n = []; let i = 0; let o = 0; for (const t of e) { if (t.offset > i) { for (let e = 0; e < t.offset - i; e++) { n.push("e") } o += t.offset - i } if (t.type == "insert") { for (let e = 0; e < t.howMany; e++) { n.push("i") } i = t.offset + t.howMany } else if (t.type == "remove") { for (let e = 0; e < t.howMany; e++) { n.push("r") } i = t.offset; o += t.howMany } else { n.push(..."a".repeat(t.howMany).split("")); i = t.offset + t.howMany; o += t.howMany } } if (o < t) { for (let e = 0; e < t - o - i; e++) { n.push("e") } } return n } function A_(t) { const e = "position" in t && t.position.root.rootName == "$graveyard"; const n = "range" in t && t.range.root.rootName == "$graveyard"; return !e && !n } class C_ { constructor() { this._operations = []; this._undoPairs = new Map; this._undoneOperations = new Set; this._baseVersionToOperationIndex = new Map; this._version = 0; this._gaps = new Map } get version() { return this._version } set version(t) { if (this._operations.length && t > this._version + 1) { this._gaps.set(this._version, t) } this._version = t } get lastOperation() { return this._operations[this._operations.length - 1] } addOperation(t) { if (t.baseVersion !== this.version) { throw new z("model-document-history-addoperation-incorrect-version", this, { operation: t, historyVersion: this.version }) } this._operations.push(t); this._version++; this._baseVersionToOperationIndex.set(t.baseVersion, this._operations.length - 1) } getOperations(t, e = this.version) { if (!this._operations.length) { return [] } const n = this._operations[0]; if (t === undefined) { t = n.baseVersion } let i = e - 1; for (const [e, n] of this._gaps) { if (t > e && t < n) { t = n } if (i > e && i < n) { i = e - 1 } } if (i < n.baseVersion || t > this.lastOperation.baseVersion) { return [] } let o = this._baseVersionToOperationIndex.get(t); if (o === undefined) { o = 0 } let r = this._baseVersionToOperationIndex.get(i); if (r === undefined) { r = this._operations.length - 1 } return this._operations.slice(o, r + 1) } getOperation(t) { const e = this._baseVersionToOperationIndex.get(t); if (e === undefined) { return } return this._operations[e] } setOperationAsUndone(t, e) { this._undoPairs.set(e, t); this._undoneOperations.add(t) } isUndoingOperation(t) { return this._undoPairs.has(t) } isUndoneOperation(t) { return this._undoneOperations.has(t) } getUndoneOperation(t) { return this._undoPairs.get(t) } reset() { this._version = 0; this._undoPairs = new Map; this._operations = []; this._undoneOperations = new Set; this._gaps = new Map; this._baseVersionToOperationIndex = new Map } } class v_ extends Hp { constructor(t, e, n = "main") { super(e); this._isAttached = true; this._document = t; this.rootName = n } get document() { return this._document } isAttached() { return this._isAttached } toJSON() { return this.rootName } } v_.prototype.is = function (t, e) { if (!e) { return t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element" || t === "node" || t === "model:node" } return e === this.name && (t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element") }; const y_ = "$graveyard"; class x_ extends (Y()) { constructor(t) { super(); this.model = t; this.history = new C_; this.selection = new _k(this); this.roots = new cl({ idProperty: "rootName" }); this.differ = new b_(t.markers); this._postFixers = new Set; this._hasSelectionChangedFromTheLastChangeBlock = false; this.createRoot("$root", y_); this.listenTo(t, "applyOperation", ((t, e) => { const n = e[0]; if (n.isDocumentOperation) { this.differ.bufferOperation(n) } }), { priority: "high" }); this.listenTo(t, "applyOperation", ((t, e) => { const n = e[0]; if (n.isDocumentOperation) { this.history.addOperation(n) } }), { priority: "low" }); this.listenTo(this.selection, "change", (() => { this._hasSelectionChangedFromTheLastChangeBlock = true })); this.listenTo(t.markers, "update", ((t, e, n, i, o) => { const r = { ...e.getData(), range: i }; this.differ.bufferMarkerChange(e.name, o, r); if (n === null) { e.on("change", ((t, n) => { const i = e.getData(); this.differ.bufferMarkerChange(e.name, { ...i, range: n }, i) })) } })); this.registerPostFixer((t => { let e = false; for (const n of this.roots) { if (!n.isAttached() && !n.isEmpty) { t.remove(t.createRangeIn(n)); e = true } } for (const n of this.model.markers) { if (!n.getRange().root.isAttached()) { t.removeMarker(n); e = true } } return e })) } get version() { return this.history.version } set version(t) { this.history.version = t } get graveyard() { return this.getRoot(y_) } createRoot(t = "$root", e = "main") { if (this.roots.get(e)) { throw new z("model-document-createroot-name-exists", this, { name: e }) } const n = new v_(this, t, e); this.roots.add(n); return n } destroy() { this.selection.destroy(); this.stopListening() } getRoot(t = "main") { return this.roots.get(t) } getRootNames(t = false) { return Array.from(this.roots).filter((e => e.rootName != y_ && (t || e.isAttached()))).map((t => t.rootName)) } registerPostFixer(t) { this._postFixers.add(t) } toJSON() { const t = _u(this); t.selection = "[engine.model.DocumentSelection]"; t.model = "[engine.model.Model]"; return t } _handleChangeBlock(t) { if (this._hasDocumentChangedFromTheLastChangeBlock()) { this._callPostFixers(t); this.selection.refresh(); if (this.differ.hasDataChanges()) { this.fire("change:data", t.batch) } else { this.fire("change", t.batch) } this.selection.refresh(); this.differ.reset() } this._hasSelectionChangedFromTheLastChangeBlock = false } _hasDocumentChangedFromTheLastChangeBlock() { return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock } _getDefaultRoot() { for (const t of this.roots) { if (t !== this.graveyard) { return t } } return this.graveyard } _getDefaultRange() { const t = this._getDefaultRoot(); const e = this.model; const n = e.schema; const i = e.createPositionFromPath(t, [0]); const o = n.getNearestSelectionRange(i); return o || e.createRange(i) } _validateSelectionRange(t) { return E_(t.start) && E_(t.end) } _callPostFixers(t) { let e = false; do { for (const n of this._postFixers) { this.selection.refresh(); e = n(t); if (e) { break } } } while (e) } } function E_(t) { const e = t.textNode; if (e) { const n = e.data; const i = t.offset - e.startOffset; return !wl(n, i) && !_l(n, i) } return true } class D_ extends (Y()) { constructor() { super(...arguments); this._markers = new Map } [Symbol.iterator]() { return this._markers.values() } has(t) { const e = t instanceof I_ ? t.name : t; return this._markers.has(e) } get(t) { return this._markers.get(t) || null } _set(t, e, n = false, i = false) { const o = t instanceof I_ ? t.name : t; if (o.includes(",")) { throw new z("markercollection-incorrect-marker-name", this) } const r = this._markers.get(o); if (r) { const t = r.getData(); const s = r.getRange(); let a = false; if (!s.isEqual(e)) { r._attachLiveRange(mk.fromRange(e)); a = true } if (n != r.managedUsingOperations) { r._managedUsingOperations = n; a = true } if (typeof i === "boolean" && i != r.affectsData) { r._affectsData = i; a = true } if (a) { this.fire(`update:${o}`, r, s, e, t) } return r } const s = mk.fromRange(e); const a = new I_(o, s, n, i); this._markers.set(o, a); this.fire(`update:${o}`, a, null, e, { ...a.getData(), range: null }); return a } _remove(t) { const e = t instanceof I_ ? t.name : t; const n = this._markers.get(e); if (n) { this._markers.delete(e); this.fire(`update:${e}`, n, n.getRange(), null, n.getData()); this._destroyMarker(n); return true } return false } _refresh(t) { const e = t instanceof I_ ? t.name : t; const n = this._markers.get(e); if (!n) { throw new z("markercollection-refresh-marker-not-exists", this) } const i = n.getRange(); this.fire(`update:${e}`, n, i, i, n.getData()) } *getMarkersAtPosition(t) { for (const e of this) { if (e.getRange().containsPosition(t)) { yield e } } } *getMarkersIntersectingRange(t) { for (const e of this) { if (e.getRange().getIntersection(t) !== null) { yield e } } } destroy() { for (const t of this._markers.values()) { this._destroyMarker(t) } this._markers = null; this.stopListening() } *getMarkersGroup(t) { for (const e of this._markers.values()) { if (e.name.startsWith(t + ":")) { yield e } } } _destroyMarker(t) { t.stopListening(); t._detachLiveRange() } } class I_ extends (Y(Op)) { constructor(t, e, n, i) { super(); this.name = t; this._liveRange = this._attachLiveRange(e); this._managedUsingOperations = n; this._affectsData = i } get managedUsingOperations() { if (!this._liveRange) { throw new z("marker-destroyed", this) } return this._managedUsingOperations } get affectsData() { if (!this._liveRange) { throw new z("marker-destroyed", this) } return this._affectsData } getData() { return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations } } getStart() { if (!this._liveRange) { throw new z("marker-destroyed", this) } return this._liveRange.start.clone() } getEnd() { if (!this._liveRange) { throw new z("marker-destroyed", this) } return this._liveRange.end.clone() } getRange() { if (!this._liveRange) { throw new z("marker-destroyed", this) } return this._liveRange.toRange() } _attachLiveRange(t) { if (this._liveRange) { this._detachLiveRange() } t.delegate("change:range").to(this); t.delegate("change:content").to(this); this._liveRange = t; return t } _detachLiveRange() { this._liveRange.stopDelegating("change:range", this); this._liveRange.stopDelegating("change:content", this); this._liveRange.detach(); this._liveRange = null } } I_.prototype.is = function (t) { return t === "marker" || t === "model:marker" }; class T_ extends Nw { constructor(t, e) { super(null); this.sourcePosition = t.clone(); this.howMany = e } get type() { return "detach" } toJSON() { const t = super.toJSON(); t.sourcePosition = this.sourcePosition.toJSON(); return t } _validate() { if (this.sourcePosition.root.document) { throw new z("detach-operation-on-document-node", this) } } _execute() { zw(Xp._createFromPositionAndShift(this.sourcePosition, this.howMany)) } static get className() { return "DetachOperation" } } class M_ extends Op { constructor(t) { super(); this.markers = new Map; this._children = new jp; if (t) { this._insertChild(0, t) } } [Symbol.iterator]() { return this.getChildren() } get childCount() { return this._children.length } get maxOffset() { return this._children.maxOffset } get isEmpty() { return this.childCount === 0 } get nextSibling() { return null } get previousSibling() { return null } get root() { return this } get parent() { return null } get document() { return null } isAttached() { return false } getAncestors() { return [] } getChild(t) { return this._children.getNode(t) } getChildren() { return this._children[Symbol.iterator]() } getChildIndex(t) { return this._children.getNodeIndex(t) } getChildStartOffset(t) { return this._children.getNodeStartOffset(t) } getPath() { return [] } getNodeByPath(t) { let e = this; for (const n of t) { e = e.getChild(e.offsetToIndex(n)) } return e } offsetToIndex(t) { return this._children.offsetToIndex(t) } toJSON() { const t = []; for (const e of this._children) { t.push(e.toJSON()) } return t } static fromJSON(t) { const e = []; for (const n of t) { if (n.name) { e.push(Hp.fromJSON(n)) } else { e.push(Vp.fromJSON(n)) } } return new M_(e) } _appendChild(t) { this._insertChild(this.childCount, t) } _insertChild(t, e) { const n = S_(e); for (const t of n) { if (t.parent !== null) { t._remove() } t.parent = this } this._children._insertNodes(t, n) } _removeChildren(t, e = 1) { const n = this._children._removeNodes(t, e); for (const t of n) { t.parent = null } return n } } M_.prototype.is = function (t) { return t === "documentFragment" || t === "model:documentFragment" }; function S_(t) { if (typeof t == "string") { return [new Vp(t)] } if (!Dt(t)) { t = [t] } return Array.from(t).map((t => { if (typeof t == "string") { return new Vp(t) } if (t instanceof Fp) { return new Vp(t.data, t.getAttributes()) } return t })) } class N_ { constructor(t, e) { this.model = t; this.batch = e } createText(t, e) { return new Vp(t, e) } createElement(t, e) { return new Hp(t, e) } createDocumentFragment() { return new M_ } cloneElement(t, e = true) { return t._clone(e) } insert(t, e, n = 0) { this._assertWriterUsedCorrectly(); if (t instanceof Vp && t.data == "") { return } const i = qp._createAt(e, n); if (t.parent) { if (O_(t.root, i.root)) { this.move(Xp._createOn(t), i); return } else { if (t.root.document) { throw new z("model-writer-insert-forbidden-move", this) } else { this.remove(t) } } } const o = i.root.document ? i.root.document.version : null; const r = new Hw(i, t, o); if (t instanceof Vp) { r.shouldReceiveAttributes = true } this.batch.addOperation(r); this.model.applyOperation(r); if (t instanceof M_) { for (const [e, n] of t.markers) { const t = qp._createAt(n.root, 0); const o = new Xp(n.start._getCombined(t, i), n.end._getCombined(t, i)); const r = { range: o, usingOperation: true, affectsData: true }; if (this.model.markers.has(e)) { this.updateMarker(e, r) } else { this.addMarker(e, r) } } } } insertText(t, e, n, i) { if (e instanceof M_ || e instanceof Hp || e instanceof qp) { this.insert(this.createText(t), e, n) } else { this.insert(this.createText(t, e), n, i) } } insertElement(t, e, n, i) { if (e instanceof M_ || e instanceof Hp || e instanceof qp) { this.insert(this.createElement(t), e, n) } else { this.insert(this.createElement(t, e), n, i) } } append(t, e) { this.insert(t, e, "end") } appendText(t, e, n) { if (e instanceof M_ || e instanceof Hp) { this.insert(this.createText(t), e, "end") } else { this.insert(this.createText(t, e), n, "end") } } appendElement(t, e, n) { if (e instanceof M_ || e instanceof Hp) { this.insert(this.createElement(t), e, "end") } else { this.insert(this.createElement(t, e), n, "end") } } setAttribute(t, e, n) { this._assertWriterUsedCorrectly(); if (n instanceof Xp) { const i = n.getMinimalFlatRanges(); for (const n of i) { B_(this, t, e, n) } } else { z_(this, t, e, n) } } setAttributes(t, e) { for (const [n, i] of fl(t)) { this.setAttribute(n, i, e) } } removeAttribute(t, e) { this._assertWriterUsedCorrectly(); if (e instanceof Xp) { const n = e.getMinimalFlatRanges(); for (const e of n) { B_(this, t, null, e) } } else { z_(this, t, null, e) } } clearAttributes(t) { this._assertWriterUsedCorrectly(); const e = t => { for (const e of t.getAttributeKeys()) { this.removeAttribute(e, t) } }; if (!(t instanceof Xp)) { e(t) } else { for (const n of t.getItems()) { e(n) } } } move(t, e, n) { this._assertWriterUsedCorrectly(); if (!(t instanceof Xp)) { throw new z("writer-move-invalid-range", this) } if (!t.isFlat) { throw new z("writer-move-range-not-flat", this) } const i = qp._createAt(e, n); if (i.isEqual(t.start)) { return } this._addOperationForAffectedMarkers("move", t); if (!O_(t.root, i.root)) { throw new z("writer-move-different-document", this) } const o = t.root.document ? t.root.document.version : null; const r = new Fw(t.start, t.end.offset - t.start.offset, i, o); this.batch.addOperation(r); this.model.applyOperation(r) } remove(t) { this._assertWriterUsedCorrectly(); const e = t instanceof Xp ? t : Xp._createOn(t); const n = e.getMinimalFlatRanges().reverse(); for (const t of n) { this._addOperationForAffectedMarkers("move", t); L_(t.start, t.end.offset - t.start.offset, this.batch, this.model) } } merge(t) { this._assertWriterUsedCorrectly(); const e = t.nodeBefore; const n = t.nodeAfter; this._addOperationForAffectedMarkers("merge", t); if (!(e instanceof Hp)) { throw new z("writer-merge-no-element-before", this) } if (!(n instanceof Hp)) { throw new z("writer-merge-no-element-after", this) } if (!t.root.document) { this._mergeDetached(t) } else { this._merge(t) } } createPositionFromPath(t, e, n) { return this.model.createPositionFromPath(t, e, n) } createPositionAt(t, e) { return this.model.createPositionAt(t, e) } createPositionAfter(t) { return this.model.createPositionAfter(t) } createPositionBefore(t) { return this.model.createPositionBefore(t) } createRange(t, e) { return this.model.createRange(t, e) } createRangeIn(t) { return this.model.createRangeIn(t) } createRangeOn(t) { return this.model.createRangeOn(t) } createSelection(...t) { return this.model.createSelection(...t) } _mergeDetached(t) { const e = t.nodeBefore; const n = t.nodeAfter; this.move(Xp._createIn(n), qp._createAt(e, "end")); this.remove(n) } _merge(t) { const e = qp._createAt(t.nodeBefore, "end"); const n = qp._createAt(t.nodeAfter, 0); const i = t.root.document.graveyard; const o = new qp(i, [0]); const r = t.root.document.version; const s = new Ww(n, t.nodeAfter.maxOffset, e, o, r); this.batch.addOperation(s); this.model.applyOperation(s) } rename(t, e) { this._assertWriterUsedCorrectly(); if (!(t instanceof Hp)) { throw new z("writer-rename-not-element-instance", this) } const n = t.root.document ? t.root.document.version : null; const i = new Kw(qp._createBefore(t), t.name, e, n); this.batch.addOperation(i); this.model.applyOperation(i) } split(t, e) { this._assertWriterUsedCorrectly(); let n = t.parent; if (!n.parent) { throw new z("writer-split-element-no-parent", this) } if (!e) { e = n.parent } if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) { throw new z("writer-split-invalid-limit-element", this) } let i; let o; do { const e = n.root.document ? n.root.document.version : null; const r = n.maxOffset - t.offset; const s = Uw.getInsertionPosition(t); const a = new Uw(t, r, s, null, e); this.batch.addOperation(a); this.model.applyOperation(a); if (!i && !o) { i = n; o = t.parent.nextSibling } t = this.createPositionAfter(t.parent); n = t.parent } while (n !== e); return { position: t, range: new Xp(qp._createAt(i, "end"), qp._createAt(o, 0)) } } wrap(t, e) { this._assertWriterUsedCorrectly(); if (!t.isFlat) { throw new z("writer-wrap-range-not-flat", this) } const n = e instanceof Hp ? e : new Hp(e); if (n.childCount > 0) { throw new z("writer-wrap-element-not-empty", this) } if (n.parent !== null) { throw new z("writer-wrap-element-attached", this) } this.insert(n, t.start); const i = new Xp(t.start.getShiftedBy(1), t.end.getShiftedBy(1)); this.move(i, qp._createAt(n, 0)) } unwrap(t) { this._assertWriterUsedCorrectly(); if (t.parent === null) { throw new z("writer-unwrap-element-no-parent", this) } this.move(Xp._createIn(t), this.createPositionAfter(t)); this.remove(t) } addMarker(t, e) { this._assertWriterUsedCorrectly(); if (!e || typeof e.usingOperation != "boolean") { throw new z("writer-addmarker-no-usingoperation", this) } const n = e.usingOperation; const i = e.range; const o = e.affectsData === undefined ? false : e.affectsData; if (this.model.markers.has(t)) { throw new z("writer-addmarker-marker-exists", this) } if (!i) { throw new z("writer-addmarker-no-range", this) } if (!n) { return this.model.markers._set(t, i, n, o) } P_(this, t, null, i, o); return this.model.markers.get(t) } updateMarker(t, e) { this._assertWriterUsedCorrectly(); const n = typeof t == "string" ? t : t.name; const i = this.model.markers.get(n); if (!i) { throw new z("writer-updatemarker-marker-not-exists", this) } if (!e) { P("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n }); this.model.markers._refresh(i); return } const o = typeof e.usingOperation == "boolean"; const r = typeof e.affectsData == "boolean"; const s = r ? e.affectsData : i.affectsData; if (!o && !e.range && !r) { throw new z("writer-updatemarker-wrong-options", this) } const a = i.getRange(); const c = e.range ? e.range : a; if (o && e.usingOperation !== i.managedUsingOperations) { if (e.usingOperation) { P_(this, n, null, c, s) } else { P_(this, n, a, null, s); this.model.markers._set(n, c, undefined, s) } return } if (i.managedUsingOperations) { P_(this, n, a, c, s) } else { this.model.markers._set(n, c, undefined, s) } } removeMarker(t) { this._assertWriterUsedCorrectly(); const e = typeof t == "string" ? t : t.name; if (!this.model.markers.has(e)) { throw new z("writer-removemarker-no-marker", this) } const n = this.model.markers.get(e); if (!n.managedUsingOperations) { this.model.markers._remove(e); return } const i = n.getRange(); P_(this, e, i, null, n.affectsData) } addRoot(t, e = "$root") { this._assertWriterUsedCorrectly(); const n = this.model.document.getRoot(t); if (n && n.isAttached()) { throw new z("writer-addroot-root-exists", this) } const i = this.model.document; const o = new Jw(t, e, true, i, i.version); this.batch.addOperation(o); this.model.applyOperation(o); return this.model.document.getRoot(t) } detachRoot(t) { this._assertWriterUsedCorrectly(); const e = typeof t == "string" ? this.model.document.getRoot(t) : t; if (!e || !e.isAttached()) { throw new z("writer-detachroot-no-root", this) } for (const t of this.model.markers) { if (t.getRange().root === e) { this.removeMarker(t) } } for (const t of e.getAttributeKeys()) { this.removeAttribute(t, e) } this.remove(this.createRangeIn(e)); const n = this.model.document; const i = new Jw(e.rootName, e.name, false, n, n.version); this.batch.addOperation(i); this.model.applyOperation(i) } setSelection(...t) { this._assertWriterUsedCorrectly(); this.model.document.selection._setTo(...t) } setSelectionFocus(t, e) { this._assertWriterUsedCorrectly(); this.model.document.selection._setFocus(t, e) } setSelectionAttribute(t, e) { this._assertWriterUsedCorrectly(); if (typeof t === "string") { this._setSelectionAttribute(t, e) } else { for (const [e, n] of fl(t)) { this._setSelectionAttribute(e, n) } } } removeSelectionAttribute(t) { this._assertWriterUsedCorrectly(); if (typeof t === "string") { this._removeSelectionAttribute(t) } else { for (const e of t) { this._removeSelectionAttribute(e) } } } overrideSelectionGravity() { return this.model.document.selection._overrideGravity() } restoreSelectionGravity(t) { this.model.document.selection._restoreGravity(t) } _setSelectionAttribute(t, e) { const n = this.model.document.selection; if (n.isCollapsed && n.anchor.parent.isEmpty) { const i = _k._getStoreAttributeKey(t); this.setAttribute(i, e, n.anchor.parent) } n._setAttribute(t, e) } _removeSelectionAttribute(t) { const e = this.model.document.selection; if (e.isCollapsed && e.anchor.parent.isEmpty) { const n = _k._getStoreAttributeKey(t); this.removeAttribute(n, e.anchor.parent) } e._removeAttribute(t) } _assertWriterUsedCorrectly() { if (this.model._currentWriter !== this) { throw new z("writer-incorrect-use", this) } } _addOperationForAffectedMarkers(t, e) { for (const n of this.model.markers) { if (!n.managedUsingOperations) { continue } const i = n.getRange(); let o = false; if (t === "move") { const t = e; o = t.containsPosition(i.start) || t.start.isEqual(i.start) || t.containsPosition(i.end) || t.end.isEqual(i.end) } else { const t = e; const n = t.nodeBefore; const r = t.nodeAfter; const s = i.start.parent == n && i.start.isAtEnd; const a = i.end.parent == r && i.end.offset == 0; const c = i.end.nodeAfter == r; const l = i.start.nodeAfter == r; o = s || a || c || l } if (o) { this.updateMarker(n.name, { range: i }) } } } } function B_(t, e, n, i) { const o = t.model; const r = o.document; let s = i.start; let a; let c; let l; for (const t of i.getWalker({ shallow: true })) { l = t.item.getAttribute(e); if (a && c != l) { if (c != n) { d() } s = a } a = t.nextPosition; c = l } if (a instanceof qp && a != s && c != n) { d() } function d() { const i = new Xp(s, a); const l = i.root.document ? r.version : null; const d = new $w(i, e, c, n, l); t.batch.addOperation(d); o.applyOperation(d) } } function z_(t, e, n, i) { const o = t.model; const r = o.document; const s = i.getAttribute(e); let a, c; if (s != n) { const l = i.root === i; if (l) { const t = i.document ? r.version : null; c = new Zw(i, e, s, n, t) } else { a = new Xp(qp._createBefore(i), t.createPositionAfter(i)); const o = a.root.document ? r.version : null; c = new $w(a, e, s, n, o) } t.batch.addOperation(c); o.applyOperation(c) } } function P_(t, e, n, i, o) { const r = t.model; const s = r.document; const a = new Gw(e, n, i, r.markers, !!o, s.version); t.batch.addOperation(a); r.applyOperation(a) } function L_(t, e, n, i) { let o; if (t.root.document) { const n = i.document; const r = new qp(n.graveyard, [0]); o = new Fw(t, e, r, n.version) } else { o = new T_(t, e) } n.addOperation(o); i.applyOperation(o) } function O_(t, e) { if (t === e) { return true } if (t instanceof v_ && e instanceof v_) { return true } return false } function R_(t, e, n = {}) { if (e.isCollapsed) { return } const i = e.getFirstRange(); if (i.root.rootName == "$graveyard") { return } const o = t.schema; t.change((t => { if (!n.doNotResetEntireContent && Z_(o, e)) { K_(t, e); return } const r = {}; if (!n.doNotAutoparagraph) { const t = e.getSelectedElement(); if (t) { Object.assign(r, o.getAttributesWithProperty(t, "copyOnReplace", true)) } } const [s, a] = j_(i); if (!s.isTouching(a)) { t.remove(t.createRange(s, a)) } if (!n.leaveUnmerged) { F_(t, s, a); o.removeDisallowedAttributes(s.parent.getChildren(), t) } J_(t, e, s); if (!n.doNotAutoparagraph && Y_(o, s)) { Q_(t, s, e, r) } s.detach(); a.detach() })) } function j_(t) { const e = t.root.document.model; const n = t.start; let i = t.end; if (e.hasContent(t, { ignoreMarkers: true })) { const n = V_(i); if (n && i.isTouching(e.createPositionAt(n, 0))) { const n = e.createSelection(t); e.modifySelection(n, { direction: "backward" }); const o = n.getLastPosition(); const r = e.createRange(o, i); if (!e.hasContent(r, { ignoreMarkers: true })) { i = o } } } return [g_.fromPosition(n, "toPrevious"), g_.fromPosition(i, "toNext")] } function V_(t) { const e = t.parent; const n = e.root.document.model.schema; const i = e.getAncestors({ parentFirst: true, includeSelf: true }); for (const t of i) { if (n.isLimit(t)) { return null } if (n.isBlock(t)) { return t } } } function F_(t, e, n) { const i = t.model; if (!G_(t.model.schema, e, n)) { return } const [o, r] = q_(e, n); if (!o || !r) { return } if (!i.hasContent(o, { ignoreMarkers: true }) && i.hasContent(r, { ignoreMarkers: true })) { U_(t, e, n, o.parent) } else { H_(t, e, n, o.parent) } } function H_(t, e, n, i) { const o = e.parent; const r = n.parent; if (o == i || r == i) { return } e = t.createPositionAfter(o); n = t.createPositionBefore(r); if (!n.isEqual(e)) { t.insert(r, e) } t.merge(e); while (n.parent.isEmpty) { const e = n.parent; n = t.createPositionBefore(e); t.remove(e) } if (!G_(t.model.schema, e, n)) { return } H_(t, e, n, i) } function U_(t, e, n, i) { const o = e.parent; const r = n.parent; if (o == i || r == i) { return } e = t.createPositionAfter(o); n = t.createPositionBefore(r); if (!n.isEqual(e)) { t.insert(o, n) } while (e.parent.isEmpty) { const n = e.parent; e = t.createPositionBefore(n); t.remove(n) } n = t.createPositionBefore(r); W_(t, n); if (!G_(t.model.schema, e, n)) { return } U_(t, e, n, i) } function W_(t, e) { const n = e.nodeBefore; const i = e.nodeAfter; if (n.name != i.name) { t.rename(n, i.name) } t.clearAttributes(n); t.setAttributes(Object.fromEntries(i.getAttributes()), n); t.merge(e) } function G_(t, e, n) { const i = e.parent; const o = n.parent; if (i == o) { return false } if (t.isLimit(i) || t.isLimit(o)) { return false } return $_(e, n, t) } function q_(t, e) { const n = t.getAncestors(); const i = e.getAncestors(); let o = 0; while (n[o] && n[o] == i[o]) { o++ } return [n[o], i[o]] } function Y_(t, e) { const n = t.checkChild(e, "$text"); const i = t.checkChild(e, "paragraph"); return !n && i } function $_(t, e, n) { const i = new Xp(t, e); for (const t of i.getWalker()) { if (n.isLimit(t.item)) { return false } } return true } function Q_(t, e, n, i = {}) { const o = t.createElement("paragraph"); t.model.schema.setAllowedAttributes(o, i, t); t.insert(o, e); J_(t, n, t.createPositionAt(o, 0)) } function K_(t, e) { const n = t.model.schema.getLimitElement(e); t.remove(t.createRangeIn(n)); Q_(t, t.createPositionAt(n, 0), e) } function Z_(t, e) { const n = t.getLimitElement(e); if (!e.containsEntireContent(n)) { return false } const i = e.getFirstRange(); if (i.start.parent == i.end.parent) { return false } return t.checkChild(n, "paragraph") } function J_(t, e, n) { if (e instanceof _k) { t.setSelection(n) } else { e.setTo(n) } } function X_(t, e) { return t.change((t => { const n = t.createDocumentFragment(); const i = e.getFirstRange(); if (!i || i.isCollapsed) { return n } const o = i.start.root; const r = i.start.getCommonPath(i.end); const s = o.getNodeByPath(r); let a; if (i.start.parent == i.end.parent) { a = i } else { a = t.createRange(t.createPositionAt(s, i.start.path[r.length]), t.createPositionAt(s, i.end.path[r.length] + 1)) } const c = a.end.offset - a.start.offset; for (const e of a.getItems({ shallow: true })) { if (e.is("$textProxy")) { t.appendText(e.data, e.getAttributes(), n) } else { t.append(t.cloneElement(e, true), n) } } if (a != i) { const e = i._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0]; const o = t.createRange(t.createPositionAt(n, 0), e.start); const r = t.createRange(e.end, t.createPositionAt(n, "end")); tA(r, t); tA(o, t) } return n })) } function tA(t, e) { const n = []; Array.from(t.getItems({ direction: "backward" })).map((t => e.createRangeOn(t))).filter((e => { const n = (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end)); return n })).forEach((t => { n.push(t.start.parent); e.remove(t) })); n.forEach((t => { let n = t; while (n.parent && n.isEmpty) { const t = e.createRangeOn(n); n = n.parent; e.remove(t) } })) } function eA(t, e, n) { return t.change((i => { const o = n ? n : t.document.selection; if (!o.isCollapsed) { t.deleteContent(o, { doNotAutoparagraph: true }) } const r = new nA(t, i, o.anchor); const s = []; let a; if (e.is("documentFragment")) { if (e.markers.size) { const t = []; for (const [n, i] of e.markers) { const { start: e, end: o } = i; const r = e.isEqual(o); t.push({ position: e, name: n, isCollapsed: r }, { position: o, name: n, isCollapsed: r }) } t.sort((({ position: t }, { position: e }) => t.isBefore(e) ? 1 : -1)); for (const { position: n, name: o, isCollapsed: r } of t) { let t = null; let a = null; const c = n.parent === e && n.isAtStart; const l = n.parent === e && n.isAtEnd; if (!c && !l) { t = i.createElement("$marker"); i.insert(t, n) } else if (r) { a = c ? "start" : "end" } s.push({ name: o, element: t, collapsed: a }) } } a = e.getChildren() } else { a = [e] } r.handleNodes(a); let c = r.getSelectionRange(); if (e.is("documentFragment") && s.length) { const t = c ? mk.fromRange(c) : null; const e = {}; for (let t = s.length - 1; t >= 0; t--) { const { name: n, element: o, collapsed: a } = s[t]; const c = !e[n]; if (c) { e[n] = [] } if (o) { const t = i.createPositionAt(o, "before"); e[n].push(t); i.remove(o) } else { const t = r.getAffectedRange(); if (!t) { if (a) { e[n].push(r.position) } continue } if (a) { e[n].push(t[a]) } else { e[n].push(c ? t.start : t.end) } } } for (const [t, [n, o]] of Object.entries(e)) { if (n && o && n.root === o.root) { i.addMarker(t, { usingOperation: true, affectsData: true, range: new Xp(n, o) }) } } if (t) { c = t.toRange(); t.detach() } } if (c) { if (o instanceof _k) { i.setSelection(c) } else { o.setTo(c) } } else { } const l = r.getAffectedRange() || t.createRange(o.anchor); r.destroy(); return l })) } class nA { constructor(t, e, n) { this._firstNode = null; this._lastNode = null; this._lastAutoParagraph = null; this._filterAttributesOf = []; this._affectedStart = null; this._affectedEnd = null; this._nodeToSelect = null; this.model = t; this.writer = e; this.position = n; this.canMergeWith = new Set([this.position.parent]); this.schema = t.schema; this._documentFragment = e.createDocumentFragment(); this._documentFragmentPosition = e.createPositionAt(this._documentFragment, 0) } handleNodes(t) { for (const e of Array.from(t)) { this._handleNode(e) } this._insertPartialFragment(); if (this._lastAutoParagraph) { this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph) } this._mergeOnRight(); this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer); this._filterAttributesOf = [] } _updateLastNodeFromAutoParagraph(t) { const e = this.writer.createPositionAfter(this._lastNode); const n = this.writer.createPositionAfter(t); if (n.isAfter(e)) { this._lastNode = t; if (this.position.parent != t || !this.position.isAtEnd) { throw new z("insertcontent-invalid-insertion-position", this) } this.position = n; this._setAffectedBoundaries(this.position) } } getSelectionRange() { if (this._nodeToSelect) { return Xp._createOn(this._nodeToSelect) } return this.model.schema.getNearestSelectionRange(this.position) } getAffectedRange() { if (!this._affectedStart) { return null } return new Xp(this._affectedStart, this._affectedEnd) } destroy() { if (this._affectedStart) { this._affectedStart.detach() } if (this._affectedEnd) { this._affectedEnd.detach() } } _handleNode(t) { if (this.schema.isObject(t)) { this._handleObject(t); return } let e = this._checkAndAutoParagraphToAllowedPosition(t); if (!e) { e = this._checkAndSplitToAllowedPosition(t); if (!e) { this._handleDisallowedNode(t); return } } this._appendToFragment(t); if (!this._firstNode) { this._firstNode = t } this._lastNode = t } _insertPartialFragment() { if (this._documentFragment.isEmpty) { return } const t = g_.fromPosition(this.position, "toNext"); this._setAffectedBoundaries(this.position); if (this._documentFragment.getChild(0) == this._firstNode) { this.writer.insert(this._firstNode, this.position); this._mergeOnLeft(); this.position = t.toPosition() } if (!this._documentFragment.isEmpty) { this.writer.insert(this._documentFragment, this.position) } this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0); this.position = t.toPosition(); t.detach() } _handleObject(t) { if (this._checkAndSplitToAllowedPosition(t)) { this._appendToFragment(t) } else { this._tryAutoparagraphing(t) } } _handleDisallowedNode(t) { if (t.is("element")) { this.handleNodes(t.getChildren()) } else { this._tryAutoparagraphing(t) } } _appendToFragment(t) { if (!this.schema.checkChild(this.position, t)) { throw new z("insertcontent-wrong-position", this, { node: t, position: this.position }) } this.writer.insert(t, this._documentFragmentPosition); this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t.offsetSize); if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) { this._nodeToSelect = t } else { this._nodeToSelect = null } this._filterAttributesOf.push(t) } _setAffectedBoundaries(t) { if (!this._affectedStart) { this._affectedStart = g_.fromPosition(t, "toPrevious") } if (!this._affectedEnd || this._affectedEnd.isBefore(t)) { if (this._affectedEnd) { this._affectedEnd.detach() } this._affectedEnd = g_.fromPosition(t, "toNext") } } _mergeOnLeft() { const t = this._firstNode; if (!(t instanceof Hp)) { return } if (!this._canMergeLeft(t)) { return } const e = g_._createBefore(t); e.stickiness = "toNext"; const n = g_.fromPosition(this.position, "toNext"); if (this._affectedStart.isEqual(e)) { this._affectedStart.detach(); this._affectedStart = g_._createAt(e.nodeBefore, "end", "toPrevious") } if (this._firstNode === this._lastNode) { this._firstNode = e.nodeBefore; this._lastNode = e.nodeBefore } this.writer.merge(e); if (e.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) { this._affectedEnd.detach(); this._affectedEnd = g_._createAt(e.nodeBefore, "end", "toNext") } this.position = n.toPosition(); n.detach(); this._filterAttributesOf.push(this.position.parent); e.detach() } _mergeOnRight() { const t = this._lastNode; if (!(t instanceof Hp)) { return } if (!this._canMergeRight(t)) { return } const e = g_._createAfter(t); e.stickiness = "toNext"; if (!this.position.isEqual(e)) { throw new z("insertcontent-invalid-insertion-position", this) } this.position = qp._createAt(e.nodeBefore, "end"); const n = g_.fromPosition(this.position, "toPrevious"); if (this._affectedEnd.isEqual(e)) { this._affectedEnd.detach(); this._affectedEnd = g_._createAt(e.nodeBefore, "end", "toNext") } if (this._firstNode === this._lastNode) { this._firstNode = e.nodeBefore; this._lastNode = e.nodeBefore } this.writer.merge(e); if (e.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) { this._affectedStart.detach(); this._affectedStart = g_._createAt(e.nodeBefore, 0, "toPrevious") } this.position = n.toPosition(); n.detach(); this._filterAttributesOf.push(this.position.parent); e.detach() } _canMergeLeft(t) { const e = t.previousSibling; return e instanceof Hp && this.canMergeWith.has(e) && this.model.schema.checkMerge(e, t) } _canMergeRight(t) { const e = t.nextSibling; return e instanceof Hp && this.canMergeWith.has(e) && this.model.schema.checkMerge(t, e) } _tryAutoparagraphing(t) { const e = this.writer.createElement("paragraph"); if (this._getAllowedIn(this.position.parent, e) && this.schema.checkChild(e, t)) { e._appendChild(t); this._handleNode(e) } } _checkAndAutoParagraphToAllowedPosition(t) { if (this.schema.checkChild(this.position.parent, t)) { return true } if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t)) { return false } this._insertPartialFragment(); const e = this.writer.createElement("paragraph"); this.writer.insert(e, this.position); this._setAffectedBoundaries(this.position); this._lastAutoParagraph = e; this.position = this.writer.createPositionAt(e, 0); return true } _checkAndSplitToAllowedPosition(t) { const e = this._getAllowedIn(this.position.parent, t); if (!e) { return false } if (e != this.position.parent) { this._insertPartialFragment() } while (e != this.position.parent) { if (this.position.isAtStart) { const t = this.position.parent; this.position = this.writer.createPositionBefore(t); if (t.isEmpty && t.parent === e) { this.writer.remove(t) } } else if (this.position.isAtEnd) { this.position = this.writer.createPositionAfter(this.position.parent) } else { const t = this.writer.createPositionAfter(this.position.parent); this._setAffectedBoundaries(this.position); this.writer.split(this.position); this.position = t; this.canMergeWith.add(this.position.nodeAfter) } } return true } _getAllowedIn(t, e) { if (this.schema.checkChild(t, e)) { return t } if (this.schema.isLimit(t)) { return null } return this._getAllowedIn(t.parent, e) } } function iA(t, e, n = "auto") { const i = t.getSelectedElement(); if (i && e.schema.isObject(i) && !e.schema.isInline(i)) { if (n == "before" || n == "after") { return e.createRange(e.createPositionAt(i, n)) } return e.createRangeOn(i) } const o = ll(t.getSelectedBlocks()); if (!o) { return e.createRange(t.focus) } if (o.isEmpty) { return e.createRange(e.createPositionAt(o, 0)) } const r = e.createPositionAfter(o); if (t.focus.isTouching(r)) { return e.createRange(r) } return e.createRange(e.createPositionBefore(o)) } function oA(t, e, n, i = {}) { if (!t.schema.isObject(e)) { throw new z("insertobject-element-not-an-object", t, { object: e }) } const o = n ? n : t.document.selection; let r = o; if (i.findOptimalPosition && t.schema.isBlock(e)) { r = t.createSelection(iA(o, t, i.findOptimalPosition)) } const s = ll(o.getSelectedBlocks()); const a = {}; if (s) { Object.assign(a, t.schema.getAttributesWithProperty(s, "copyOnReplace", true)) } return t.change((n => { if (!r.isCollapsed) { t.deleteContent(r, { doNotAutoparagraph: true }) } let o = e; const s = r.anchor.parent; if (!t.schema.checkChild(s, e) && t.schema.checkChild(s, "paragraph") && t.schema.checkChild("paragraph", e)) { o = n.createElement("paragraph"); n.insert(e, o) } t.schema.setAllowedAttributes(o, a, n); const c = t.insertContent(o, r); if (c.isCollapsed) { return c } if (i.setSelection) { rA(n, e, i.setSelection, a) } return c })) } function rA(t, e, n, i) { const o = t.model; if (n == "on") { t.setSelection(e, "on"); return } if (n != "after") { throw new z("insertobject-invalid-place-parameter-value", o) } let r = e.nextSibling; if (o.schema.isInline(e)) { t.setSelection(e, "after"); return } const s = r && o.schema.checkChild(r, "$text"); if (!s && o.schema.checkChild(e.parent, "paragraph")) { r = t.createElement("paragraph"); o.schema.setAllowedAttributes(r, i, t); o.insertContent(r, t.createPositionAfter(e)) } if (r) { t.setSelection(r, 0) } } const sA = ' ,.?!:;"-()'; function aA(t, e, n = {}) { const i = t.schema; const o = n.direction != "backward"; const r = n.unit ? n.unit : "character"; const s = !!n.treatEmojiAsSingleUnit; const a = e.focus; const c = new Wp({ boundaries: uA(a, o), singleCharacters: true, direction: o ? "forward" : "backward" }); const l = { walker: c, schema: i, isForward: o, unit: r, treatEmojiAsSingleUnit: s }; let d; while (d = c.next()) { if (d.done) { return } const n = cA(l, d.value); if (n) { if (e instanceof _k) { t.change((t => { t.setSelectionFocus(n) })) } else { e.setFocus(n) } return } } } function cA(t, e) { const { isForward: n, walker: i, unit: o, schema: r, treatEmojiAsSingleUnit: s } = t; const { type: a, item: c, nextPosition: l } = e; if (a == "text") { if (t.unit === "word") { return dA(i, n) } return lA(i, o, s) } if (a == (n ? "elementStart" : "elementEnd")) { if (r.isSelectable(c)) { return qp._createAt(c, n ? "after" : "before") } if (r.checkChild(l, "$text")) { return l } } else { if (r.isLimit(c)) { i.skip((() => true)); return } if (r.checkChild(l, "$text")) { return l } } } function lA(t, e, n) { const i = t.position.textNode; if (i) { const o = i.data; let r = t.position.offset - i.startOffset; while (wl(o, r) || e == "character" && _l(o, r) || n && Cl(o, r)) { t.next(); r = t.position.offset - i.startOffset } } return t.position } function dA(t, e) { let n = t.position.textNode; if (!n) { n = e ? t.position.nodeAfter : t.position.nodeBefore } while (n && n.is("$text")) { const i = t.position.offset - n.startOffset; if (fA(n, i, e)) { n = e ? t.position.nodeAfter : t.position.nodeBefore } else if (hA(n.data, i, e)) { break } else { t.next() } } return t.position } function uA(t, e) { const n = t.root; const i = qp._createAt(n, e ? "end" : 0); if (e) { return new Xp(t, i) } else { return new Xp(i, t) } } function hA(t, e, n) { const i = e + (n ? 0 : -1); return sA.includes(t.charAt(i)) } function fA(t, e, n) { return e === (n ? t.offsetSize : 0) } class gA extends (ft()) { constructor() { super(); this.markers = new D_; this.document = new x_(this); this.schema = new nw; this._pendingChanges = []; this._currentWriter = null;["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t => this.decorate(t))); this.on("applyOperation", ((t, e) => { const n = e[0]; n._validate() }), { priority: "highest" }); this.schema.register("$root", { isLimit: true }); this.schema.register("$container", { allowIn: ["$root", "$container"] }); this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: true }); this.schema.register("$blockObject", { allowWhere: "$block", isBlock: true, isObject: true }); this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: true, isObject: true }); this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true }); this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }); this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }); this.schema.register("$marker"); this.schema.addChildCheck(((t, e) => { if (e.name === "$marker") { return true } })); Hb(this); this.document.registerPostFixer(wb); this.on("insertContent", ((t, [e, n]) => { t.return = eA(this, e, n) })); this.on("insertObject", ((t, [e, n, i]) => { t.return = oA(this, e, n, i) })) } change(t) { try { if (this._pendingChanges.length === 0) { this._pendingChanges.push({ batch: new k_, callback: t }); return this._runPendingChanges()[0] } else { return t(this._currentWriter) } } catch (t) { z.rethrowUnexpectedError(t, this) } } enqueueChange(t, e) { try { if (!t) { t = new k_ } else if (typeof t === "function") { e = t; t = new k_ } else if (!(t instanceof k_)) { t = new k_(t) } this._pendingChanges.push({ batch: t, callback: e }); if (this._pendingChanges.length == 1) { this._runPendingChanges() } } catch (t) { z.rethrowUnexpectedError(t, this) } } applyOperation(t) { t._execute() } insertContent(t, e, n, ...i) { const o = mA(e, n); return this.fire("insertContent", [t, o, n, ...i]) } insertObject(t, e, n, i, ...o) { const r = mA(e, n); return this.fire("insertObject", [t, r, i, i, ...o]) } deleteContent(t, e) { R_(this, t, e) } modifySelection(t, e) { aA(this, t, e) } getSelectedContent(t) { return X_(this, t) } hasContent(t, e = {}) { const n = t instanceof Xp ? t : Xp._createIn(t); if (n.isCollapsed) { return false } const { ignoreWhitespaces: i = false, ignoreMarkers: o = false } = e; if (!o) { for (const t of this.markers.getMarkersIntersectingRange(n)) { if (t.affectsData) { return true } } } for (const t of n.getItems()) { if (this.schema.isContent(t)) { if (t.is("$textProxy")) { if (!i) { return true } else if (t.data.search(/\S/) !== -1) { return true } } else { return true } } } return false } createPositionFromPath(t, e, n) { return new qp(t, e, n) } createPositionAt(t, e) { return qp._createAt(t, e) } createPositionAfter(t) { return qp._createAfter(t) } createPositionBefore(t) { return qp._createBefore(t) } createRange(t, e) { return new Xp(t, e) } createRangeIn(t) { return Xp._createIn(t) } createRangeOn(t) { return Xp._createOn(t) } createSelection(...t) { return new ak(...t) } createBatch(t) { return new k_(t) } createOperationFromJSON(t) { return t_.fromJSON(t, this.document) } destroy() { this.document.destroy(); this.stopListening() } _runPendingChanges() { const t = []; this.fire("_beforeChanges"); try { while (this._pendingChanges.length) { const e = this._pendingChanges[0].batch; this._currentWriter = new N_(this, e); const n = this._pendingChanges[0].callback(this._currentWriter); t.push(n); this.document._handleChangeBlock(this._currentWriter); this._pendingChanges.shift(); this._currentWriter = null } } finally { this._pendingChanges.length = 0; this._currentWriter = null; this.fire("_afterChanges") } return t } } function mA(t, e) { if (!t) { return } if (t instanceof ak || t instanceof _k) { return t } if (t instanceof Rp) { return new ak(t, e) } return new ak(t) } class pA extends om { constructor() { super(...arguments); this.domEventType = "click" } onDomEvent(t) { this.fire(t.type, t) } } class kA extends om { constructor() { super(...arguments); this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"] } onDomEvent(t) { this.fire(t.type, t) } } class bA { constructor(t) { this.document = t } createDocumentFragment(t) { return new rg(this.document, t) } createElement(t, e, n) { return new vf(this.document, t, e, n) } createText(t) { return new Cu(this.document, t) } clone(t, e = false) { return t._clone(e) } appendChild(t, e) { return e._appendChild(t) } insertChild(t, e, n) { return n._insertChild(t, e) } removeChildren(t, e, n) { return n._removeChildren(t, e) } remove(t) { const e = t.parent; if (e) { return this.removeChildren(e.getChildIndex(t), 1, e) } return [] } replace(t, e) { const n = t.parent; if (n) { const i = n.getChildIndex(t); this.removeChildren(i, 1, n); this.insertChild(i, e, n); return true } return false } unwrapElement(t) { const e = t.parent; if (e) { const n = e.getChildIndex(t); this.remove(t); this.insertChild(n, t.getChildren(), e) } } rename(t, e) { const n = new vf(this.document, t, e.getAttributes(), e.getChildren()); return this.replace(e, n) ? n : null } setAttribute(t, e, n) { n._setAttribute(t, e) } removeAttribute(t, e) { e._removeAttribute(t) } addClass(t, e) { e._addClass(t) } removeClass(t, e) { e._removeClass(t) } setStyle(t, e, n) { if (me(t) && n === undefined) { e._setStyle(t) } else { n._setStyle(t, e) } } removeStyle(t, e) { e._removeStyle(t) } setCustomProperty(t, e, n) { n._setCustomProperty(t, e) } removeCustomProperty(t, e) { return e._removeCustomProperty(t) } createPositionAt(t, e) { return Bf._createAt(t, e) } createPositionAfter(t) { return Bf._createAfter(t) } createPositionBefore(t) { return Bf._createBefore(t) } createRange(t, e) { return new zf(t, e) } createRangeOn(t) { return zf._createOn(t) } createRangeIn(t) { return zf._createIn(t) } createSelection(...t) { return new Lf(...t) } } const wA = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i; const _A = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i; const AA = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i; const CA = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i; const vA = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i; const yA = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]); function xA(t) { if (t.startsWith("#")) { return wA.test(t) } if (t.startsWith("rgb")) { return _A.test(t) || AA.test(t) } if (t.startsWith("hsl")) { return CA.test(t) || vA.test(t) } return yA.has(t.toLowerCase()) } const EA = null && ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]; function DA(t) { return EA.includes(t) } const IA = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/; function TA(t) { return IA.test(t) } const MA = /^[+-]?[0-9]*([.][0-9]+)?%$/; function SA(t) { return MA.test(t) } const NA = null && ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"]; function BA(t) { return NA.includes(t) } const zA = null && ["center", "top", "bottom", "left", "right"]; function PA(t) { return zA.includes(t) } const LA = null && ["fixed", "scroll", "local"]; function OA(t) { return LA.includes(t) } const RA = /^url\(/; function jA(t) { return RA.test(t) } function VA(t = "") { if (t === "") { return { top: undefined, right: undefined, bottom: undefined, left: undefined } } const e = WA(t); const n = e[0]; const i = e[2] || n; const o = e[1] || n; const r = e[3] || o; return { top: n, bottom: i, right: o, left: r } } function FA(t) { return e => { const { top: n, right: i, bottom: o, left: r } = e; const s = []; if (![n, i, r, o].every((t => !!t))) { if (n) { s.push([t + "-top", n]) } if (i) { s.push([t + "-right", i]) } if (o) { s.push([t + "-bottom", o]) } if (r) { s.push([t + "-left", r]) } } else { s.push([t, HA(e)]) } return s } } function HA({ top: t, right: e, bottom: n, left: i }) { const o = []; if (i !== e) { o.push(t, e, n, i) } else if (n !== t) { o.push(t, e, n) } else if (e !== t) { o.push(t, e) } else { o.push(t) } return o.join(" ") } function UA(t) { return e => ({ path: t, value: VA(e) }) } function WA(t) { return t.replace(/, /g, ",").split(" ").map((t => t.replace(/,/g, ", "))) } function GA(t) { t.setNormalizer("background", qA()); t.setNormalizer("background-color", YA()); t.setReducer("background", $A()); t.setStyleRelation("background", ["background-color"]) } function qA() { return t => { const e = {}; const n = getShorthandValues(t); for (const t of n) { if (isRepeat(t)) { e.repeat = e.repeat || []; e.repeat.push(t) } else if (isPosition(t)) { e.position = e.position || []; e.position.push(t) } else if (isAttachment(t)) { e.attachment = t } else if (isColor(t)) { e.color = t } else if (isURL(t)) { e.image = t } } return { path: "background", value: e } } } function YA() { return t => ({ path: "background.color", value: t }) } function $A() { return t => { const e = []; e.push(["background-color", t.color]); return e } } function QA(t) { t.setNormalizer("border", KA()); t.setNormalizer("border-top", ZA("top")); t.setNormalizer("border-right", ZA("right")); t.setNormalizer("border-bottom", ZA("bottom")); t.setNormalizer("border-left", ZA("left")); t.setNormalizer("border-color", JA("color")); t.setNormalizer("border-width", JA("width")); t.setNormalizer("border-style", JA("style")); t.setNormalizer("border-top-color", tC("color", "top")); t.setNormalizer("border-top-style", tC("style", "top")); t.setNormalizer("border-top-width", tC("width", "top")); t.setNormalizer("border-right-color", tC("color", "right")); t.setNormalizer("border-right-style", tC("style", "right")); t.setNormalizer("border-right-width", tC("width", "right")); t.setNormalizer("border-bottom-color", tC("color", "bottom")); t.setNormalizer("border-bottom-style", tC("style", "bottom")); t.setNormalizer("border-bottom-width", tC("width", "bottom")); t.setNormalizer("border-left-color", tC("color", "left")); t.setNormalizer("border-left-style", tC("style", "left")); t.setNormalizer("border-left-width", tC("width", "left")); t.setExtractor("border-top", eC("top")); t.setExtractor("border-right", eC("right")); t.setExtractor("border-bottom", eC("bottom")); t.setExtractor("border-left", eC("left")); t.setExtractor("border-top-color", "border.color.top"); t.setExtractor("border-right-color", "border.color.right"); t.setExtractor("border-bottom-color", "border.color.bottom"); t.setExtractor("border-left-color", "border.color.left"); t.setExtractor("border-top-width", "border.width.top"); t.setExtractor("border-right-width", "border.width.right"); t.setExtractor("border-bottom-width", "border.width.bottom"); t.setExtractor("border-left-width", "border.width.left"); t.setExtractor("border-top-style", "border.style.top"); t.setExtractor("border-right-style", "border.style.right"); t.setExtractor("border-bottom-style", "border.style.bottom"); t.setExtractor("border-left-style", "border.style.left"); t.setReducer("border-color", getBoxSidesValueReducer("border-color")); t.setReducer("border-style", getBoxSidesValueReducer("border-style")); t.setReducer("border-width", getBoxSidesValueReducer("border-width")); t.setReducer("border-top", rC("top")); t.setReducer("border-right", rC("right")); t.setReducer("border-bottom", rC("bottom")); t.setReducer("border-left", rC("left")); t.setReducer("border", oC()); t.setStyleRelation("border", ["border-color", "border-style", "border-width", "border-top", "border-right", "border-bottom", "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]); t.setStyleRelation("border-color", ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]); t.setStyleRelation("border-style", ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"]); t.setStyleRelation("border-width", ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]); t.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]); t.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]); t.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]); t.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"]) } function KA() { return t => { const { color: e, style: n, width: i } = iC(t); return { path: "border", value: { color: getBoxSidesValues(e), style: getBoxSidesValues(n), width: getBoxSidesValues(i) } } } } function ZA(t) { return e => { const { color: n, style: i, width: o } = iC(e); const r = {}; if (n !== undefined) { r.color = { [t]: n } } if (i !== undefined) { r.style = { [t]: i } } if (o !== undefined) { r.width = { [t]: o } } return { path: "border", value: r } } } function JA(t) { return e => ({ path: "border", value: XA(e, t) }) } function XA(t, e) { return { [e]: getBoxSidesValues(t) } } function tC(t, e) { return n => ({ path: "border", value: { [t]: { [e]: n } } }) } function eC(t) { return (e, n) => { if (n.border) { return nC(n.border, t) } } } function nC(t, e) { const n = {}; if (t.width && t.width[e]) { n.width = t.width[e] } if (t.style && t.style[e]) { n.style = t.style[e] } if (t.color && t.color[e]) { n.color = t.color[e] } return n } function iC(t) { const e = {}; const n = getShorthandValues(t); for (const t of n) { if (isLength(t) || /thin|medium|thick/.test(t)) { e.width = t } else if (isLineStyle(t)) { e.style = t } else { e.color = t } } return e } function oC() { return e => { const n = nC(e, "top"); const i = nC(e, "right"); const o = nC(e, "bottom"); const r = nC(e, "left"); const s = [n, i, o, r]; const a = { width: t(s, "width"), style: t(s, "style"), color: t(s, "color") }; const c = sC(a, "all"); if (c.length) { return c } const l = Object.entries(a).reduce(((t, [e, n]) => { if (n) { t.push([`border-${e}`, n]); s.forEach((t => delete t[e])) } return t }), []); return [...l, ...sC(n, "top"), ...sC(i, "right"), ...sC(o, "bottom"), ...sC(r, "left")] }; function t(t, e) { return t.map((t => t[e])).reduce(((t, e) => t == e ? t : null)) } } function rC(t) { return e => sC(e, t) } function sC(t, e) { const n = []; if (t && t.width) { n.push("width") } if (t && t.style) { n.push("style") } if (t && t.color) { n.push("color") } if (n.length == 3) { const i = n.map((e => t[e])).join(" "); return [e == "all" ? ["border", i] : [`border-${e}`, i]] } if (e == "all") { return [] } return n.map((n => [`border-${e}-${n}`, t[n]])) } function aC(t) { t.setNormalizer("margin", UA("margin")); t.setNormalizer("margin-top", (t => ({ path: "margin.top", value: t }))); t.setNormalizer("margin-right", (t => ({ path: "margin.right", value: t }))); t.setNormalizer("margin-bottom", (t => ({ path: "margin.bottom", value: t }))); t.setNormalizer("margin-left", (t => ({ path: "margin.left", value: t }))); t.setReducer("margin", FA("margin")); t.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]) } function cC(t) { t.setNormalizer("padding", getPositionShorthandNormalizer("padding")); t.setNormalizer("padding-top", (t => ({ path: "padding.top", value: t }))); t.setNormalizer("padding-right", (t => ({ path: "padding.right", value: t }))); t.setNormalizer("padding-bottom", (t => ({ path: "padding.bottom", value: t }))); t.setNormalizer("padding-left", (t => ({ path: "padding.left", value: t }))); t.setReducer("padding", getBoxSidesValueReducer("padding")); t.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"]) } class lC { constructor() { this._commands = new Map } add(t, e) { this._commands.set(t, e) } get(t) { return this._commands.get(t) } execute(t, ...e) { const n = this.get(t); if (!n) { throw new z("commandcollection-command-not-found", this, { commandName: t }) } return n.execute(...e) } *names() { yield* this._commands.keys() } *commands() { yield* this._commands.values() } [Symbol.iterator]() { return this._commands[Symbol.iterator]() } destroy() { for (const t of this.commands()) { t.destroy() } } } class dC extends ul { constructor(t) { super(); this.editor = t } set(t, e, n = {}) { if (typeof e == "string") { const t = e; e = (e, n) => { this.editor.execute(t); n() } } super.set(t, e, n) } } class uC extends (ft()) { constructor(t = {}) { super(); const e = this.constructor; const n = t.language || e.defaultConfig && e.defaultConfig.language; this._context = t.context || new nu({ language: n }); this._context._addEditor(this, !t.context); const i = Array.from(e.builtinPlugins || []); this.config = new Ga(t, e.defaultConfig); this.config.define("plugins", i); this.config.define(this._context._getEditorConfig()); this.plugins = new eu(this, i, this._context.plugins); this.locale = this._context.locale; this.t = this.locale.t; this._readOnlyLocks = new Set; this.commands = new lC; this.set("state", "initializing"); this.once("ready", (() => this.state = "ready"), { priority: "high" }); this.once("destroy", (() => this.state = "destroyed"), { priority: "high" }); this.model = new gA; const o = new wf; this.data = new Dw(this.model, o); this.editing = new Zb(this.model, o); this.editing.view.document.bind("isReadOnly").to(this); this.conversion = new Tw([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher); this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher); this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher); this.keystrokes = new dC(this); this.keystrokes.listenTo(this.editing.view.document) } get isReadOnly() { return this._readOnlyLocks.size > 0 } set isReadOnly(t) { throw new z("editor-isreadonly-has-no-setter") } enableReadOnlyMode(t) { if (typeof t !== "string" && typeof t !== "symbol") { throw new z("editor-read-only-lock-id-invalid", null, { lockId: t }) } if (this._readOnlyLocks.has(t)) { return } this._readOnlyLocks.add(t); if (this._readOnlyLocks.size === 1) { this.fire("change:isReadOnly", "isReadOnly", true, false) } } disableReadOnlyMode(t) { if (typeof t !== "string" && typeof t !== "symbol") { throw new z("editor-read-only-lock-id-invalid", null, { lockId: t }) } if (!this._readOnlyLocks.has(t)) { return } this._readOnlyLocks.delete(t); if (this._readOnlyLocks.size === 0) { this.fire("change:isReadOnly", "isReadOnly", false, true) } } initPlugins() { const t = this.config; const e = t.get("plugins"); const n = t.get("removePlugins") || []; const i = t.get("extraPlugins") || []; const o = t.get("substitutePlugins") || []; return this.plugins.init(e.concat(i), n, o) } destroy() { let t = Promise.resolve(); if (this.state == "initializing") { t = new Promise((t => this.once("ready", t))) } return t.then((() => { this.fire("destroy"); this.stopListening(); this.commands.destroy() })).then((() => this.plugins.destroy())).then((() => { this.model.destroy(); this.data.destroy(); this.editing.destroy(); this.keystrokes.destroy() })).then((() => this._context._removeEditor(this))) } execute(t, ...e) { try { return this.commands.execute(t, ...e) } catch (t) { z.rethrowUnexpectedError(t, this) } } focus() { this.editing.view.focus() } static create(...t) { throw new Error("This is an abstract method.") } } function hC(t) { if (!Ye(t.updateSourceElement)) { throw new z("attachtoform-missing-elementapi-interface", t) } const e = t.sourceElement; if (fC(e) && e.form) { let n; const i = e.form; const o = () => t.updateSourceElement(); if (Ye(i.submit)) { n = i.submit; i.submit = () => { o(); n.apply(i) } } i.addEventListener("submit", o); t.on("destroy", (() => { i.removeEventListener("submit", o); if (n) { i.submit = n } })) } } function fC(t) { return !!t && t.tagName.toLowerCase() === "textarea" } function gC(t) { class e extends t { setData(t) { this.data.set(t) } getData(t) { return this.data.get(t) } } return e } { const t = gC(Object); gC.setData = t.prototype.setData; gC.getData = t.prototype.getData } function mC(t) { class e extends t { updateSourceElement(t = this.data.get()) { if (!this.sourceElement) { throw new z("editor-missing-sourceelement", this) } const e = this.config.get("updateSourceElementOnDestroy"); const n = this.sourceElement instanceof HTMLTextAreaElement; if (!e && !n) { gc(this.sourceElement, ""); return } gc(this.sourceElement, t) } } return e } mC.updateSourceElement = mC(Object).prototype.updateSourceElement; function pC(t, e) { if (e.ckeditorInstance) { throw new CKEditorError("editor-source-element-already-used", t) } e.ckeditorInstance = t; t.once("destroy", (() => { delete e.ckeditorInstance })) } class kC extends iu { static get pluginName() { return "PendingActions" } init() { this.set("hasAny", false); this._actions = new cl({ idProperty: "_id" }); this._actions.delegate("add", "remove").to(this) } add(t) { if (typeof t !== "string") { throw new z("pendingactions-add-invalid-message", this) } const e = new (ft()); e.set("message", t); this._actions.add(e); this.hasAny = true; return e } remove(t) { this._actions.remove(t); this.hasAny = !!this._actions.length } get first() { return this._actions.get(0) } [Symbol.iterator]() { return this._actions[Symbol.iterator]() } } const bC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>'; const wC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>'; const _C = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>'; const AC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>'; const CC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>'; const vC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>'; const yC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>'; const xC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>'; const EC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>'; const DC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>'; const IC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'; const TC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>'; const MC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>'; const SC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>'; const NC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'; const BC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>'; const zC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'; const PC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>'; const LC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'; const OC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>'; const RC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>'; const jC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>'; const VC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>'; const FC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>'; const HC = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>'; const UC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>'; const WC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>'; const GC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>'; const qC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>'; const YC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>'; const $C = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>'; const QC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>'; const KC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path clip-rule="evenodd" d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>'; const ZC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path clip-rule="evenodd" d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></g><defs><clipPath id="a"><path d="M0 0h20v20H0z"/></clipPath></defs></svg>'; const JC = { bold: YC, cancel: bC, caption: wC, check: _C, cog: AC, eraser: CC, image: yC, lowVision: vC, importExport: ZC, paragraph: $C, plus: QC, text: KC, alignBottom: xC, alignMiddle: EC, alignTop: DC, alignLeft: IC, alignCenter: TC, alignRight: MC, alignJustify: SC, objectLeft: OC, objectCenter: BC, objectRight: RC, objectFullWidth: PC, objectInline: LC, objectBlockLeft: NC, objectBlockRight: zC, objectSizeFull: jC, objectSizeLarge: VC, objectSizeSmall: FC, objectSizeMedium: HC, pencil: UC, pilcrow: WC, quote: GC, threeVerticalDots: qC }; var XC = n(5571); var tv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; tv.insert = "head"; tv.singleton = true; var ev = Dl()(XC.Z, tv); const nv = XC.Z.locals || {}; const { threeVerticalDots: iv } = JC; const ov = { alignLeft: JC.alignLeft, bold: JC.bold, importExport: JC.importExport, paragraph: JC.paragraph, plus: JC.plus, text: JC.text, threeVerticalDots: JC.threeVerticalDots }; class rv extends Nl { constructor(t, e) { super(t); const n = this.bindTemplate; const i = this.t; this.options = e || {}; this.set("ariaLabel", i("Editor toolbar")); this.set("maxWidth", "auto"); this.items = this.createCollection(); this.focusTracker = new dl; this.keystrokes = new ul; this.set("class", undefined); this.set("isCompact", false); this.itemsView = new sv(t); this.children = this.createCollection(); this.children.add(this.itemsView); this.focusables = this.createCollection(); const o = t.uiLanguageDirection === "rtl"; this._focusCycler = new Wd({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"], focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"] } }); const r = ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")]; if (this.options.shouldGroupWhenFull && this.options.isFloating) { r.push("ck-toolbar_floating") } this.setTemplate({ tag: "div", attributes: { class: r, role: "toolbar", "aria-label": n.to("ariaLabel"), style: { maxWidth: n.to("maxWidth") } }, children: this.children, on: { mousedown: $d(this) } }); this._behavior = this.options.shouldGroupWhenFull ? new cv(this) : new av(this) } render() { super.render(); for (const t of this.items) { this.focusTracker.add(t.element) } this.items.on("add", ((t, e) => { this.focusTracker.add(e.element) })); this.items.on("remove", ((t, e) => { this.focusTracker.remove(e.element) })); this.keystrokes.listenTo(this.element); this._behavior.render(this) } destroy() { this._behavior.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy(); return super.destroy() } focus() { this._focusCycler.focusFirst() } focusLast() { this._focusCycler.focusLast() } fillFromConfig(t, e, n) { this.items.addMany(this._buildItemsFromConfig(t, e, n)) } _buildItemsFromConfig(t, e, n) { const i = Qd(t); const o = n || i.removeItems; const r = this._cleanItemsConfiguration(i.items, e, o).map((t => { if (st(t)) { return this._createNestedToolbarDropdown(t, e, o) } else if (t === "|") { return new qd } else if (t === "-") { return new Yd } return e.create(t) })).filter((t => !!t)); return r } _cleanItemsConfiguration(t, e, n) { const i = t.filter(((t, i, o) => { if (t === "|") { return true } if (n.indexOf(t) !== -1) { return false } if (t === "-") { if (this.options.shouldGroupWhenFull) { P("toolbarview-line-break-ignored-when-grouping-items", o); return false } return true } if (!st(t) && !e.has(t)) { P("toolbarview-item-unavailable", { item: t }); return false } return true })); return this._cleanSeparatorsAndLineBreaks(i) } _cleanSeparatorsAndLineBreaks(t) { const e = t => t !== "-" && t !== "|"; const n = t.length; const i = t.findIndex(e); if (i === -1) { return [] } const o = n - t.slice().reverse().findIndex(e); return t.slice(i, o).filter(((t, n, i) => { if (e(t)) { return true } const o = n > 0 && i[n - 1] === t; return !o })) } _createNestedToolbarDropdown(t, e, n) { let { label: i, icon: o, items: r, tooltip: s = true, withText: a = false } = t; r = this._cleanItemsConfiguration(r, e, n); if (!r.length) { return null } const c = this.locale; const l = yv(c); if (!i) { P("toolbarview-nested-toolbar-dropdown-missing-label", t) } l.class = "ck-toolbar__nested-toolbar-dropdown"; l.buttonView.set({ label: i, tooltip: s, withText: !!a }); if (o !== false) { l.buttonView.icon = ov[o] || o || iv } else { l.buttonView.withText = true } xv(l, (() => l.toolbarView._buildItemsFromConfig(r, e, n))); return l } } class sv extends Nl { constructor(t) { super(t); this.children = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children }) } } class av { constructor(t) { const e = t.bindTemplate; t.set("isVertical", false); t.itemsView.children.bindTo(t.items).using((t => t)); t.focusables.bindTo(t.items).using((t => t)); t.extendTemplate({ attributes: { class: [e.if("isVertical", "ck-toolbar_vertical")] } }) } render() { } destroy() { } } class cv { constructor(t) { this.resizeObserver = null; this.cachedPadding = null; this.shouldUpdateGroupingOnNextResize = false; this.view = t; this.viewChildren = t.children; this.viewFocusables = t.focusables; this.viewItemsView = t.itemsView; this.viewFocusTracker = t.focusTracker; this.viewLocale = t.locale; this.ungroupedItems = t.createCollection(); this.groupedItems = t.createCollection(); this.groupedItemsDropdown = this._createGroupedItemsDropdown(); t.itemsView.children.bindTo(this.ungroupedItems).using((t => t)); this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)); t.children.on("change", this._updateFocusCycleableItems.bind(this)); t.items.on("change", ((t, e) => { const n = e.index; const i = Array.from(e.added); for (const t of e.removed) { if (n >= this.ungroupedItems.length) { this.groupedItems.remove(t) } else { this.ungroupedItems.remove(t) } } for (let t = n; t < n + i.length; t++) { const e = i[t - n]; if (t > this.ungroupedItems.length) { this.groupedItems.add(e, t - this.ungroupedItems.length) } else { this.ungroupedItems.add(e, t) } } this._updateGrouping() })); t.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } }) } render(t) { this.viewElement = t.element; this._enableGroupingOnResize(); this._enableGroupingOnMaxWidthChange(t) } destroy() { this.groupedItemsDropdown.destroy(); this.resizeObserver.destroy() } _updateGrouping() { if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) { return } if (!wc(this.viewElement)) { this.shouldUpdateGroupingOnNextResize = true; return } const t = this.groupedItems.length; let e; while (this._areItemsOverflowing) { this._groupLastItem(); e = true } if (!e && this.groupedItems.length) { while (this.groupedItems.length && !this._areItemsOverflowing) { this._ungroupFirstItem() } if (this._areItemsOverflowing) { this._groupLastItem() } } if (this.groupedItems.length !== t) { this.view.fire("groupedItemsUpdate") } } get _areItemsOverflowing() { if (!this.ungroupedItems.length) { return false } const t = this.viewElement; const e = this.viewLocale.uiLanguageDirection; const n = new lc(t.lastChild); const i = new lc(t); if (!this.cachedPadding) { const n = nc.window.getComputedStyle(t); const i = e === "ltr" ? "paddingRight" : "paddingLeft"; this.cachedPadding = Number.parseInt(n[i]) } if (e === "ltr") { return n.right > i.right - this.cachedPadding } else { return n.left < i.left + this.cachedPadding } } _enableGroupingOnResize() { let t; this.resizeObserver = new fc(this.viewElement, (e => { if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) { this.shouldUpdateGroupingOnNextResize = false; this._updateGrouping(); t = e.contentRect.width } })); this._updateGrouping() } _enableGroupingOnMaxWidthChange(t) { t.on("change:maxWidth", (() => { this._updateGrouping() })) } _groupLastItem() { if (!this.groupedItems.length) { this.viewChildren.add(new qd); this.viewChildren.add(this.groupedItemsDropdown); this.viewFocusTracker.add(this.groupedItemsDropdown.element) } this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0) } _ungroupFirstItem() { this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)); if (!this.groupedItems.length) { this.viewChildren.remove(this.groupedItemsDropdown); this.viewChildren.remove(this.viewChildren.last); this.viewFocusTracker.remove(this.groupedItemsDropdown.element) } } _createGroupedItemsDropdown() { const t = this.viewLocale; const e = t.t; const n = yv(t); n.class = "ck-toolbar__grouped-dropdown"; n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se"; xv(n, this.groupedItems); n.buttonView.set({ label: e("Show more items"), tooltip: true, tooltipPosition: t.uiLanguageDirection === "rtl" ? "se" : "sw", icon: iv }); return n } _updateFocusCycleableItems() { this.viewFocusables.clear(); this.ungroupedItems.map((t => { this.viewFocusables.add(t) })); if (this.groupedItems.length) { this.viewFocusables.add(this.groupedItemsDropdown) } } } var lv = n(1162); var dv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; dv.insert = "head"; dv.singleton = true; var uv = Dl()(lv.Z, dv); const hv = lv.Z.locals || {}; class fv extends Nl { constructor(t) { super(t); const e = this.bindTemplate; this.items = this.createCollection(); this.focusTracker = new dl; this.keystrokes = new ul; this._focusCycler = new Wd({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }); this.set("ariaLabel", undefined); this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], "aria-label": e.to("ariaLabel") }, children: this.items }) } render() { super.render(); for (const t of this.items) { this.focusTracker.add(t.element) } this.items.on("add", ((t, e) => { this.focusTracker.add(e.element) })); this.items.on("remove", ((t, e) => { this.focusTracker.remove(e.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } focusLast() { this._focusCycler.focusLast() } } class gv extends Nl { constructor(t) { super(t); const e = this.bindTemplate; this.set("isVisible", true); this.children = this.createCollection(); this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", e.if("isVisible", "ck-hidden", (t => !t))] }, children: this.children }) } focus() { this.children.first.focus() } } class mv extends Nl { constructor(t) { super(t); this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } }) } } var pv = n(5075); var kv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; kv.insert = "head"; kv.singleton = true; var bv = Dl()(pv.Z, kv); const wv = pv.Z.locals || {}; var _v = n(6875); var Av = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Av.insert = "head"; Av.singleton = true; var Cv = Dl()(_v.Z, Av); const vv = _v.Z.locals || {}; function yv(t, e = Rd) { const n = new e(t); const i = new Ld(t); const o = new Pd(t, n, i); n.bind("isEnabled").to(o); if (n instanceof Ud) { n.arrowView.bind("isOn").to(o, "isOpen") } else { n.bind("isOn").to(o, "isOpen") } Mv(o); return o } function xv(t, e, n = {}) { t.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }); if (t.isOpen) { Ev(t, e, n) } else { t.once("change:isOpen", (() => Ev(t, e, n)), { priority: "highest" }) } if (n.enableActiveItemFocusOnDropdownOpen) { Tv(t, (() => t.toolbarView.items.find((t => t.isOn)))) } } function Ev(t, e, n) { const i = t.locale; const o = i.t; const r = t.toolbarView = new rv(i); const s = typeof e == "function" ? e() : e; r.ariaLabel = n.ariaLabel || o("Dropdown toolbar"); if (n.maxWidth) { r.maxWidth = n.maxWidth } if (n.class) { r.class = n.class } if (n.isCompact) { r.isCompact = n.isCompact } if (n.isVertical) { r.isVertical = true } if (s instanceof yl) { r.items.bindTo(s).using((t => t)) } else { r.items.addMany(s) } t.panelView.children.add(r); r.items.delegate("execute").to(t) } function Dv(t, e, n = {}) { if (t.isOpen) { Iv(t, e, n) } else { t.once("change:isOpen", (() => Iv(t, e, n)), { priority: "highest" }) } Tv(t, (() => t.listView.items.find((t => { if (t instanceof gv) { return t.children.first.isOn } return false })))) } function Iv(t, e, n) { const i = t.locale; const o = t.listView = new fv(i); const r = typeof e == "function" ? e() : e; o.ariaLabel = n.ariaLabel; o.items.bindTo(r).using((t => { if (t.type === "separator") { return new mv(i) } else if (t.type === "button" || t.type === "switchbutton") { const e = new gv(i); let n; if (t.type === "button") { n = new kd(i) } else { n = new Cd(i) } n.bind(...Object.keys(t.model)).to(t.model); n.delegate("execute").to(e); e.children.add(n); return e } return null })); t.panelView.children.add(o); o.items.delegate("execute").to(t) } function Tv(t, e) { t.on("change:isOpen", (() => { if (!t.isOpen) { return } const n = e(); if (!n) { return } if (typeof n.focus === "function") { n.focus() } else { P("ui-dropdown-focus-child-on-open-child-missing-focus", { view: n }) } }), { priority: S.low - 10 }) } function Mv(t) { Sv(t); Nv(t); Bv(t); zv(t); Pv(t); Lv(t) } function Sv(e) { e.on("render", (() => { t({ emitter: e, activator: () => e.isOpen, callback: () => { e.isOpen = false }, contextElements: [e.element] }) })) } function Nv(t) { t.on("execute", (e => { if (e.source instanceof Cd) { return } t.isOpen = false })) } function Bv(t) { t.focusTracker.on("change:isFocused", ((e, n, i) => { if (t.isOpen && !i) { t.isOpen = false } })) } function zv(t) { t.keystrokes.set("arrowdown", ((e, n) => { if (t.isOpen) { t.panelView.focus(); n() } })); t.keystrokes.set("arrowup", ((e, n) => { if (t.isOpen) { t.panelView.focusLast(); n() } })) } function Pv(t) { t.on("change:isOpen", ((e, n, i) => { if (i) { return } const o = t.panelView.element; if (o && o.contains(nc.document.activeElement)) { t.buttonView.focus() } })) } function Lv(t) { t.on("change:isOpen", ((e, n, i) => { if (!i) { return } t.panelView.focus() }), { priority: "low" }) } var Ov = n(8245); var Rv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Rv.insert = "head"; Rv.singleton = true; var jv = Dl()(Ov.Z, Rv); const Vv = Ov.Z.locals || {}; const Fv = mc("px"); const Hv = nc.document.body; class Uv extends Nl { constructor(t) { super(t); const e = this.bindTemplate; this.set("top", 0); this.set("left", 0); this.set("position", "arrow_nw"); this.set("isVisible", false); this.set("withArrow", true); this.set("class", undefined); this._pinWhenIsVisibleCallback = null; this.content = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e.to("position", (t => `ck-balloon-panel_${t}`)), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")], style: { top: e.to("top", Fv), left: e.to("left", Fv) } }, children: this.content }) } show() { this.isVisible = true } hide() { this.isVisible = false } attachTo(t) { this.show(); const e = Uv.defaultPositions; const n = Object.assign({}, { element: this.element, positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast, e.viewportStickyNorth], limiter: Hv, fitInViewport: true }, t); const i = Uv._getOptimalPosition(n); const o = parseInt(i.left); const r = parseInt(i.top); const s = i.name; const a = i.config || {}; const { withArrow: c = true } = a; this.top = r; this.left = o; this.position = s; this.withArrow = c } pin(t) { this.unpin(); this._pinWhenIsVisibleCallback = () => { if (this.isVisible) { this._startPinning(t) } else { this._stopPinning() } }; this._startPinning(t); this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback) } unpin() { if (this._pinWhenIsVisibleCallback) { this._stopPinning(); this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback); this._pinWhenIsVisibleCallback = null; this.hide() } } _startPinning(t) { this.attachTo(t); const e = Wv(t.target); const n = t.limiter ? Wv(t.limiter) : Hv; this.listenTo(nc.document, "scroll", ((i, o) => { const r = o.target; const s = e && r.contains(e); const a = n && r.contains(n); if (s || a || !e || !n) { this.attachTo(t) } }), { useCapture: true }); this.listenTo(nc.window, "resize", (() => { this.attachTo(t) })) } _stopPinning() { this.stopListening(nc.document, "scroll"); this.stopListening(nc.window, "resize") } } Uv.arrowSideOffset = 25; Uv.arrowHeightOffset = 10; Uv.stickyVerticalOffset = 20; Uv._getOptimalPosition = Ac; Uv.defaultPositions = Gv(); function Wv(t) { if (Wa(t)) { return t } if (sc(t)) { return t.commonAncestorContainer } if (typeof t == "function") { return Wv(t()) } return null } function Gv(t = {}) { const { sideOffset: e = Uv.arrowSideOffset, heightOffset: n = Uv.arrowHeightOffset, stickyVerticalOffset: i = Uv.stickyVerticalOffset, config: o } = t; return { northWestArrowSouthWest: (t, n) => ({ top: r(t, n), left: t.left - e, name: "arrow_sw", ...o && { config: o } }), northWestArrowSouthMiddleWest: (t, n) => ({ top: r(t, n), left: t.left - n.width * .25 - e, name: "arrow_smw", ...o && { config: o } }), northWestArrowSouth: (t, e) => ({ top: r(t, e), left: t.left - e.width / 2, name: "arrow_s", ...o && { config: o } }), northWestArrowSouthMiddleEast: (t, n) => ({ top: r(t, n), left: t.left - n.width * .75 + e, name: "arrow_sme", ...o && { config: o } }), northWestArrowSouthEast: (t, n) => ({ top: r(t, n), left: t.left - n.width + e, name: "arrow_se", ...o && { config: o } }), northArrowSouthWest: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - e, name: "arrow_sw", ...o && { config: o } }), northArrowSouthMiddleWest: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - n.width * .25 - e, name: "arrow_smw", ...o && { config: o } }), northArrowSouth: (t, e) => ({ top: r(t, e), left: t.left + t.width / 2 - e.width / 2, name: "arrow_s", ...o && { config: o } }), northArrowSouthMiddleEast: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - n.width * .75 + e, name: "arrow_sme", ...o && { config: o } }), northArrowSouthEast: (t, n) => ({ top: r(t, n), left: t.left + t.width / 2 - n.width + e, name: "arrow_se", ...o && { config: o } }), northEastArrowSouthWest: (t, n) => ({ top: r(t, n), left: t.right - e, name: "arrow_sw", ...o && { config: o } }), northEastArrowSouthMiddleWest: (t, n) => ({ top: r(t, n), left: t.right - n.width * .25 - e, name: "arrow_smw", ...o && { config: o } }), northEastArrowSouth: (t, e) => ({ top: r(t, e), left: t.right - e.width / 2, name: "arrow_s", ...o && { config: o } }), northEastArrowSouthMiddleEast: (t, n) => ({ top: r(t, n), left: t.right - n.width * .75 + e, name: "arrow_sme", ...o && { config: o } }), northEastArrowSouthEast: (t, n) => ({ top: r(t, n), left: t.right - n.width + e, name: "arrow_se", ...o && { config: o } }), southWestArrowNorthWest: t => ({ top: s(t), left: t.left - e, name: "arrow_nw", ...o && { config: o } }), southWestArrowNorthMiddleWest: (t, n) => ({ top: s(t), left: t.left - n.width * .25 - e, name: "arrow_nmw", ...o && { config: o } }), southWestArrowNorth: (t, e) => ({ top: s(t), left: t.left - e.width / 2, name: "arrow_n", ...o && { config: o } }), southWestArrowNorthMiddleEast: (t, n) => ({ top: s(t), left: t.left - n.width * .75 + e, name: "arrow_nme", ...o && { config: o } }), southWestArrowNorthEast: (t, n) => ({ top: s(t), left: t.left - n.width + e, name: "arrow_ne", ...o && { config: o } }), southArrowNorthWest: t => ({ top: s(t), left: t.left + t.width / 2 - e, name: "arrow_nw", ...o && { config: o } }), southArrowNorthMiddleWest: (t, n) => ({ top: s(t), left: t.left + t.width / 2 - n.width * .25 - e, name: "arrow_nmw", ...o && { config: o } }), southArrowNorth: (t, e) => ({ top: s(t), left: t.left + t.width / 2 - e.width / 2, name: "arrow_n", ...o && { config: o } }), southArrowNorthMiddleEast: (t, n) => ({ top: s(t), left: t.left + t.width / 2 - n.width * .75 + e, name: "arrow_nme", ...o && { config: o } }), southArrowNorthEast: (t, n) => ({ top: s(t), left: t.left + t.width / 2 - n.width + e, name: "arrow_ne", ...o && { config: o } }), southEastArrowNorthWest: t => ({ top: s(t), left: t.right - e, name: "arrow_nw", ...o && { config: o } }), southEastArrowNorthMiddleWest: (t, n) => ({ top: s(t), left: t.right - n.width * .25 - e, name: "arrow_nmw", ...o && { config: o } }), southEastArrowNorth: (t, e) => ({ top: s(t), left: t.right - e.width / 2, name: "arrow_n", ...o && { config: o } }), southEastArrowNorthMiddleEast: (t, n) => ({ top: s(t), left: t.right - n.width * .75 + e, name: "arrow_nme", ...o && { config: o } }), southEastArrowNorthEast: (t, n) => ({ top: s(t), left: t.right - n.width + e, name: "arrow_ne", ...o && { config: o } }), westArrowEast: (t, e) => ({ top: t.top + t.height / 2 - e.height / 2, left: t.left - e.width - n, name: "arrow_e", ...o && { config: o } }), eastArrowWest: (t, e) => ({ top: t.top + t.height / 2 - e.height / 2, left: t.right + n, name: "arrow_w", ...o && { config: o } }), viewportStickyNorth: (t, e, n) => { if (!t.getIntersection(n)) { return null } return { top: n.top + i, left: t.left + t.width / 2 - e.width / 2, name: "arrowless", config: { withArrow: false, ...o } } } }; function r(t, e) { return t.top - e.height - n } function s(t) { return t.bottom + n } } var qv = n(9948); var Yv = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Yv.insert = "head"; Yv.singleton = true; var $v = Dl()(qv.Z, Yv); const Qv = qv.Z.locals || {}; const Kv = "ck-tooltip"; class Zv extends (Za()) { constructor(t) { super(); this._currentElementWithTooltip = null; this._currentTooltipPosition = null; this._resizeObserver = null; Zv._editors.add(t); if (Zv._instance) { return Zv._instance } Zv._instance = this; this.tooltipTextView = new Nl(t.locale); this.tooltipTextView.set("text", ""); this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }); this.balloonPanelView = new Uv(t.locale); this.balloonPanelView.class = Kv; this.balloonPanelView.content.add(this.tooltipTextView); this._pinTooltipDebounced = xm(this._pinTooltip, 600); this.listenTo(nc.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: true }); this.listenTo(nc.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: true }); this.listenTo(nc.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true }); this.listenTo(nc.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true }); this.listenTo(nc.document, "scroll", this._onScroll.bind(this), { useCapture: true }); this._watchdogExcluded = true } destroy(t) { const e = t.ui.view && t.ui.view.body; Zv._editors.delete(t); this.stopListening(t.ui); if (e && e.has(this.balloonPanelView)) { e.remove(this.balloonPanelView) } if (!Zv._editors.size) { this._unpinTooltip(); this.balloonPanelView.destroy(); this.stopListening(); Zv._instance = null } } static getPositioningFunctions(t) { const e = Zv.defaultBalloonPositions; return { s: [e.southArrowNorth, e.southArrowNorthEast, e.southArrowNorthWest], n: [e.northArrowSouth], e: [e.eastArrowWest], w: [e.westArrowEast], sw: [e.southArrowNorthEast], se: [e.southArrowNorthWest] }[t] } _onEnterOrFocus(t, { target: e }) { const n = Jv(e); if (!n) { return } if (n === this._currentElementWithTooltip) { return } this._unpinTooltip(); this._pinTooltipDebounced(n, Xv(n)) } _onLeaveOrBlur(t, { target: e, relatedTarget: n }) { if (t.name === "mouseleave") { if (!Wa(e)) { return } if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) { return } const t = Jv(e); const i = Jv(n); if (t && t !== i) { this._unpinTooltip() } } else { if (this._currentElementWithTooltip && e !== this._currentElementWithTooltip) { return } this._unpinTooltip() } } _onScroll(t, { target: e }) { if (!this._currentElementWithTooltip) { return } if (e.contains(this.balloonPanelView.element) && e.contains(this._currentElementWithTooltip)) { return } this._unpinTooltip() } _pinTooltip(t, { text: e, position: n, cssClass: i }) { const o = ll(Zv._editors.values()).ui.view.body; if (!o.has(this.balloonPanelView)) { o.add(this.balloonPanelView) } this.tooltipTextView.text = e; this.balloonPanelView.pin({ target: t, positions: Zv.getPositioningFunctions(n) }); this._resizeObserver = new fc(t, (() => { if (!wc(t)) { this._unpinTooltip() } })); this.balloonPanelView.class = [Kv, i].filter((t => t)).join(" "); for (const t of Zv._editors) { this.listenTo(t.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" }) } this._currentElementWithTooltip = t; this._currentTooltipPosition = n } _unpinTooltip() { this._pinTooltipDebounced.cancel(); this.balloonPanelView.unpin(); for (const t of Zv._editors) { this.stopListening(t.ui, "update") } this._currentElementWithTooltip = null; this._currentTooltipPosition = null; if (this._resizeObserver) { this._resizeObserver.destroy() } } _updateTooltipPosition() { if (!wc(this._currentElementWithTooltip)) { this._unpinTooltip(); return } this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: Zv.getPositioningFunctions(this._currentTooltipPosition) }) } } Zv.defaultBalloonPositions = Gv({ heightOffset: 5, sideOffset: 13 }); Zv._editors = new Set; Zv._instance = null; function Jv(t) { if (!Wa(t)) { return null } return t.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") } function Xv(t) { return { text: t.dataset.ckeTooltipText, position: t.dataset.ckeTooltipPosition || "s", cssClass: t.dataset.ckeTooltipClass || "" } } class ty extends (ft()) { constructor(t) { super(); this.isReady = false; this._editableElementsMap = new Map; this._focusableToolbarDefinitions = []; this.editor = t; this.componentFactory = new Td(t); this.focusTracker = new dl; this.tooltipManager = new Zv(t); this.set("viewportOffset", this._readViewportOffsetFromConfig()); this.once("ready", (() => { this.isReady = true })); this.listenTo(t.editing.view.document, "layoutChanged", (() => this.update())); this._initFocusTracking() } get element() { return null } update() { this.fire("update") } destroy() { this.stopListening(); this.focusTracker.destroy(); this.tooltipManager.destroy(this.editor); for (const t of this._editableElementsMap.values()) { t.ckeditorInstance = null; this.editor.keystrokes.stopListening(t) } this._editableElementsMap = new Map; this._focusableToolbarDefinitions = [] } setEditableElement(t, e) { this._editableElementsMap.set(t, e); if (!e.ckeditorInstance) { e.ckeditorInstance = this.editor } this.focusTracker.add(e); const n = () => { if (this.editor.editing.view.getDomRoot(t)) { return } this.editor.keystrokes.listenTo(e) }; if (this.isReady) { n() } else { this.once("ready", n) } } removeEditableElement(t) { const e = this._editableElementsMap.get(t); if (!e) { return } this._editableElementsMap.delete(t); this.editor.keystrokes.stopListening(e); this.focusTracker.remove(e); e.ckeditorInstance = null } getEditableElement(t = "main") { return this._editableElementsMap.get(t) } getEditableElementsNames() { return this._editableElementsMap.keys() } addToolbar(t, e = {}) { if (t.isRendered) { this.focusTracker.add(t.element); this.editor.keystrokes.listenTo(t.element) } else { t.once("render", (() => { this.focusTracker.add(t.element); this.editor.keystrokes.listenTo(t.element) })) } this._focusableToolbarDefinitions.push({ toolbarView: t, options: e }) } get _editableElements() { console.warn("editor-ui-deprecated-editable-elements: " + "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }); return this._editableElementsMap } _readViewportOffsetFromConfig() { const t = this.editor; const e = t.config.get("ui.viewportOffset"); if (e) { return e } const n = t.config.get("toolbar.viewportTopOffset"); if (n) { console.warn("editor-ui-deprecated-viewport-offset-config: " + "The `toolbar.vieportTopOffset` configuration option is deprecated. " + "It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."); return { top: n } } return { top: 0 } } _initFocusTracking() { const t = this.editor; const e = t.editing.view; let n; let i; t.keystrokes.set("Alt+F10", ((t, o) => { const r = this.focusTracker.focusedElement; if (Array.from(this._editableElementsMap.values()).includes(r) && !Array.from(e.domRoots.values()).includes(r)) { n = r } const s = this._getCurrentFocusedToolbarDefinition(); if (!s || !i) { i = this._getFocusableCandidateToolbarDefinitions() } for (let t = 0; t < i.length; t++) { const t = i.shift(); i.push(t); if (t !== s && this._focusFocusableCandidateToolbar(t)) { if (s && s.options.afterBlur) { s.options.afterBlur() } break } } o() })); t.keystrokes.set("Esc", ((e, i) => { const o = this._getCurrentFocusedToolbarDefinition(); if (!o) { return } if (n) { n.focus(); n = null } else { t.editing.view.focus() } if (o.options.afterBlur) { o.options.afterBlur() } i() })) } _getFocusableCandidateToolbarDefinitions() { const t = []; for (const e of this._focusableToolbarDefinitions) { const { toolbarView: n, options: i } = e; if (wc(n.element) || i.beforeFocus) { t.push(e) } } t.sort(((t, e) => ey(t) - ey(e))); return t } _getCurrentFocusedToolbarDefinition() { for (const t of this._focusableToolbarDefinitions) { if (t.toolbarView.element && t.toolbarView.element.contains(this.focusTracker.focusedElement)) { return t } } return null } _focusFocusableCandidateToolbar(t) { const { toolbarView: e, options: { beforeFocus: n } } = t; if (n) { n() } if (!wc(e.element)) { return false } e.focus(); return true } } function ey(t) { const { toolbarView: e, options: n } = t; let i = 10; if (wc(e.element)) { i-- } if (n.isContextual) { i-- } return i } var ny = n(4547); var iy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; iy.insert = "head"; iy.singleton = true; var oy = Dl()(ny.Z, iy); const ry = ny.Z.locals || {}; class sy extends Nl { constructor(t) { super(t); this.body = new ad(t) } render() { super.render(); this.body.attachToDom() } destroy() { this.body.detachFromDom(); return super.destroy() } } var ay = n(2751); var cy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; cy.insert = "head"; cy.singleton = true; var ly = Dl()(ay.Z, cy); const dy = ay.Z.locals || {}; class uy extends Nl { constructor(t) { super(t); this.set("text", undefined); this.set("for", undefined); this.id = `ck-editor__label_${T()}`; const e = this.bindTemplate; this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: e.to("for") }, children: [{ text: e.to("text") }] }) } } class hy extends sy { constructor(t) { super(t); this.top = this.createCollection(); this.main = this.createCollection(); this._voiceLabelView = this._createVoiceLabel(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: t.uiLanguageDirection, lang: t.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] }) } _createVoiceLabel() { const t = this.t; const e = new uy; e.text = t("Rich Text Editor"); e.extendTemplate({ attributes: { class: "ck-voice-label" } }); return e } } class fy extends Nl { constructor(t, e, n) { super(t); this.name = null; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: t.contentLanguage, dir: t.contentLanguageDirection } }); this.set("isFocused", false); this._editableElement = n; this._hasExternalElement = !!this._editableElement; this._editingView = e } render() { super.render(); if (this._hasExternalElement) { this.template.apply(this.element = this._editableElement) } else { this._editableElement = this.element } this.on("change:isFocused", (() => this._updateIsFocusedClasses())); this._updateIsFocusedClasses() } destroy() { if (this._hasExternalElement) { this.template.revert(this._editableElement) } super.destroy() } get hasExternalElement() { return this._hasExternalElement } _updateIsFocusedClasses() { const t = this._editingView; if (t.isRenderingInProgress) { n(this) } else { e(this) } function e(e) { t.change((n => { const i = t.document.getRoot(e.name); n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i); n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i) })) } function n(i) { t.once("change:isRenderingInProgress", ((t, o, r) => { if (!r) { e(i) } else { n(i) } })) } } } class gy extends fy { constructor(t, e, n, i = {}) { super(t, e, n); const o = t.t; this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } }); this._generateLabel = i.label || (() => o("Editor editing area: %0", this.name)) } render() { super.render(); const t = this._editingView; t.change((e => { const n = t.document.getRoot(this.name); e.setAttribute("aria-label", this._generateLabel(this), n) })) } } var my = n(5523); var py = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; py.insert = "head"; py.singleton = true; var ky = Dl()(my.Z, py); const by = my.Z.locals || {}; class wy extends Nl { constructor(t, e = {}) { super(t); const n = this.bindTemplate; this.set("label", e.label || ""); this.set("class", e.class || null); this.children = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form__header", n.to("class")] }, children: this.children }); const i = new Nl(t); i.setTemplate({ tag: "h2", attributes: { class: ["ck", "ck-form__header__label"] }, children: [{ text: n.to("label") }] }); this.children.add(i) } } var _y = n(6985); var Ay = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Ay.insert = "head"; Ay.singleton = true; var Cy = Dl()(_y.Z, Ay); const vy = _y.Z.locals || {}; class yy extends Nl { constructor(t) { super(t); this.set("value", undefined); this.set("id", undefined); this.set("placeholder", undefined); this.set("isReadOnly", false); this.set("hasError", false); this.set("ariaDescribedById", undefined); this.focusTracker = new dl; this.bind("isFocused").to(this.focusTracker); this.set("isEmpty", true); this.set("inputMode", "text"); const e = this.bindTemplate; this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", e.if("isFocused", "ck-input_focused"), e.if("isEmpty", "ck-input-text_empty"), e.if("hasError", "ck-error")], id: e.to("id"), placeholder: e.to("placeholder"), readonly: e.to("isReadOnly"), inputmode: e.to("inputMode"), "aria-invalid": e.if("hasError", true), "aria-describedby": e.to("ariaDescribedById") }, on: { input: e.to(((...t) => { this.fire("input", ...t); this._updateIsEmpty() })), change: e.to(this._updateIsEmpty.bind(this)) } }) } render() { super.render(); this.focusTracker.add(this.element); this._setDomElementValue(this.value); this._updateIsEmpty(); this.on("change:value", ((t, e, n) => { this._setDomElementValue(n); this._updateIsEmpty() })) } destroy() { super.destroy(); this.focusTracker.destroy() } select() { this.element.select() } focus() { this.element.focus() } _updateIsEmpty() { this.isEmpty = xy(this.element) } _setDomElementValue(t) { this.element.value = !t && t !== 0 ? "" : t } } function xy(t) { return !t.value } class Ey extends yy { constructor(t) { super(t); this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } }) } } class Dy extends yy { constructor(t, { min: e, max: n, step: i } = {}) { super(t); const o = this.bindTemplate; this.set("min", e); this.set("max", n); this.set("step", i); this.extendTemplate({ attributes: { type: "number", class: ["ck-input-number"], min: o.to("min"), max: o.to("max"), step: o.to("step") } }) } } class Iy extends (null && View) { constructor(t) { super(t); const e = this.bindTemplate; this.setTemplate({ tag: "iframe", attributes: { class: ["ck", "ck-reset_all"], sandbox: "allow-same-origin allow-scripts" }, on: { load: e.to("loaded") } }) } render() { return new Promise((t => { this.on("loaded", t); return super.render() })) } } var Ty = n(8111); var My = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; My.insert = "head"; My.singleton = true; var Sy = Dl()(Ty.Z, My); const Ny = Ty.Z.locals || {}; class By extends Nl { constructor(t, e) { super(t); const n = `ck-labeled-field-view-${T()}`; const i = `ck-labeled-field-view-status-${T()}`; this.fieldView = e(this, n, i); this.set("label", undefined); this.set("isEnabled", true); this.set("isEmpty", true); this.set("isFocused", false); this.set("errorText", null); this.set("infoText", null); this.set("class", undefined); this.set("placeholder", undefined); this.labelView = this._createLabelView(n); this.statusView = this._createStatusView(i); this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]); this.bind("_statusText").to(this, "errorText", this, "infoText", ((t, e) => t || e)); const o = this.bindTemplate; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", o.to("class"), o.if("isEnabled", "ck-disabled", (t => !t)), o.if("isEmpty", "ck-labeled-field-view_empty"), o.if("isFocused", "ck-labeled-field-view_focused"), o.if("placeholder", "ck-labeled-field-view_placeholder"), o.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] }) } _createLabelView(t) { const e = new uy(this.locale); e.for = t; e.bind("text").to(this, "label"); return e } _createStatusView(t) { const e = new Nl(this.locale); const n = this.bindTemplate; e.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (t => !t))], id: t, role: n.if("errorText", "alert") }, children: [{ text: n.to("_statusText") }] }); return e } focus() { this.fieldView.focus() } } function zy(t, e, n) { const i = new Ey(t.locale); i.set({ id: e, ariaDescribedById: n }); i.bind("isReadOnly").to(t, "isEnabled", (t => !t)); i.bind("hasError").to(t, "errorText", (t => !!t)); i.on("input", (() => { t.errorText = null })); t.bind("isEmpty", "isFocused", "placeholder").to(i); return i } function Py(t, e, n) { const i = new Dy(t.locale); i.set({ id: e, ariaDescribedById: n, inputMode: "numeric" }); i.bind("isReadOnly").to(t, "isEnabled", (t => !t)); i.bind("hasError").to(t, "errorText", (t => !!t)); i.on("input", (() => { t.errorText = null })); t.bind("isEmpty", "isFocused", "placeholder").to(i); return i } function Ly(t, e, n) { const i = createDropdown(t.locale); i.set({ id: e, ariaDescribedById: n }); i.bind("isEnabled").to(t); return i } class Oy extends iu { static get pluginName() { return "Notification" } init() { this.on("show:warning", ((t, e) => { window.alert(e.message) }), { priority: "lowest" }) } showSuccess(t, e = {}) { this._showNotification({ message: t, type: "success", namespace: e.namespace, title: e.title }) } showInfo(t, e = {}) { this._showNotification({ message: t, type: "info", namespace: e.namespace, title: e.title }) } showWarning(t, e = {}) { this._showNotification({ message: t, type: "warning", namespace: e.namespace, title: e.title }) } _showNotification(t) { const e = t.namespace ? `show:${t.type}:${t.namespace}` : `show:${t.type}`; this.fire(e, { message: t.message, type: t.type, title: t.title || "" }) } } class Ry extends (ft()) { constructor(t, e) { super(); if (e) { nm(this, e) } if (t) { this.set(t) } } } const jy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'; const Vy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'; var Fy = n(1757); var Hy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Hy.insert = "head"; Hy.singleton = true; var Uy = Dl()(Fy.Z, Hy); const Wy = Fy.Z.locals || {}; var Gy = n(3553); var qy = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; qy.insert = "head"; qy.singleton = true; var Yy = Dl()(Gy.Z, qy); const $y = Gy.Z.locals || {}; const Qy = mc("px"); class Ky extends Kd { static get pluginName() { return "ContextualBalloon" } constructor(t) { super(t); this._viewToStack = new Map; this._idToStack = new Map; this._view = null; this._rotatorView = null; this._fakePanelsView = null; this.positionLimiter = () => { const t = this.editor.editing.view; const e = t.document; const n = e.selection.editableElement; if (n) { return t.domConverter.mapViewToDom(n.root) } return null }; this.set("visibleView", null); this.set("_numberOfStacks", 0); this.set("_singleViewMode", false) } destroy() { super.destroy(); if (this._view) { this._view.destroy() } if (this._rotatorView) { this._rotatorView.destroy() } if (this._fakePanelsView) { this._fakePanelsView.destroy() } } get view() { if (!this._view) { this._createPanelView() } return this._view } hasView(t) { return Array.from(this._viewToStack.keys()).includes(t) } add(t) { if (!this._view) { this._createPanelView() } if (this.hasView(t.view)) { throw new z("contextualballoon-add-view-exist", [this, t]) } const e = t.stackId || "main"; if (!this._idToStack.has(e)) { this._idToStack.set(e, new Map([[t.view, t]])); this._viewToStack.set(t.view, this._idToStack.get(e)); this._numberOfStacks = this._idToStack.size; if (!this._visibleStack || t.singleViewMode) { this.showStack(e) } return } const n = this._idToStack.get(e); if (t.singleViewMode) { this.showStack(e) } n.set(t.view, t); this._viewToStack.set(t.view, n); if (n === this._visibleStack) { this._showView(t) } } remove(t) { if (!this.hasView(t)) { throw new z("contextualballoon-remove-view-not-exist", [this, t]) } const e = this._viewToStack.get(t); if (this._singleViewMode && this.visibleView === t) { this._singleViewMode = false } if (this.visibleView === t) { if (e.size === 1) { if (this._idToStack.size > 1) { this._showNextStack() } else { this.view.hide(); this.visibleView = null; this._rotatorView.hideView() } } else { this._showView(Array.from(e.values())[e.size - 2]) } } if (e.size === 1) { this._idToStack.delete(this._getStackId(e)); this._numberOfStacks = this._idToStack.size } else { e.delete(t) } this._viewToStack.delete(t) } updatePosition(t) { if (t) { this._visibleStack.get(this.visibleView).position = t } this.view.pin(this._getBalloonPosition()); this._fakePanelsView.updatePosition() } showStack(t) { this.visibleStack = t; const e = this._idToStack.get(t); if (!e) { throw new z("contextualballoon-showstack-stack-not-exist", this) } if (this._visibleStack === e) { return } this._showView(Array.from(e.values()).pop()) } _createPanelView() { this._view = new Uv(this.editor.locale); this.editor.ui.view.body.add(this._view); this.editor.ui.focusTracker.add(this._view.element); this._rotatorView = this._createRotatorView(); this._fakePanelsView = this._createFakePanelsView() } get _visibleStack() { return this._viewToStack.get(this.visibleView) } _getStackId(t) { const e = Array.from(this._idToStack.entries()).find((e => e[1] === t)); return e[0] } _showNextStack() { const t = Array.from(this._idToStack.values()); let e = t.indexOf(this._visibleStack) + 1; if (!t[e]) { e = 0 } this.showStack(this._getStackId(t[e])) } _showPrevStack() { const t = Array.from(this._idToStack.values()); let e = t.indexOf(this._visibleStack) - 1; if (!t[e]) { e = t.length - 1 } this.showStack(this._getStackId(t[e])) } _createRotatorView() { const t = new Zy(this.editor.locale); const e = this.editor.locale.t; this.view.content.add(t); t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t > 1)); t.on("change:isNavigationVisible", (() => this.updatePosition()), { priority: "low" }); t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", ((t, n) => { if (n < 2) { return "" } const i = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1; return e("%0 of %1", [i, n]) })); t.buttonNextView.on("execute", (() => { if (t.focusTracker.isFocused) { this.editor.editing.view.focus() } this._showNextStack() })); t.buttonPrevView.on("execute", (() => { if (t.focusTracker.isFocused) { this.editor.editing.view.focus() } this._showPrevStack() })); return t } _createFakePanelsView() { const t = new Jy(this.editor.locale, this.view); t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => { const n = !e && t >= 2; return n ? Math.min(t - 1, 2) : 0 })); t.listenTo(this.view, "change:top", (() => t.updatePosition())); t.listenTo(this.view, "change:left", (() => t.updatePosition())); this.editor.ui.view.body.add(t); return t } _showView({ view: t, balloonClassName: e = "", withArrow: n = true, singleViewMode: i = false }) { this.view.class = e; this.view.withArrow = n; this._rotatorView.showView(t); this.visibleView = t; this.view.pin(this._getBalloonPosition()); this._fakePanelsView.updatePosition(); if (i) { this._singleViewMode = true } } _getBalloonPosition() { let t = Array.from(this._visibleStack.values()).pop().position; if (t) { if (!t.limiter) { t = Object.assign({}, t, { limiter: this.positionLimiter }) } t = Object.assign({}, t, { viewportOffsetConfig: this.editor.ui.viewportOffset }) } return t } } class Zy extends Nl { constructor(t) { super(t); const e = t.t; const n = this.bindTemplate; this.set("isNavigationVisible", true); this.focusTracker = new dl; this.buttonPrevView = this._createButtonView(e("Previous"), jy); this.buttonNextView = this._createButtonView(e("Next"), Vy); this.content = this.createCollection(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (t => t ? "" : "ck-hidden"))] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] }) } render() { super.render(); this.focusTracker.add(this.element) } destroy() { super.destroy(); this.focusTracker.destroy() } showView(t) { this.hideView(); this.content.add(t) } hideView() { this.content.clear() } _createButtonView(t, e) { const n = new kd(this.locale); n.set({ label: t, icon: e, tooltip: true }); return n } } class Jy extends Nl { constructor(t, e) { super(t); const n = this.bindTemplate; this.set("top", 0); this.set("left", 0); this.set("height", 0); this.set("width", 0); this.set("numberOfPanels", 0); this.content = this.createCollection(); this._balloonPanelView = e; this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n.to("numberOfPanels", (t => t ? "" : "ck-hidden"))], style: { top: n.to("top", Qy), left: n.to("left", Qy), width: n.to("width", Qy), height: n.to("height", Qy) } }, children: this.content }); this.on("change:numberOfPanels", ((t, e, n, i) => { if (n > i) { this._addPanels(n - i) } else { this._removePanels(i - n) } this.updatePosition() })) } _addPanels(t) { while (t--) { const t = new Nl; t.setTemplate({ tag: "div" }); this.content.add(t); this.registerChild(t) } } _removePanels(t) { while (t--) { const t = this.content.last; this.content.remove(t); this.deregisterChild(t); t.destroy() } } updatePosition() { if (this.numberOfPanels) { const { top: t, left: e } = this._balloonPanelView; const { width: n, height: i } = new lc(this._balloonPanelView.element); Object.assign(this, { top: t, left: e, width: n, height: i }) } } } var Xy = n(3609); var tx = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; tx.insert = "head"; tx.singleton = true; var ex = Dl()(Xy.Z, tx); const nx = Xy.Z.locals || {}; const ix = mc("px"); class ox extends Nl { constructor(t) { super(t); const e = this.bindTemplate; this.set("isActive", false); this.set("isSticky", false); this.set("limiterElement", null); this.set("limiterBottomOffset", 50); this.set("viewportTopOffset", 0); this.set("_marginLeft", null); this.set("_isStickyToTheLimiter", false); this.set("_hasViewportTopOffset", false); this.content = this.createCollection(); this._contentPanelPlaceholder = new zl({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: e.to("isSticky", (t => t ? "block" : "none")), height: e.to("isSticky", (t => t ? ix(this._panelRect.height) : null)) } } }).render(); this._contentPanel = new zl({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", e.if("isSticky", "ck-sticky-panel__content_sticky"), e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: e.to("isSticky", (t => t ? ix(this._contentPanelPlaceholder.getBoundingClientRect().width) : null)), top: e.to("_hasViewportTopOffset", (t => t ? ix(this.viewportTopOffset) : null)), bottom: e.to("_isStickyToTheLimiter", (t => t ? ix(this.limiterBottomOffset) : null)), marginLeft: e.to("_marginLeft") } }, children: this.content }).render(); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] }) } render() { super.render(); this._checkIfShouldBeSticky(); this.listenTo(nc.window, "scroll", (() => { this._checkIfShouldBeSticky() })); this.listenTo(this, "change:isActive", (() => { this._checkIfShouldBeSticky() })) } _checkIfShouldBeSticky() { const t = this._panelRect = this._contentPanel.getBoundingClientRect(); let e; if (!this.limiterElement) { this.isSticky = false } else { e = this._limiterRect = this.limiterElement.getBoundingClientRect(); this.isSticky = this.isActive && e.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e.height } if (this.isSticky) { this._isStickyToTheLimiter = e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset; this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset; this._marginLeft = this._isStickyToTheLimiter ? null : ix(-nc.window.scrollX) } else { this._isStickyToTheLimiter = false; this._hasViewportTopOffset = false; this._marginLeft = null } } } const rx = mc("px"); class sx extends (null && Plugin) { static get pluginName() { return "BalloonToolbar" } static get requires() { return [ContextualBalloon] } constructor(t) { super(t); this._resizeObserver = null; this._balloonConfig = normalizeToolbarConfig(t.config.get("balloonToolbar")); this.toolbarView = this._createToolbarView(); this.focusTracker = new FocusTracker; t.ui.once("ready", (() => { this.focusTracker.add(t.ui.getEditableElement()); this.focusTracker.add(this.toolbarView.element) })); t.ui.addToolbar(this.toolbarView, { beforeFocus: () => this.show(true), afterBlur: () => this.hide(), isContextual: true }); this._balloon = t.plugins.get(ContextualBalloon); this._fireSelectionChangeDebounced = debounce((() => this.fire("_selectionChangeDebounced")), 200); this.decorate("show") } init() { const t = this.editor; const e = t.model.document.selection; this.listenTo(this.focusTracker, "change:isFocused", ((t, e, n) => { const i = this._balloon.visibleView === this.toolbarView; if (!n && i) { this.hide() } else if (n) { this.show() } })); this.listenTo(e, "change:range", ((t, n) => { if (n.directChange || e.isCollapsed) { this.hide() } this._fireSelectionChangeDebounced() })); this.listenTo(this, "_selectionChangeDebounced", (() => { if (this.editor.editing.view.document.isFocused) { this.show() } })); if (!this._balloonConfig.shouldNotGroupWhenFull) { this.listenTo(t, "ready", (() => { const e = t.ui.view.editable.element; this._resizeObserver = new ResizeObserver(e, (t => { this.toolbarView.maxWidth = rx(t.contentRect.width * .9) })) })) } this.listenTo(this.toolbarView, "groupedItemsUpdate", (() => { this._updatePosition() })) } afterInit() { const t = this.editor.ui.componentFactory; this.toolbarView.fillFromConfig(this._balloonConfig, t) } _createToolbarView() { const t = this.editor.locale.t; const e = !this._balloonConfig.shouldNotGroupWhenFull; const n = new ToolbarView(this.editor.locale, { shouldGroupWhenFull: e, isFloating: true }); n.ariaLabel = t("Editor contextual toolbar"); n.render(); return n } show(t = false) { const e = this.editor; const n = e.model.document.selection; const i = e.model.schema; if (this._balloon.hasView(this.toolbarView)) { return } if (n.isCollapsed && !t) { return } if (ax(n, i)) { return } if (Array.from(this.toolbarView.items).every((t => t.isEnabled !== undefined && !t.isEnabled))) { return } this.listenTo(this.editor.ui, "update", (() => { this._updatePosition() })); this._balloon.add({ view: this.toolbarView, position: this._getBalloonPositionData(), balloonClassName: "ck-toolbar-container" }) } hide() { if (this._balloon.hasView(this.toolbarView)) { this.stopListening(this.editor.ui, "update"); this._balloon.remove(this.toolbarView) } } _getBalloonPositionData() { const t = this.editor; const e = t.editing.view; const n = e.document; const i = n.selection; const o = n.selection.isBackward; return { target: () => { const t = o ? i.getFirstRange() : i.getLastRange(); const n = Rect.getDomRangeRects(e.domConverter.viewRangeToDom(t)); if (o) { return n[0] } else { if (n.length > 1 && n[n.length - 1].width === 0) { n.pop() } return n[n.length - 1] } }, positions: this._getBalloonPositions(o) } } _updatePosition() { this._balloon.updatePosition(this._getBalloonPositionData()) } destroy() { super.destroy(); this.stopListening(); this._fireSelectionChangeDebounced.cancel(); this.toolbarView.destroy(); this.focusTracker.destroy(); if (this._resizeObserver) { this._resizeObserver.destroy() } } _getBalloonPositions(t) { const e = env.isSafari && env.isiOS; const n = e ? generatePositions({ heightOffset: Math.max(BalloonPanelView.arrowHeightOffset, Math.round(20 / global.window.visualViewport.scale)) }) : BalloonPanelView.defaultPositions; return t ? [n.northWestArrowSouth, n.northWestArrowSouthWest, n.northWestArrowSouthEast, n.northWestArrowSouthMiddleEast, n.northWestArrowSouthMiddleWest, n.southWestArrowNorth, n.southWestArrowNorthWest, n.southWestArrowNorthEast, n.southWestArrowNorthMiddleWest, n.southWestArrowNorthMiddleEast] : [n.southEastArrowNorth, n.southEastArrowNorthEast, n.southEastArrowNorthWest, n.southEastArrowNorthMiddleEast, n.southEastArrowNorthMiddleWest, n.northEastArrowSouth, n.northEastArrowSouthEast, n.northEastArrowSouthWest, n.northEastArrowSouthMiddleEast, n.northEastArrowSouthMiddleWest] } } function ax(t, e) { if (t.rangeCount === 1) { return false } return [...t.getRanges()].every((t => { const n = t.getContainedElement(); return n && e.isSelectable(n) })) } var cx = n(6706); var lx = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; lx.insert = "head"; lx.singleton = true; var dx = Dl()(cx.Z, lx); const ux = cx.Z.locals || {}; const hx = mc("px"); class fx extends (null && ButtonView) { constructor(t) { super(t); const e = this.bindTemplate; this.isVisible = false; this.isToggleable = true; this.set("top", 0); this.set("left", 0); this.extendTemplate({ attributes: { class: "ck-block-toolbar-button", style: { top: e.to("top", (t => hx(t))), left: e.to("left", (t => hx(t))) } } }) } } const gx = mc("px"); const { pilcrow: mx } = JC; class px extends (null && Plugin) { static get pluginName() { return "BlockToolbar" } constructor(t) { super(t); this._resizeObserver = null; this._blockToolbarConfig = normalizeToolbarConfig(this.editor.config.get("blockToolbar")); this.toolbarView = this._createToolbarView(); this.panelView = this._createPanelView(); this.buttonView = this._createButtonView(); clickOutsideHandler({ emitter: this.panelView, contextElements: [this.panelView.element, this.buttonView.element], activator: () => this.panelView.isVisible, callback: () => this._hidePanel() }) } init() { const t = this.editor; this.listenTo(t.model.document.selection, "change:range", ((t, e) => { if (e.directChange) { this._hidePanel() } })); this.listenTo(t.ui, "update", (() => this._updateButton())); this.listenTo(t, "change:isReadOnly", (() => this._updateButton()), { priority: "low" }); this.listenTo(t.ui.focusTracker, "change:isFocused", (() => this._updateButton())); this.listenTo(this.buttonView, "change:isVisible", ((t, e, n) => { if (n) { this.buttonView.listenTo(window, "resize", (() => this._updateButton())) } else { this.buttonView.stopListening(window, "resize"); this._hidePanel() } })); t.ui.addToolbar(this.toolbarView, { beforeFocus: () => this._showPanel(), afterBlur: () => this._hidePanel() }) } afterInit() { const t = this.editor.ui.componentFactory; const e = this._blockToolbarConfig; this.toolbarView.fillFromConfig(e, t); for (const t of this.toolbarView.items) { t.on("execute", (() => this._hidePanel(true)), { priority: "high" }) } if (!e.shouldNotGroupWhenFull) { this.listenTo(this.editor, "ready", (() => { const t = this.editor.ui.view.editable.element; this._resizeObserver = new ResizeObserver(t, (() => { this.toolbarView.maxWidth = this._getToolbarMaxWidth() })) })) } } destroy() { super.destroy(); this.panelView.destroy(); this.buttonView.destroy(); this.toolbarView.destroy(); if (this._resizeObserver) { this._resizeObserver.destroy() } } _createToolbarView() { const t = this.editor.locale.t; const e = !this._blockToolbarConfig.shouldNotGroupWhenFull; const n = new ToolbarView(this.editor.locale, { shouldGroupWhenFull: e, isFloating: true }); n.ariaLabel = t("Editor block content toolbar"); n.focusTracker.on("change:isFocused", ((t, e, n) => { if (!n) { this._hidePanel() } })); return n } _createPanelView() { const t = this.editor; const e = new BalloonPanelView(t.locale); e.content.add(this.toolbarView); e.class = "ck-toolbar-container"; t.ui.view.body.add(e); t.ui.focusTracker.add(e.element); this.toolbarView.keystrokes.set("Esc", ((t, e) => { this._hidePanel(true); e() })); return e } _createButtonView() { const t = this.editor; const e = t.t; const n = new BlockButtonView(t.locale); const i = n.bindTemplate; n.set({ label: e("Edit block"), icon: mx, withText: false }); n.extendTemplate({ on: { mousedown: i.to((t => { if (env.isSafari && this.panelView.isVisible) { this.toolbarView.focus() } t.preventDefault() })) } }); n.bind("isOn").to(this.panelView, "isVisible"); n.bind("tooltip").to(this.panelView, "isVisible", (t => !t)); this.listenTo(n, "execute", (() => { if (!this.panelView.isVisible) { this._showPanel() } else { this._hidePanel(true) } })); t.ui.view.body.add(n); t.ui.focusTracker.add(n.element); return n } _updateButton() { const t = this.editor; const e = t.model; const n = t.editing.view; if (!t.ui.focusTracker.isFocused) { this._hideButton(); return } if (t.isReadOnly) { this._hideButton(); return } const i = Array.from(e.document.selection.getSelectedBlocks())[0]; if (!i || Array.from(this.toolbarView.items).every((t => !t.isEnabled))) { this._hideButton(); return } const o = n.domConverter.mapViewToDom(t.editing.mapper.toViewElement(i)); this.buttonView.isVisible = true; this._attachButtonToElement(o); if (this.panelView.isVisible) { this._showPanel() } } _hideButton() { this.buttonView.isVisible = false } _showPanel() { if (!this.buttonView.isVisible) { return } const t = this.panelView.isVisible; this.panelView.show(); this.toolbarView.maxWidth = this._getToolbarMaxWidth(); this.panelView.pin({ target: this.buttonView.element, limiter: this.editor.ui.getEditableElement() }); if (!t) { this.toolbarView.items.get(0).focus() } } _hidePanel(t) { this.panelView.isVisible = false; if (t) { this.editor.editing.view.focus() } } _attachButtonToElement(t) { const e = window.getComputedStyle(t); const n = new Rect(this.editor.ui.getEditableElement()); const i = parseInt(e.paddingTop, 10); const o = parseInt(e.lineHeight, 10) || parseInt(e.fontSize, 10) * 1.2; const r = getOptimalPosition({ element: this.buttonView.element, target: t, positions: [(t, e) => { let r; if (this.editor.locale.uiLanguageDirection === "ltr") { r = n.left - e.width } else { r = n.right } return { top: t.top + i + (o - e.height) / 2, left: r } }] }); this.buttonView.top = r.top; this.buttonView.left = r.left } _getToolbarMaxWidth() { const t = this.editor.ui.view.editable.element; const e = new Rect(t); const n = new Rect(this.buttonView.element); const i = this.editor.locale.uiLanguageDirection === "rtl"; const o = i ? n.left - e.right + n.width : e.left - n.left; return gx(e.width + o) } } class kx extends ty { constructor(t, e) { super(t); this.view = e; this._toolbarConfig = Qd(t.config.get("toolbar")); this._elementReplacer = new yt } get element() { return this.view.element } init(t) { const e = this.editor; const n = this.view; const i = e.editing.view; const o = n.editable; const r = i.document.getRoot(); o.name = r.rootName; n.render(); const s = o.element; this.setEditableElement(o.name, s); n.editable.bind("isFocused").to(this.focusTracker); i.attachDomRoot(s); if (t) { this._elementReplacer.replace(t, this.element) } this._initPlaceholder(); this._initToolbar(); this.fire("ready") } destroy() { super.destroy(); const t = this.view; const e = this.editor.editing.view; this._elementReplacer.restore(); e.detachDomRoot(t.editable.name); t.destroy() } _initToolbar() { const t = this.view; t.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"); t.stickyPanel.limiterElement = t.element; t.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", (({ top: t }) => t || 0)); t.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory); this.addToolbar(t.toolbar) } _initPlaceholder() { const t = this.editor; const e = t.editing.view; const n = e.document.getRoot(); const i = t.sourceElement; let o; const r = t.config.get("placeholder"); if (r) { o = typeof r === "string" ? r : r[this.view.editable.name] } if (!o && i && i.tagName.toLowerCase() === "textarea") { o = i.getAttribute("placeholder") } if (o) { lu({ view: e, element: n, text: o, isDirectHost: false, keepOnFocus: true }) } } } var bx = n(3638); var wx = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; wx.insert = "head"; wx.singleton = true; var _x = Dl()(bx.Z, wx); const Ax = bx.Z.locals || {}; class Cx extends hy { constructor(t, e, n = {}) { super(t); this.stickyPanel = new ox(t); this.toolbar = new rv(t, { shouldGroupWhenFull: n.shouldToolbarGroupWhenFull }); this.editable = new gy(t, e) } render() { super.render(); this.stickyPanel.content.add(this.toolbar); this.top.add(this.stickyPanel); this.main.add(this.editable) } } class vx { constructor(t) { this.crashes = []; this.state = "initializing"; this._now = Date.now; this.crashes = []; this._crashNumberLimit = typeof t.crashNumberLimit === "number" ? t.crashNumberLimit : 3; this._minimumNonErrorTimePeriod = typeof t.minimumNonErrorTimePeriod === "number" ? t.minimumNonErrorTimePeriod : 5e3; this._boundErrorHandler = t => { const e = "error" in t ? t.error : t.reason; if (e instanceof Error) { this._handleError(e, t) } }; this._listeners = {}; if (!this._restart) { throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. " + "Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.") } } destroy() { this._stopErrorHandling(); this._listeners = {} } on(t, e) { if (!this._listeners[t]) { this._listeners[t] = [] } this._listeners[t].push(e) } off(t, e) { this._listeners[t] = this._listeners[t].filter((t => t !== e)) } _fire(t, ...e) { const n = this._listeners[t] || []; for (const t of n) { t.apply(this, [null, ...e]) } } _startErrorHandling() { window.addEventListener("error", this._boundErrorHandler); window.addEventListener("unhandledrejection", this._boundErrorHandler) } _stopErrorHandling() { window.removeEventListener("error", this._boundErrorHandler); window.removeEventListener("unhandledrejection", this._boundErrorHandler) } _handleError(t, e) { if (this._shouldReactToError(t)) { this.crashes.push({ message: t.message, stack: t.stack, filename: e instanceof ErrorEvent ? e.filename : undefined, lineno: e instanceof ErrorEvent ? e.lineno : undefined, colno: e instanceof ErrorEvent ? e.colno : undefined, date: this._now() }); const n = this._shouldRestart(); this.state = "crashed"; this._fire("stateChange"); this._fire("error", { error: t, causesRestart: n }); if (n) { this._restart() } else { this.state = "crashedPermanently"; this._fire("stateChange") } } } _shouldReactToError(t) { return t.is && t.is("CKEditorError") && t.context !== undefined && t.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(t) } _shouldRestart() { if (this.crashes.length <= this._crashNumberLimit) { return true } const t = this.crashes[this.crashes.length - 1].date; const e = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date; const n = (t - e) / this._crashNumberLimit; return n > this._minimumNonErrorTimePeriod } } function yx(t, e = new Set) { const n = [t]; const i = new Set; let o = 0; while (n.length > o) { const t = n[o++]; if (i.has(t) || !xx(t) || e.has(t)) { continue } i.add(t); if (Symbol.iterator in t) { try { for (const e of t) { n.push(e) } } catch (t) { } } else { for (const e in t) { if (e === "defaultValue") { continue } n.push(t[e]) } } } return i } function xx(t) { const e = Object.prototype.toString.call(t); const n = typeof t; return !(n === "number" || n === "boolean" || n === "string" || n === "symbol" || n === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || t === undefined || t === null || t._watchdogExcluded || t instanceof EventTarget || t instanceof Event) } function Ex(t, e, n = new Set) { if (t === e && Ix(t)) { return true } const i = yx(t, n); const o = yx(e, n); for (const t of i) { if (o.has(t)) { return true } } return false } function Dx(t, e, n) { const { subNodes: i, prevNodeMap: o } = getSubNodes(t, n.subNodes); const { subNodes: r, prevNodeMap: s } = getSubNodes(e, n.subNodes); for (const n of i) { if (r.has(n)) { const i = []; i.push(n); let r = o.get(n); while (r && r !== t) { i.push(r); r = o.get(r) } r = s.get(n); while (r && r !== e) { i.unshift(r); r = s.get(r) } console.log("--------"); console.log({ target1: t }); console.log({ sharedNode: n }); console.log({ target2: e }); console.log({ connection: i }); return true } } return false } function Ix(t) { return typeof t === "object" && t !== null } var Tx = "Expected a function"; function Mx(t, e, n) { var i = true, o = true; if (typeof t != "function") { throw new TypeError(Tx) } if (st(n)) { i = "leading" in n ? !!n.leading : i; o = "trailing" in n ? !!n.trailing : o } return xm(t, e, { leading: i, maxWait: e, trailing: o }) } const Sx = Mx; class Nx extends vx { constructor(t, e = {}) { super(e); this._editor = null; this._throttledSave = Sx(this._save.bind(this), typeof e.saveInterval === "number" ? e.saveInterval : 5e3); if (t) { this._creator = (e, n) => t.create(e, n) } this._destructor = t => t.destroy() } get editor() { return this._editor } get _item() { return this._editor } setCreator(t) { this._creator = t } setDestructor(t) { this._destructor = t } _restart() { return Promise.resolve().then((() => { this.state = "initializing"; this._fire("stateChange"); return this._destroy() })).catch((t => { console.error("An error happened during the editor destroying.", t) })).then((() => { if (typeof this._elementOrData === "string") { return this.create(this._data, this._config, this._config.context) } else { const t = Object.assign({}, this._config, { initialData: this._data }); return this.create(this._elementOrData, t, t.context) } })).then((() => { this._fire("restart") })) } create(t = this._elementOrData, e = this._config, n) { return Promise.resolve().then((() => { super._startErrorHandling(); this._elementOrData = t; this._config = this._cloneEditorConfiguration(e) || {}; this._config.context = n; return this._creator(t, this._config) })).then((t => { this._editor = t; t.model.document.on("change:data", this._throttledSave); this._lastDocumentVersion = t.model.document.version; this._data = this._getData(); this.state = "ready"; this._fire("stateChange") })) } destroy() { return Promise.resolve().then((() => { this.state = "destroyed"; this._fire("stateChange"); super.destroy(); return this._destroy() })) } _destroy() { return Promise.resolve().then((() => { this._stopErrorHandling(); this._throttledSave.flush(); const t = this._editor; this._editor = null; t.model.document.off("change:data", this._throttledSave); return this._destructor(t) })) } _save() { const t = this._editor.model.document.version; try { this._data = this._getData(); this._lastDocumentVersion = t } catch (t) { console.error(t, "An error happened during restoring editor data. " + "Editor will be restored from the previously saved data.") } } _setExcludedProperties(t) { this._excludedProps = t } _getData() { const t = {}; for (const e of this._editor.model.document.getRootNames()) { t[e] = this._editor.data.get({ rootName: e }) } return t } _isErrorComingFromThisItem(t) { return Ex(this._editor, t.context, this._excludedProps) } _cloneEditorConfiguration(t) { return Ha(t, ((t, e) => { if (Wa(t)) { return t } if (e === "context") { return t } })) } } const Bx = Symbol("MainQueueId"); class zx extends vx { constructor(t, e = {}) { super(e); this._watchdogs = new Map; this._context = null; this._contextProps = new Set; this._actionQueues = new Px; this._watchdogConfig = e; this._creator = e => t.create(e); this._destructor = t => t.destroy(); this._actionQueues.onEmpty((() => { if (this.state === "initializing") { this.state = "ready"; this._fire("stateChange") } })) } setCreator(t) { this._creator = t } setDestructor(t) { this._destructor = t } get context() { return this._context } create(t = {}) { return this._actionQueues.enqueue(Bx, (() => { this._contextConfig = t; return this._create() })) } getItem(t) { const e = this._getWatchdog(t); return e._item } getItemState(t) { const e = this._getWatchdog(t); return e.state } add(t) { const e = Lx(t); return Promise.all(e.map((t => this._actionQueues.enqueue(t.id, (() => { if (this.state === "destroyed") { throw new Error("Cannot add items to destroyed watchdog.") } if (!this._context) { throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.") } let e; if (this._watchdogs.has(t.id)) { throw new Error(`Item with the given id is already added: '${t.id}'.`) } if (t.type === "editor") { e = new Nx(null, this._watchdogConfig); e.setCreator(t.creator); e._setExcludedProperties(this._contextProps); if (t.destructor) { e.setDestructor(t.destructor) } this._watchdogs.set(t.id, e); e.on("error", ((n, { error: i, causesRestart: o }) => { this._fire("itemError", { itemId: t.id, error: i }); if (!o) { return } this._actionQueues.enqueue(t.id, (() => new Promise((n => { const i = () => { e.off("restart", i); this._fire("itemRestart", { itemId: t.id }); n() }; e.on("restart", i) })))) })); return e.create(t.sourceElementOrData, t.config, this._context) } else { throw new Error(`Not supported item type: '${t.type}'.`) } }))))) } remove(t) { const e = Lx(t); return Promise.all(e.map((t => this._actionQueues.enqueue(t, (() => { const e = this._getWatchdog(t); this._watchdogs.delete(t); return e.destroy() }))))) } destroy() { return this._actionQueues.enqueue(Bx, (() => { this.state = "destroyed"; this._fire("stateChange"); super.destroy(); return this._destroy() })) } _restart() { return this._actionQueues.enqueue(Bx, (() => { this.state = "initializing"; this._fire("stateChange"); return this._destroy().catch((t => { console.error("An error happened during destroying the context or items.", t) })).then((() => this._create())).then((() => this._fire("restart"))) })) } _create() { return Promise.resolve().then((() => { this._startErrorHandling(); return this._creator(this._contextConfig) })).then((t => { this._context = t; this._contextProps = yx(this._context); return Promise.all(Array.from(this._watchdogs.values()).map((t => { t._setExcludedProperties(this._contextProps); return t.create(undefined, undefined, this._context) }))) })) } _destroy() { return Promise.resolve().then((() => { this._stopErrorHandling(); const t = this._context; this._context = null; this._contextProps = new Set; return Promise.all(Array.from(this._watchdogs.values()).map((t => t.destroy()))).then((() => this._destructor(t))) })) } _getWatchdog(t) { const e = this._watchdogs.get(t); if (!e) { throw new Error(`Item with the given id was not registered: ${t}.`) } return e } _isErrorComingFromThisItem(t) { for (const e of this._watchdogs.values()) { if (e._isErrorComingFromThisItem(t)) { return false } } return Ex(this._context, t.context) } } class Px { constructor() { this._onEmptyCallbacks = []; this._queues = new Map; this._activeActions = 0 } onEmpty(t) { this._onEmptyCallbacks.push(t) } enqueue(t, e) { const n = t === Bx; this._activeActions++; if (!this._queues.get(t)) { this._queues.set(t, Promise.resolve()) } const i = n ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Bx), this._queues.get(t)]); const o = i.then(e); const r = o.catch((() => { })); this._queues.set(t, r); return o.finally((() => { this._activeActions--; if (this._queues.get(t) === r && this._activeActions === 0) { this._onEmptyCallbacks.forEach((t => t())) } })) } } function Lx(t) { return Array.isArray(t) ? t : [t] } class Ox extends (gC(mC(uC))) { constructor(t, e = {}) { if (!jx(t) && e.initialData !== undefined) { throw new z("editor-create-initial-data", null) } super(e); if (this.config.get("initialData") === undefined) { this.config.set("initialData", Rx(t)) } if (jx(t)) { this.sourceElement = t } this.model.document.createRoot(); const n = !this.config.get("toolbar.shouldNotGroupWhenFull"); const i = new Cx(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n }); this.ui = new kx(this, i); hC(this) } destroy() { if (this.sourceElement) { this.updateSourceElement() } this.ui.destroy(); return super.destroy() } static create(t, e = {}) { return new Promise((n => { const i = new this(t, e); n(i.initPlugins().then((() => i.ui.init(jx(t) ? t : null))).then((() => i.data.init(i.config.get("initialData")))).then((() => i.fire("ready"))).then((() => i))) })) } } Ox.Context = nu; Ox.EditorWatchdog = Nx; Ox.ContextWatchdog = zx; function Rx(t) { return jx(t) ? oc(t) : t } function jx(t) { return Wa(t) } const Vx = ["left", "right", "center", "justify"]; function Fx(t) { return Vx.includes(t) } function Hx(t, e) { if (e.contentLanguageDirection == "rtl") { return t === "right" } else { return t === "left" } } function Ux(t) { const e = t.map((t => { let e; if (typeof t == "string") { e = { name: t } } else { e = t } return e })).filter((t => { const e = Vx.includes(t.name); if (!e) { P("alignment-config-name-not-recognized", { option: t }) } return e })); const n = e.filter((t => Boolean(t.className))).length; if (n && n < e.length) { throw new z("alignment-config-classnames-are-missing", { configuredOptions: t }) } e.forEach(((e, n, i) => { const o = i.slice(n + 1); const r = o.some((t => t.name == e.name)); if (r) { throw new z("alignment-config-name-already-defined", { option: e, configuredOptions: t }) } if (e.className) { const n = o.some((t => t.className == e.className)); if (n) { throw new z("alignment-config-classname-already-defined", { option: e, configuredOptions: t }) } } })); return e } const Wx = "alignment"; class Gx extends Jd { refresh() { const t = this.editor; const e = t.locale; const n = ll(this.editor.model.document.selection.getSelectedBlocks()); this.isEnabled = Boolean(n) && this._canBeAligned(n); if (this.isEnabled && n.hasAttribute("alignment")) { this.value = n.getAttribute("alignment") } else { this.value = e.contentLanguageDirection === "rtl" ? "right" : "left" } } execute(t = {}) { const e = this.editor; const n = e.locale; const i = e.model; const o = i.document; const r = t.value; i.change((t => { const e = Array.from(o.selection.getSelectedBlocks()).filter((t => this._canBeAligned(t))); const i = e[0].getAttribute("alignment"); const s = Hx(r, n) || i === r || !r; if (s) { qx(e, t) } else { Yx(e, t, r) } })) } _canBeAligned(t) { return this.editor.model.schema.checkAttribute(t, Wx) } } function qx(t, e) { for (const n of t) { e.removeAttribute(Wx, n) } } function Yx(t, e, n) { for (const i of t) { e.setAttribute(Wx, n, i) } } class $x extends Kd { static get pluginName() { return "AlignmentEditing" } constructor(t) { super(t); t.config.define("alignment", { options: Vx.map((t => ({ name: t }))) }) } init() { const t = this.editor; const e = t.locale; const n = t.model.schema; const i = Ux(t.config.get("alignment.options")); const o = i.filter((t => Fx(t.name) && !Hx(t.name, e))); const r = o.some((t => !!t.className)); n.extend("$block", { allowAttributes: "alignment" }); t.model.schema.setAttributeProperties("alignment", { isFormatting: true }); if (r) { t.conversion.attributeToAttribute(Jx(o)) } else { t.conversion.for("downcast").attributeToAttribute(Qx(o)) } const s = Kx(o); for (const e of s) { t.conversion.for("upcast").attributeToAttribute(e) } const a = Zx(o); for (const e of a) { t.conversion.for("upcast").attributeToAttribute(e) } t.commands.add("alignment", new Gx(t)) } } function Qx(t) { const e = {}; for (const { name: n } of t) { e[n] = { key: "style", value: { "text-align": n } } } const n = { model: { key: "alignment", values: t.map((t => t.name)) }, view: e }; return n } function Kx(t) { const e = []; for (const { name: n } of t) { e.push({ view: { key: "style", value: { "text-align": n } }, model: { key: "alignment", value: n } }) } return e } function Zx(t) { const e = []; for (const { name: n } of t) { e.push({ view: { key: "align", value: n }, model: { key: "alignment", value: n } }) } return e } function Jx(t) { const e = {}; for (const n of t) { e[n.name] = { key: "class", value: n.className } } const n = { model: { key: "alignment", values: t.map((t => t.name)) }, view: e }; return n } const Xx = new Map([["left", JC.alignLeft], ["right", JC.alignRight], ["center", JC.alignCenter], ["justify", JC.alignJustify]]); class tE extends Kd { get localizedOptionTitles() { const t = this.editor.t; return { left: t("Align left"), right: t("Align right"), center: t("Align center"), justify: t("Justify") } } static get pluginName() { return "AlignmentUI" } init() { const t = this.editor; const e = t.ui.componentFactory; const n = t.t; const i = Ux(t.config.get("alignment.options")); i.map((t => t.name)).filter(Fx).forEach((t => this._addButton(t))); e.add("alignment", (o => { const r = yv(o); xv(r, (() => i.map((t => e.create(`alignment:${t.name}`)))), { enableActiveItemFocusOnDropdownOpen: true, isVertical: true, ariaLabel: n("Text alignment toolbar") }); r.buttonView.set({ label: n("Text alignment"), tooltip: true }); r.extendTemplate({ attributes: { class: "ck-alignment-dropdown" } }); const s = o.contentLanguageDirection === "rtl" ? Xx.get("right") : Xx.get("left"); const a = t.commands.get("alignment"); r.buttonView.bind("icon").to(a, "value", (t => Xx.get(t) || s)); r.bind("isEnabled").to(a, "isEnabled"); this.listenTo(r, "execute", (() => { t.editing.view.focus() })); return r })) } _addButton(t) { const e = this.editor; e.ui.componentFactory.add(`alignment:${t}`, (n => { const i = e.commands.get("alignment"); const o = new kd(n); o.set({ label: this.localizedOptionTitles[t], icon: Xx.get(t), tooltip: true, isToggleable: true }); o.bind("isEnabled").to(i); o.bind("isOn").to(i, "value", (e => e === t)); this.listenTo(o, "execute", (() => { e.execute("alignment", { value: t }); e.editing.view.focus() })); return o })) } } class eE extends Kd { static get requires() { return [$x, tE] } static get pluginName() { return "Alignment" } } function* nE(t, e) { for (const n of e) { if (n && t.getAttributeProperties(n[0]).copyOnEnter) { yield n } } } class iE extends Jd { execute() { this.editor.model.change((t => { this.enterBlock(t); this.fire("afterExecute", { writer: t }) })) } enterBlock(t) { const e = this.editor.model; const n = e.document.selection; const i = e.schema; const o = n.isCollapsed; const r = n.getFirstRange(); const s = r.start.parent; const a = r.end.parent; if (i.isLimit(s) || i.isLimit(a)) { if (!o && s == a) { e.deleteContent(n) } return false } if (o) { const e = nE(t.model.schema, n.getAttributes()); oE(t, r.start); t.setSelectionAttribute(e); return true } else { const i = !(r.start.isAtStart && r.end.isAtEnd); const o = s == a; e.deleteContent(n, { leaveUnmerged: i }); if (i) { if (o) { oE(t, n.focus); return true } else { t.setSelection(a, 0) } } } return false } } function oE(t, e) { t.split(e); t.setSelection(e.parent.nextSibling, 0) } const rE = { insertParagraph: { isSoft: false }, insertLineBreak: { isSoft: true } }; class sE extends tm { constructor(t) { super(t); const e = this.document; let n = false; e.on("keydown", ((t, e) => { n = e.shiftKey })); e.on("beforeinput", ((i, o) => { if (!this.isEnabled) { return } let r = o.inputType; if (l.isSafari && n && r == "insertParagraph") { r = "insertLineBreak" } const s = o.domEvent; const a = rE[r]; if (!a) { return } const c = new Rf(e, "enter", o.targetRanges[0]); e.fire(c, new im(t, s, { isSoft: a.isSoft })); if (c.stop.called) { i.stop() } })) } observe() { } stopObserving() { } } class aE extends Kd { static get pluginName() { return "Enter" } init() { const t = this.editor; const e = t.editing.view; const n = e.document; e.addObserver(sE); t.commands.add("enter", new iE(t)); this.listenTo(n, "enter", ((i, o) => { if (!n.isComposing) { o.preventDefault() } if (o.isSoft) { return } t.execute("enter"); e.scrollToTheSelection() }), { priority: "low" }) } } class cE extends Jd { execute() { const t = this.editor.model; const e = t.document; t.change((n => { dE(t, n, e.selection); this.fire("afterExecute", { writer: n }) })) } refresh() { const t = this.editor.model; const e = t.document; this.isEnabled = lE(t.schema, e.selection) } } function lE(t, e) { if (e.rangeCount > 1) { return false } const n = e.anchor; if (!n || !t.checkChild(n, "softBreak")) { return false } const i = e.getFirstRange(); const o = i.start.parent; const r = i.end.parent; if ((hE(o, t) || hE(r, t)) && o !== r) { return false } return true } function dE(t, e, n) { const i = n.isCollapsed; const o = n.getFirstRange(); const r = o.start.parent; const s = o.end.parent; const a = r == s; if (i) { const i = nE(t.schema, n.getAttributes()); uE(t, e, o.end); e.removeSelectionAttribute(n.getAttributeKeys()); e.setSelectionAttribute(i) } else { const i = !(o.start.isAtStart && o.end.isAtEnd); t.deleteContent(n, { leaveUnmerged: i }); if (a) { uE(t, e, n.focus) } else { if (i) { e.setSelection(s, 0) } } } } function uE(t, e, n) { const i = e.createElement("softBreak"); t.insertContent(i, n); e.setSelection(i, "after") } function hE(t, e) { if (t.is("rootElement")) { return false } return e.isLimit(t) || hE(t.parent, e) } class fE extends Kd { static get pluginName() { return "ShiftEnter" } init() { const t = this.editor; const e = t.model.schema; const n = t.conversion; const i = t.editing.view; const o = i.document; e.register("softBreak", { allowWhere: "$text", isInline: true }); n.for("upcast").elementToElement({ model: "softBreak", view: "br" }); n.for("downcast").elementToElement({ model: "softBreak", view: (t, { writer: e }) => e.createEmptyElement("br") }); i.addObserver(sE); t.commands.add("shiftEnter", new cE(t)); this.listenTo(o, "enter", ((e, n) => { if (!o.isComposing) { n.preventDefault() } if (!n.isSoft) { return } t.execute("shiftEnter"); i.scrollToTheSelection() }), { priority: "low" }) } } class gE { constructor(t, e = 20) { this._batch = null; this.model = t; this._size = 0; this.limit = e; this._isLocked = false; this._changeCallback = (t, e) => { if (e.isLocal && e.isUndoable && e !== this._batch) { this._reset(true) } }; this._selectionChangeCallback = () => { this._reset() }; this.model.document.on("change", this._changeCallback); this.model.document.selection.on("change:range", this._selectionChangeCallback); this.model.document.selection.on("change:attribute", this._selectionChangeCallback) } get batch() { if (!this._batch) { this._batch = this.model.createBatch({ isTyping: true }) } return this._batch } get size() { return this._size } input(t) { this._size += t; if (this._size >= this.limit) { this._reset(true) } } get isLocked() { return this._isLocked } lock() { this._isLocked = true } unlock() { this._isLocked = false } destroy() { this.model.document.off("change", this._changeCallback); this.model.document.selection.off("change:range", this._selectionChangeCallback); this.model.document.selection.off("change:attribute", this._selectionChangeCallback) } _reset(t = false) { if (!this.isLocked || t) { this._batch = null; this._size = 0 } } } class mE extends Jd { constructor(t, e) { super(t); this._buffer = new gE(t.model, e) } get buffer() { return this._buffer } destroy() { super.destroy(); this._buffer.destroy() } execute(t = {}) { const e = this.editor.model; const n = e.document; const i = t.text || ""; const o = i.length; let r = n.selection; if (t.selection) { r = t.selection } else if (t.range) { r = e.createSelection(t.range) } const s = t.resultRange; e.enqueueChange(this._buffer.batch, (t => { this._buffer.lock(); e.deleteContent(r); if (i) { e.insertContent(t.createText(i, n.selection.getAttributes()), r) } if (s) { t.setSelection(s) } else if (!r.is("documentSelection")) { t.setSelection(r) } this._buffer.unlock(); this._buffer.input(o) })) } } const pE = ["insertText", "insertReplacementText"]; class kE extends tm { constructor(t) { super(t); if (l.isAndroid) { pE.push("insertCompositionText") } const e = t.document; e.on("beforeinput", ((n, i) => { if (!this.isEnabled) { return } const { data: o, targetRanges: r, inputType: s, domEvent: a } = i; if (!pE.includes(s)) { return } const c = new D(e, "insertText"); e.fire(c, new im(t, a, { text: o, selection: t.createSelection(r) })); if (c.stop.called) { n.stop() } })); e.on("compositionend", ((n, { data: i, domEvent: o }) => { if (!this.isEnabled || l.isAndroid) { return } if (!i) { return } e.fire("insertText", new im(t, o, { text: i, selection: e.selection })) }), { priority: "lowest" }) } observe() { } stopObserving() { } } class bE extends Kd { static get pluginName() { return "Input" } init() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = e.document.selection; n.addObserver(kE); const o = new mE(t, t.config.get("typing.undoStep") || 20); t.commands.add("insertText", o); t.commands.add("input", o); this.listenTo(n.document, "insertText", ((i, o) => { if (!n.document.isComposing) { o.preventDefault() } const { text: r, selection: s, resultRange: a } = o; const c = Array.from(s.getRanges()).map((e => t.editing.mapper.toModelRange(e))); let d = r; if (l.isAndroid) { const t = Array.from(c[0].getItems()).reduce(((t, e) => t + (e.is("$textProxy") ? e.data : "")), ""); if (t) { if (t.length <= d.length) { if (d.startsWith(t)) { d = d.substring(t.length); c[0].start = c[0].start.getShiftedBy(t.length) } } else { if (t.startsWith(d)) { c[0].start = c[0].start.getShiftedBy(d.length); d = "" } } } } const u = { text: d, selection: e.createSelection(c) }; if (a) { u.resultRange = t.editing.mapper.toModelRange(a) } t.execute("insertText", u) })); if (l.isAndroid) { this.listenTo(n.document, "keydown", ((t, r) => { if (i.isCollapsed || r.keyCode != 229 || !n.document.isComposing) { return } wE(e, o) })) } else { this.listenTo(n.document, "compositionstart", (() => { if (i.isCollapsed) { return } wE(e, o) })) } } } function wE(t, e) { if (!e.isEnabled) { return } const n = e.buffer; n.lock(); t.enqueueChange(n.batch, (() => { t.deleteContent(t.document.selection) })); n.unlock() } class _E extends Jd { constructor(t, e) { super(t); this.direction = e; this._buffer = new gE(t.model, t.config.get("typing.undoStep")) } get buffer() { return this._buffer } execute(t = {}) { const e = this.editor.model; const n = e.document; e.enqueueChange(this._buffer.batch, (i => { this._buffer.lock(); const o = i.createSelection(t.selection || n.selection); const r = t.sequence || 1; const s = o.isCollapsed; if (o.isCollapsed) { e.modifySelection(o, { direction: this.direction, unit: t.unit, treatEmojiAsSingleUnit: true }) } if (this._shouldEntireContentBeReplacedWithParagraph(r)) { this._replaceEntireContentWithParagraph(i); return } if (this._shouldReplaceFirstBlockWithParagraph(o, r)) { this.editor.execute("paragraph", { selection: o }); return } if (o.isCollapsed) { return } let a = 0; o.getFirstRange().getMinimalFlatRanges().forEach((t => { a += xt(t.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true })) })); e.deleteContent(o, { doNotResetEntireContent: s, direction: this.direction }); this._buffer.input(a); i.setSelection(o); this._buffer.unlock() })) } _shouldEntireContentBeReplacedWithParagraph(t) { if (t > 1) { return false } const e = this.editor.model; const n = e.document; const i = n.selection; const o = e.schema.getLimitElement(i); const r = i.isCollapsed && i.containsEntireContent(o); if (!r) { return false } if (!e.schema.checkChild(o, "paragraph")) { return false } const s = o.getChild(0); if (s && s.is("element", "paragraph")) { return false } return true } _replaceEntireContentWithParagraph(t) { const e = this.editor.model; const n = e.document; const i = n.selection; const o = e.schema.getLimitElement(i); const r = t.createElement("paragraph"); t.remove(t.createRangeIn(o)); t.insert(r, o); t.setSelection(r, 0) } _shouldReplaceFirstBlockWithParagraph(t, e) { const n = this.editor.model; if (e > 1 || this.direction != "backward") { return false } if (!t.isCollapsed) { return false } const i = t.getFirstPosition(); const o = n.schema.getLimitElement(i); const r = o.getChild(0); if (i.parent != r) { return false } if (!t.containsEntireContent(r)) { return false } if (!n.schema.checkChild(o, "paragraph")) { return false } if (r.name == "paragraph") { return false } return true } } const AE = "character"; const CE = "word"; const vE = "codePoint"; const yE = "selection"; const xE = "backward"; const EE = "forward"; const DE = { deleteContent: { unit: yE, direction: xE }, deleteContentBackward: { unit: vE, direction: xE }, deleteWordBackward: { unit: CE, direction: xE }, deleteHardLineBackward: { unit: yE, direction: xE }, deleteSoftLineBackward: { unit: yE, direction: xE }, deleteContentForward: { unit: AE, direction: EE }, deleteWordForward: { unit: CE, direction: EE }, deleteHardLineForward: { unit: yE, direction: EE }, deleteSoftLineForward: { unit: yE, direction: EE } }; class IE extends tm { constructor(t) { super(t); const e = t.document; let n = 0; e.on("keydown", (() => { n++ })); e.on("keyup", (() => { n = 0 })); e.on("beforeinput", ((i, o) => { if (!this.isEnabled) { return } const { targetRanges: r, domEvent: s, inputType: a } = o; const c = DE[a]; if (!c) { return } const d = { direction: c.direction, unit: c.unit, sequence: n }; if (d.unit == yE) { d.selectionToRemove = t.createSelection(r[0]) } if (a === "deleteContentBackward") { if (l.isAndroid) { d.sequence = 1 } if (ME(r)) { d.unit = yE; d.selectionToRemove = t.createSelection(r) } } const u = new Rf(e, "delete", r[0]); e.fire(u, new im(t, s, d)); if (u.stop.called) { i.stop() } })); if (l.isBlink) { TE(this) } } observe() { } stopObserving() { } } function TE(t) { const e = t.view; const n = e.document; let i = null; let o = false; n.on("keydown", ((t, { keyCode: e }) => { i = e; o = false })); n.on("keyup", ((a, { keyCode: c, domEvent: l }) => { const d = n.selection; const u = t.isEnabled && c == i && r(c) && !d.isCollapsed && !o; i = null; if (u) { const t = d.getFirstRange(); const i = new Rf(n, "delete", t); const o = { unit: yE, direction: s(c), selectionToRemove: d }; n.fire(i, new im(e, l, o)) } })); n.on("beforeinput", ((t, { inputType: e }) => { const n = DE[e]; const a = r(i) && n && n.direction == s(i); if (a) { o = true } }), { priority: "high" }); n.on("beforeinput", ((t, { inputType: e, data: n }) => { const o = i == Fc["delete"] && e == "insertText" && n == ""; if (o) { t.stop() } }), { priority: "high" }); function r(t) { return t == Fc.backspace || t == Fc["delete"] } function s(t) { return t == Fc.backspace ? xE : EE } } function ME(t) { if (t.length != 1 || t[0].isCollapsed) { return false } const e = t[0].getWalker({ direction: "backward", singleCharacters: true, ignoreElementEnd: true }); let n = 0; for (const { nextPosition: t } of e) { if (!t.parent.is("$text")) { n++ } else { const e = t.parent.data; const i = t.offset; if (wl(e, i) || _l(e, i) || Cl(e, i)) { continue } n++ } if (n > 1) { return true } } return false } class SE extends Kd { static get pluginName() { return "Delete" } init() { const t = this.editor; const e = t.editing.view; const n = e.document; const i = t.model.document; e.addObserver(IE); this._undoOnBackspace = false; const o = new _E(t, "forward"); t.commands.add("deleteForward", o); t.commands.add("forwardDelete", o); t.commands.add("delete", new _E(t, "backward")); this.listenTo(n, "delete", ((i, o) => { if (!n.isComposing) { o.preventDefault() } const { direction: r, sequence: s, selectionToRemove: a, unit: c } = o; const l = r === "forward" ? "deleteForward" : "delete"; const d = { sequence: s }; if (c == "selection") { const e = Array.from(a.getRanges()).map((e => t.editing.mapper.toModelRange(e))); d.selection = t.model.createSelection(e) } else { d.unit = c } t.execute(l, d); e.scrollToTheSelection() }), { priority: "low" }); if (this.editor.plugins.has("UndoEditing")) { this.listenTo(n, "delete", ((e, n) => { if (this._undoOnBackspace && n.direction == "backward" && n.sequence == 1 && n.unit == "codePoint") { this._undoOnBackspace = false; t.execute("undo"); n.preventDefault(); e.stop() } }), { context: "$capture" }); this.listenTo(i, "change", (() => { this._undoOnBackspace = false })) } } requestUndoOnBackspace() { if (this.editor.plugins.has("UndoEditing")) { this._undoOnBackspace = true } } } class NE extends Kd { static get requires() { return [bE, SE] } static get pluginName() { return "Typing" } } function BE(t, e) { let n = t.start; const i = Array.from(t.getItems()).reduce(((t, i) => { if (!(i.is("$text") || i.is("$textProxy"))) { n = e.createPositionAfter(i); return "" } return t + i.data }), ""); return { text: i, range: e.createRange(n, t.end) } } class zE extends (ft()) { constructor(t, e) { super(); this.model = t; this.testCallback = e; this._hasMatch = false; this.set("isEnabled", true); this.on("change:isEnabled", (() => { if (this.isEnabled) { this._startListening() } else { this.stopListening(t.document.selection); this.stopListening(t.document) } })); this._startListening() } get hasMatch() { return this._hasMatch } _startListening() { const t = this.model; const e = t.document; this.listenTo(e.selection, "change:range", ((t, { directChange: n }) => { if (!n) { return } if (!e.selection.isCollapsed) { if (this.hasMatch) { this.fire("unmatched"); this._hasMatch = false } return } this._evaluateTextBeforeSelection("selection") })); this.listenTo(e, "change:data", ((t, e) => { if (e.isUndo || !e.isLocal) { return } this._evaluateTextBeforeSelection("data", { batch: e }) })) } _evaluateTextBeforeSelection(t, e = {}) { const n = this.model; const i = n.document; const o = i.selection; const r = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus); const { text: s, range: a } = BE(r, n); const c = this.testCallback(s); if (!c && this.hasMatch) { this.fire("unmatched") } this._hasMatch = !!c; if (c) { const n = Object.assign(e, { text: s, range: a }); if (typeof c == "object") { Object.assign(n, c) } this.fire(`matched:${t}`, n) } } } class PE extends Kd { static get pluginName() { return "TwoStepCaretMovement" } constructor(t) { super(t); this.attributes = new Set; this._overrideUid = null } init() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = t.locale; const o = e.document.selection; this.listenTo(n.document, "arrowKey", ((t, e) => { if (!o.isCollapsed) { return } if (e.shiftKey || e.altKey || e.ctrlKey) { return } const n = e.keyCode == Fc.arrowright; const r = e.keyCode == Fc.arrowleft; if (!n && !r) { return } const s = i.contentLanguageDirection; let a = false; if (s === "ltr" && n || s === "rtl" && r) { a = this._handleForwardMovement(e) } else { a = this._handleBackwardMovement(e) } if (a === true) { t.stop() } }), { context: "$text", priority: "highest" }); this._isNextGravityRestorationSkipped = false; this.listenTo(o, "change:range", ((t, e) => { if (this._isNextGravityRestorationSkipped) { this._isNextGravityRestorationSkipped = false; return } if (!this._isGravityOverridden) { return } if (!e.directChange && VE(o.getFirstPosition(), this.attributes)) { return } this._restoreGravity() })) } registerAttribute(t) { this.attributes.add(t) } _handleForwardMovement(t) { const e = this.attributes; const n = this.editor.model; const i = n.document.selection; const o = i.getFirstPosition(); if (this._isGravityOverridden) { return false } if (o.isAtStart && LE(i, e)) { return false } if (VE(o, e)) { RE(t); this._overrideGravity(); return true } return false } _handleBackwardMovement(t) { const e = this.attributes; const n = this.editor.model; const i = n.document.selection; const o = i.getFirstPosition(); if (this._isGravityOverridden) { RE(t); this._restoreGravity(); OE(n, e, o); return true } else { if (o.isAtStart) { if (LE(i, e)) { RE(t); OE(n, e, o); return true } return false } if (jE(o, e)) { if (o.isAtEnd && !LE(i, e) && VE(o, e)) { RE(t); OE(n, e, o); return true } this._isNextGravityRestorationSkipped = true; this._overrideGravity(); return false } } return false } get _isGravityOverridden() { return !!this._overrideUid } _overrideGravity() { this._overrideUid = this.editor.model.change((t => t.overrideSelectionGravity())) } _restoreGravity() { this.editor.model.change((t => { t.restoreSelectionGravity(this._overrideUid); this._overrideUid = null })) } } function LE(t, e) { for (const n of e) { if (t.hasAttribute(n)) { return true } } return false } function OE(t, e, n) { const i = n.nodeBefore; t.change((t => { if (i) { t.setSelectionAttribute(i.getAttributes()) } else { t.removeSelectionAttribute(e) } })) } function RE(t) { t.preventDefault() } function jE(t, e) { const n = t.getShiftedBy(-1); return VE(n, e) } function VE(t, e) { const { nodeBefore: n, nodeAfter: i } = t; for (const t of e) { const e = n ? n.getAttribute(t) : undefined; const o = i ? i.getAttribute(t) : undefined; if (o !== e) { return true } } return false } const FE = { copyright: { from: "(c)", to: "©" }, registeredTrademark: { from: "(r)", to: "®" }, trademark: { from: "(tm)", to: "™" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] }, lessThanOrEqual: { from: "<=", to: "≤" }, greaterThanOrEqual: { from: ">=", to: "≥" }, notEqual: { from: "!=", to: "≠" }, arrowLeft: { from: "<-", to: "←" }, arrowRight: { from: "->", to: "→" }, horizontalEllipsis: { from: "...", to: "…" }, enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] }, quotesPrimary: { from: $E('"'), to: [null, "“", null, "”"] }, quotesSecondary: { from: $E("'"), to: [null, "‘", null, "’"] }, quotesPrimaryEnGb: { from: $E("'"), to: [null, "‘", null, "’"] }, quotesSecondaryEnGb: { from: $E('"'), to: [null, "“", null, "”"] }, quotesPrimaryPl: { from: $E('"'), to: [null, "„", null, "”"] }, quotesSecondaryPl: { from: $E("'"), to: [null, "‚", null, "’"] } }; const HE = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }; const UE = null && ["symbols", "mathematical", "typography", "quotes"]; class WE extends (null && Plugin) { static get requires() { return ["Delete", "Input"] } static get pluginName() { return "TextTransformation" } constructor(t) { super(t); t.config.define("typing", { transformations: { include: UE } }) } init() { const t = this.editor.model; const e = t.document.selection; e.on("change:range", (() => { this.isEnabled = !e.anchor.parent.is("element", "codeBlock") })); this._enableTransformationWatchers() } _enableTransformationWatchers() { const t = this.editor; const e = t.model; const n = t.plugins.get("Delete"); const i = QE(t.config.get("typing.transformations")); const o = t => { for (const e of i) { const n = e.from; const i = n.test(t); if (i) { return { normalizedTransformation: e } } } }; const r = new TextWatcher(t.model, o); r.on("matched:data", ((t, i) => { if (!i.batch.isTyping) { return } const { from: o, to: r } = i.normalizedTransformation; const s = o.exec(i.text); const a = r(s.slice(1)); const c = i.range; let l = s.index; e.enqueueChange((t => { for (let n = 1; n < s.length; n++) { const i = s[n]; const o = a[n - 1]; if (o == null) { l += i.length; continue } const r = c.start.getShiftedBy(l); const d = e.createRange(r, r.getShiftedBy(i.length)); const u = YE(r); e.insertContent(t.createText(o, u), d); l += o.length } e.enqueueChange((() => { n.requestUndoOnBackspace() })) })) })); r.bind("isEnabled").to(this) } } function GE(t) { if (typeof t == "string") { return new RegExp(`(${escapeRegExp(t)})$`) } return t } function qE(t) { if (typeof t == "string") { return () => [t] } else if (t instanceof Array) { return () => t } return t } function YE(t) { const e = t.textNode ? t.textNode : t.nodeAfter; return e.getAttributes() } function $E(t) { return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`) } function QE(t) { const e = t.extra || []; const n = t.remove || []; const i = t => !n.includes(t); const o = t.include.concat(e).filter(i); return KE(o).filter(i).map((t => typeof t == "string" && FE[t] ? FE[t] : t)).filter((t => typeof t === "object")).map((t => ({ from: GE(t.from), to: qE(t.to) }))) } function KE(t) { const e = new Set; for (const n of t) { if (typeof n == "string" && HE[n]) { for (const t of HE[n]) { e.add(t) } } else { e.add(n) } } return Array.from(e) } function ZE(t, e, n, i) { return i.createRange(JE(t, e, n, true, i), JE(t, e, n, false, i)) } function JE(t, e, n, i, o) { let r = t.textNode || (i ? t.nodeBefore : t.nodeAfter); let s = null; while (r && r.getAttribute(e) == n) { s = r; r = i ? r.previousSibling : r.nextSibling } return s ? o.createPositionAt(s, i ? "before" : "after") : t } function XE(t, e, n, i) { const o = t.editing.view; const r = new Set; o.document.registerPostFixer((o => { const s = t.model.document.selection; let a = false; if (s.hasAttribute(e)) { const c = ZE(s.getFirstPosition(), e, s.getAttribute(e), t.model); const l = t.editing.mapper.toViewRange(c); for (const t of l.getItems()) { if (t.is("element", n) && !t.hasClass(i)) { o.addClass(i, t); r.add(t); a = true } } } return a })); t.conversion.for("editingDowncast").add((t => { t.on("insert", e, { priority: "highest" }); t.on("remove", e, { priority: "highest" }); t.on("attribute", e, { priority: "highest" }); t.on("selection", e, { priority: "highest" }); function e() { o.change((t => { for (const e of r.values()) { t.removeClass(i, e); r.delete(e) } })) } })) } class tD extends Jd { refresh() { this.value = this._getValue(); this.isEnabled = this._checkEnabled() } execute(t = {}) { const e = this.editor.model; const n = e.schema; const i = e.document.selection; const o = Array.from(i.getSelectedBlocks()); const r = t.forceValue === undefined ? !this.value : t.forceValue; e.change((t => { if (!r) { this._removeQuote(t, o.filter(eD)) } else { const e = o.filter((t => eD(t) || iD(n, t))); this._applyQuote(t, e) } })) } _getValue() { const t = this.editor.model.document.selection; const e = ll(t.getSelectedBlocks()); return !!(e && eD(e)) } _checkEnabled() { if (this.value) { return true } const t = this.editor.model.document.selection; const e = this.editor.model.schema; const n = ll(t.getSelectedBlocks()); if (!n) { return false } return iD(e, n) } _removeQuote(t, e) { nD(t, e).reverse().forEach((e => { if (e.start.isAtStart && e.end.isAtEnd) { t.unwrap(e.start.parent); return } if (e.start.isAtStart) { const n = t.createPositionBefore(e.start.parent); t.move(e, n); return } if (!e.end.isAtEnd) { t.split(e.end) } const n = t.createPositionAfter(e.end.parent); t.move(e, n) })) } _applyQuote(t, e) { const n = []; nD(t, e).reverse().forEach((e => { let i = eD(e.start); if (!i) { i = t.createElement("blockQuote"); t.wrap(e, i) } n.push(i) })); n.reverse().reduce(((e, n) => { if (e.nextSibling == n) { t.merge(t.createPositionAfter(e)); return e } return n })) } } function eD(t) { return t.parent.name == "blockQuote" ? t.parent : null } function nD(t, e) { let n; let i = 0; const o = []; while (i < e.length) { const r = e[i]; const s = e[i + 1]; if (!n) { n = t.createPositionBefore(r) } if (!s || r.nextSibling != s) { o.push(t.createRange(n, t.createPositionAfter(r))); n = null } i++ } return o } function iD(t, e) { const n = t.checkChild(e.parent, "blockQuote"); const i = t.checkChild(["$root", "blockQuote"], e); return n && i } class oD extends Kd { static get pluginName() { return "BlockQuoteEditing" } static get requires() { return [aE, SE] } init() { const t = this.editor; const e = t.model.schema; t.commands.add("blockQuote", new tD(t)); e.register("blockQuote", { inheritAllFrom: "$container" }); t.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }); t.model.document.registerPostFixer((n => { const i = t.model.document.differ.getChanges(); for (const t of i) { if (t.type == "insert") { const i = t.position.nodeAfter; if (!i) { continue } if (i.is("element", "blockQuote") && i.isEmpty) { n.remove(i); return true } else if (i.is("element", "blockQuote") && !e.checkChild(t.position, i)) { n.unwrap(i); return true } else if (i.is("element")) { const t = n.createRangeIn(i); for (const i of t.getItems()) { if (i.is("element", "blockQuote") && !e.checkChild(n.createPositionBefore(i), i)) { n.unwrap(i); return true } } } } else if (t.type == "remove") { const e = t.position.parent; if (e.is("element", "blockQuote") && e.isEmpty) { n.remove(e); return true } } } return false })); const n = this.editor.editing.view.document; const i = t.model.document.selection; const o = t.commands.get("blockQuote"); this.listenTo(n, "enter", ((e, n) => { if (!i.isCollapsed || !o.value) { return } const r = i.getLastPosition().parent; if (r.isEmpty) { t.execute("blockQuote"); t.editing.view.scrollToTheSelection(); n.preventDefault(); e.stop() } }), { context: "blockquote" }); this.listenTo(n, "delete", ((e, n) => { if (n.direction != "backward" || !i.isCollapsed || !o.value) { return } const r = i.getLastPosition().parent; if (r.isEmpty && !r.previousSibling) { t.execute("blockQuote"); t.editing.view.scrollToTheSelection(); n.preventDefault(); e.stop() } }), { context: "blockquote" }) } } var rD = n(636); var sD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; sD.insert = "head"; sD.singleton = true; var aD = Dl()(rD.Z, sD); const cD = rD.Z.locals || {}; class lD extends Kd { static get pluginName() { return "BlockQuoteUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("blockQuote", (n => { const i = t.commands.get("blockQuote"); const o = new kd(n); o.set({ label: e("Block quote"), icon: JC.quote, tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute("blockQuote"); t.editing.view.focus() })); return o })) } } class dD extends Kd { static get requires() { return [oD, lD] } static get pluginName() { return "BlockQuote" } } class uD extends Jd { constructor(t, e) { super(t); this.attributeKey = e } refresh() { const t = this.editor.model; const e = t.document; this.value = this._getValueFromFirstAllowedNode(); this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey) } execute(t = {}) { const e = this.editor.model; const n = e.document; const i = n.selection; const o = t.forceValue === undefined ? !this.value : t.forceValue; e.change((t => { if (i.isCollapsed) { if (o) { t.setSelectionAttribute(this.attributeKey, true) } else { t.removeSelectionAttribute(this.attributeKey) } } else { const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey); for (const e of n) { if (o) { t.setAttribute(this.attributeKey, o, e) } else { t.removeAttribute(this.attributeKey, e) } } } })) } _getValueFromFirstAllowedNode() { const t = this.editor.model; const e = t.schema; const n = t.document.selection; if (n.isCollapsed) { return n.hasAttribute(this.attributeKey) } for (const t of n.getRanges()) { for (const n of t.getItems()) { if (e.checkAttribute(n, this.attributeKey)) { return n.hasAttribute(this.attributeKey) } } } return false } } const hD = "bold"; class fD extends Kd { static get pluginName() { return "BoldEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: hD }); t.model.schema.setAttributeProperties(hD, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: hD, view: "strong", upcastAlso: ["b", t => { const e = t.getStyle("font-weight"); if (!e) { return null } if (e == "bold" || Number(e) >= 600) { return { name: true, styles: ["font-weight"] } } return null }] }); t.commands.add(hD, new uD(t, hD)); t.keystrokes.set("CTRL+B", hD) } } const gD = "bold"; class mD extends Kd { static get pluginName() { return "BoldUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(gD, (n => { const i = t.commands.get(gD); const o = new kd(n); o.set({ label: e("Bold"), icon: JC.bold, keystroke: "CTRL+B", tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(gD); t.editing.view.focus() })); return o })) } } class pD extends Kd { static get requires() { return [fD, mD] } static get pluginName() { return "Bold" } } class kD extends om { constructor(t) { super(t); this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"]; const e = this.document; this.listenTo(e, "paste", n("clipboardInput"), { priority: "low" }); this.listenTo(e, "drop", n("clipboardInput"), { priority: "low" }); this.listenTo(e, "dragover", n("dragging"), { priority: "low" }); function n(t) { return (n, i) => { i.preventDefault(); const o = i.dropRange ? [i.dropRange] : null; const r = new D(e, t); e.fire(r, { dataTransfer: i.dataTransfer, method: n.name, targetRanges: o, target: i.target }); if (r.stop.called) { i.stopPropagation() } } } } onDomEvent(t) { const e = "clipboardData" in t ? t.clipboardData : t.dataTransfer; const n = t.type == "drop" || t.type == "paste"; const i = { dataTransfer: new Sp(e, { cacheFiles: n }) }; if (t.type == "drop" || t.type == "dragover") { i.dropRange = bD(this.view, t) } this.fire(t.type, t, i) } } function bD(t, e) { const n = e.target.ownerDocument; const i = e.clientX; const o = e.clientY; let r; if (n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)) { r = n.caretRangeFromPoint(i, o) } else if (e.rangeParent) { r = n.createRange(); r.setStart(e.rangeParent, e.rangeOffset); r.collapse(true) } if (r) { return t.domConverter.domRangeToView(r) } return null } function wD(t) { t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;"); if (t.includes("</p><p>") || t.includes("<br>")) { t = `<p>${t}</p>` } return t } function _D(t) { return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => { if (e.length == 1) { return " " } return e })).replace(/<!--[\s\S]*?-->/g, "") } const AD = ["figcaption", "li"]; function CD(t) { let e = ""; if (t.is("$text") || t.is("$textProxy")) { e = t.data } else if (t.is("element", "img") && t.hasAttribute("alt")) { e = t.getAttribute("alt") } else if (t.is("element", "br")) { e = "\n" } else { let n = null; for (const i of t.getChildren()) { const t = CD(i); if (n && (n.is("containerElement") || i.is("containerElement"))) { if (AD.includes(n.name) || AD.includes(i.name)) { e += "\n" } else { e += "\n\n" } } e += t; n = i } } return e } class vD extends Kd { static get pluginName() { return "ClipboardPipeline" } init() { const t = this.editor; const e = t.editing.view; e.addObserver(kD); this._setupPasteDrop(); this._setupCopyCut() } _setupPasteDrop() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = n.document; this.listenTo(i, "clipboardInput", (e => { if (t.isReadOnly) { e.stop() } }), { priority: "highest" }); this.listenTo(i, "clipboardInput", ((t, e) => { const i = e.dataTransfer; let o; if (e.content) { o = e.content } else { let t = ""; if (i.getData("text/html")) { t = _D(i.getData("text/html")) } else if (i.getData("text/plain")) { t = wD(i.getData("text/plain")) } o = this.editor.data.htmlProcessor.toView(t) } const r = new D(this, "inputTransformation"); this.fire(r, { content: o, dataTransfer: i, targetRanges: e.targetRanges, method: e.method }); if (r.stop.called) { t.stop() } n.scrollToTheSelection() }), { priority: "low" }); this.listenTo(this, "inputTransformation", ((t, n) => { if (n.content.isEmpty) { return } const i = this.editor.data; const o = i.toModel(n.content, "$clipboardHolder"); if (o.childCount == 0) { return } t.stop(); e.change((() => { this.fire("contentInsertion", { content: o, method: n.method, dataTransfer: n.dataTransfer, targetRanges: n.targetRanges }) })) }), { priority: "low" }); this.listenTo(this, "contentInsertion", ((t, n) => { n.resultRange = e.insertContent(n.content) }), { priority: "low" }) } _setupCopyCut() { const t = this.editor; const e = t.model.document; const n = t.editing.view; const i = n.document; const o = (n, o) => { const r = o.dataTransfer; o.preventDefault(); const s = t.data.toView(t.model.getSelectedContent(e.selection)); i.fire("clipboardOutput", { dataTransfer: r, content: s, method: n.name }) }; this.listenTo(i, "copy", o, { priority: "low" }); this.listenTo(i, "cut", ((e, n) => { if (t.isReadOnly) { n.preventDefault() } else { o(e, n) } }), { priority: "low" }); this.listenTo(i, "clipboardOutput", ((n, i) => { if (!i.content.isEmpty) { i.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(i.content)); i.dataTransfer.setData("text/plain", CD(i.content)) } if (i.method == "cut") { t.model.deleteContent(e.selection) } }), { priority: "low" }) } } class yD extends (Y()) { constructor() { super(...arguments); this._stack = [] } add(t, e) { const n = this._stack; const i = n[0]; this._insertDescriptor(t); const o = n[0]; if (i !== o && !xD(i, o)) { this.fire("change:top", { oldDescriptor: i, newDescriptor: o, writer: e }) } } remove(t, e) { const n = this._stack; const i = n[0]; this._removeDescriptor(t); const o = n[0]; if (i !== o && !xD(i, o)) { this.fire("change:top", { oldDescriptor: i, newDescriptor: o, writer: e }) } } _insertDescriptor(t) { const e = this._stack; const n = e.findIndex((e => e.id === t.id)); if (xD(t, e[n])) { return } if (n > -1) { e.splice(n, 1) } let i = 0; while (e[i] && ED(e[i], t)) { i++ } e.splice(i, 0, t) } _removeDescriptor(t) { const e = this._stack; const n = e.findIndex((e => e.id === t)); if (n > -1) { e.splice(n, 1) } } } function xD(t, e) { return t && e && t.priority == e.priority && DD(t.classes) == DD(e.classes) } function ED(t, e) { if (t.priority > e.priority) { return true } else if (t.priority < e.priority) { return false } return DD(t.classes) > DD(e.classes) } function DD(t) { return Array.isArray(t) ? t.sort().join(",") : t } const ID = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>'; const TD = "ck-widget"; const MD = "ck-widget_selected"; function SD(t) { if (!t.is("element")) { return false } return !!t.getCustomProperty("widget") } function ND(t, e, n = {}) { if (!t.is("containerElement")) { throw new z("widget-to-widget-wrong-element-type", null, { element: t }) } e.setAttribute("contenteditable", "false", t); e.addClass(TD, t); e.setCustomProperty("widget", true, t); t.getFillerOffset = FD; e.setCustomProperty("widgetLabel", [], t); if (n.label) { LD(t, n.label) } if (n.hasSelectionHandle) { HD(t, e) } PD(t, e); return t } function BD(t, e, n) { if (e.classes) { n.addClass(tl(e.classes), t) } if (e.attributes) { for (const i in e.attributes) { n.setAttribute(i, e.attributes[i], t) } } } function zD(t, e, n) { if (e.classes) { n.removeClass(tl(e.classes), t) } if (e.attributes) { for (const i in e.attributes) { n.removeAttribute(i, t) } } } function PD(t, e, n = BD, i = zD) { const o = new yD; o.on("change:top", ((e, o) => { if (o.oldDescriptor) { i(t, o.oldDescriptor, o.writer) } if (o.newDescriptor) { n(t, o.newDescriptor, o.writer) } })); const r = (t, e, n) => o.add(e, n); const s = (t, e, n) => o.remove(e, n); e.setCustomProperty("addHighlight", r, t); e.setCustomProperty("removeHighlight", s, t) } function LD(t, e) { const n = t.getCustomProperty("widgetLabel"); n.push(e) } function OD(t) { const e = t.getCustomProperty("widgetLabel"); return e.reduce(((t, e) => { if (typeof e === "function") { return t ? t + ". " + e() : e() } else { return t ? t + ". " + e : e } }), "") } function RD(t, e, n = {}) { e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t); e.setAttribute("role", "textbox", t); if (n.label) { e.setAttribute("aria-label", n.label, t) } e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t); t.on("change:isReadOnly", ((n, i, o) => { e.setAttribute("contenteditable", o ? "false" : "true", t) })); t.on("change:isFocused", ((n, i, o) => { if (o) { e.addClass("ck-editor__nested-editable_focused", t) } else { e.removeClass("ck-editor__nested-editable_focused", t) } })); PD(t, e); return t } function jD(t, e) { const n = t.getSelectedElement(); if (n) { const i = $D(t); if (i) { return e.createRange(e.createPositionAt(n, i)) } } return iA(t, e) } function VD(t, e) { return (n, i) => { const { mapper: o, viewPosition: r } = i; const s = o.findMappedViewAncestor(r); if (!e(s)) { return } const a = o.toModelElement(s); i.modelPosition = t.createPositionAt(a, r.isAtStart ? "before" : "after") } } function FD() { return null } function HD(t, e) { const n = e.createUIElement("div", { class: "ck ck-widget__selection-handle" }, (function (t) { const e = this.toDomElement(t); const n = new hd; n.set("content", ID); n.render(); e.appendChild(n.element); return e })); e.insert(e.createPositionAt(t, 0), n); e.addClass(["ck-widget_with-selection-handle"], t) } const UD = "widget-type-around"; function WD(t, e, n) { return !!t && SD(t) && !n.isInline(e) } function GD(t) { return t.closest(".ck-widget__type-around__button") } function qD(t) { return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after" } function YD(t, e) { const n = t.closest(".ck-widget"); return e.mapDomToView(n) } function $D(t) { return t.getAttribute(UD) } const QD = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>'; var KD = n(5137); var ZD = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; ZD.insert = "head"; ZD.singleton = true; var JD = Dl()(KD.Z, ZD); const XD = KD.Z.locals || {}; const tI = ["before", "after"]; const eI = (new DOMParser).parseFromString(QD, "image/svg+xml").firstChild; const nI = "ck-widget__type-around_disabled"; class iI extends Kd { constructor() { super(...arguments); this._currentFakeCaretModelElement = null } static get pluginName() { return "WidgetTypeAround" } static get requires() { return [aE, SE] } init() { const t = this.editor; const e = t.editing.view; this.on("change:isEnabled", ((n, i, o) => { e.change((t => { for (const n of e.document.roots) { if (o) { t.removeClass(nI, n) } else { t.addClass(nI, n) } } })); if (!o) { t.model.change((t => { t.removeSelectionAttribute(UD) })) } })); this._enableTypeAroundUIInjection(); this._enableInsertingParagraphsOnButtonClick(); this._enableInsertingParagraphsOnEnterKeypress(); this._enableInsertingParagraphsOnTypingKeystroke(); this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(); this._enableDeleteIntegration(); this._enableInsertContentIntegration(); this._enableInsertObjectIntegration(); this._enableDeleteContentIntegration() } destroy() { super.destroy(); this._currentFakeCaretModelElement = null } _insertParagraph(t, e) { const n = this.editor; const i = n.editing.view; const o = n.model.schema.getAttributesWithProperty(t, "copyOnReplace", true); n.execute("insertParagraph", { position: n.model.createPositionAt(t, e), attributes: o }); i.focus(); i.scrollToTheSelection() } _listenToIfEnabled(t, e, n, i) { this.listenTo(t, e, ((...t) => { if (this.isEnabled) { n(...t) } }), i) } _insertParagraphAccordingToFakeCaretPosition() { const t = this.editor; const e = t.model; const n = e.document.selection; const i = $D(n); if (!i) { return false } const o = n.getSelectedElement(); this._insertParagraph(o, i); return true } _enableTypeAroundUIInjection() { const t = this.editor; const e = t.model.schema; const n = t.locale.t; const i = { before: n("Insert paragraph before block"), after: n("Insert paragraph after block") }; t.editing.downcastDispatcher.on("insert", ((t, o, r) => { const s = r.mapper.toViewElement(o.item); if (!s) { return } if (WD(s, o.item, e)) { oI(r.writer, i, s); const t = s.getCustomProperty("widgetLabel"); t.push((() => this.isEnabled ? n("Press Enter to type after or press Shift + Enter to type before the widget") : "")) } }), { priority: "low" }) } _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() { const t = this.editor; const e = t.model; const n = e.document.selection; const i = e.schema; const o = t.editing.view; this._listenToIfEnabled(o.document, "arrowKey", ((t, e) => { this._handleArrowKeyPress(t, e) }), { context: [SD, "$text"], priority: "high" }); this._listenToIfEnabled(n, "change:range", ((e, n) => { if (!n.directChange) { return } t.model.change((t => { t.removeSelectionAttribute(UD) })) })); this._listenToIfEnabled(e.document, "change:data", (() => { const e = n.getSelectedElement(); if (e) { const n = t.editing.mapper.toViewElement(e); if (WD(n, e, i)) { return } } t.model.change((t => { t.removeSelectionAttribute(UD) })) })); this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", ((t, e, n) => { const o = n.writer; if (this._currentFakeCaretModelElement) { const t = n.mapper.toViewElement(this._currentFakeCaretModelElement); if (t) { o.removeClass(tI.map(r), t); this._currentFakeCaretModelElement = null } } const s = e.selection.getSelectedElement(); if (!s) { return } const a = n.mapper.toViewElement(s); if (!WD(a, s, i)) { return } const c = $D(e.selection); if (!c) { return } o.addClass(r(c), a); this._currentFakeCaretModelElement = s })); this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", ((e, n, i) => { if (!i) { t.model.change((t => { t.removeSelectionAttribute(UD) })) } })); function r(t) { return `ck-widget_type-around_show-fake-caret_${t}` } } _handleArrowKeyPress(t, e) { const n = this.editor; const i = n.model; const o = i.document.selection; const r = i.schema; const s = n.editing.view; const a = e.keyCode; const c = Qc(a, n.locale.contentLanguageDirection); const l = s.document.selection.getSelectedElement(); const d = n.editing.mapper.toModelElement(l); let u; if (WD(l, d, r)) { u = this._handleArrowKeyPressOnSelectedWidget(c) } else if (o.isCollapsed) { u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c) } else if (!e.shiftKey) { u = this._handleArrowKeyPressWhenNonCollapsedSelection(c) } if (u) { e.preventDefault(); t.stop() } } _handleArrowKeyPressOnSelectedWidget(t) { const e = this.editor; const n = e.model; const i = n.document.selection; const o = $D(i); return n.change((e => { if (o) { const n = o === (t ? "after" : "before"); if (!n) { e.removeSelectionAttribute(UD); return true } } else { e.setSelectionAttribute(UD, t ? "after" : "before"); return true } return false })) } _handleArrowKeyPressWhenSelectionNextToAWidget(t) { const e = this.editor; const n = e.model; const i = n.schema; const o = e.plugins.get("Widget"); const r = o._getObjectElementNextToSelection(t); const s = e.editing.mapper.toViewElement(r); if (WD(s, r, i)) { n.change((e => { o._setSelectionOverElement(r); e.setSelectionAttribute(UD, t ? "before" : "after") })); return true } return false } _handleArrowKeyPressWhenNonCollapsedSelection(t) { const e = this.editor; const n = e.model; const i = n.schema; const o = e.editing.mapper; const r = n.document.selection; const s = t ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter; const a = o.toViewElement(s); if (WD(a, s, i)) { n.change((e => { e.setSelection(s, "on"); e.setSelectionAttribute(UD, t ? "after" : "before") })); return true } return false } _enableInsertingParagraphsOnButtonClick() { const t = this.editor; const e = t.editing.view; this._listenToIfEnabled(e.document, "mousedown", ((n, i) => { const o = GD(i.domTarget); if (!o) { return } const r = qD(o); const s = YD(o, e.domConverter); const a = t.editing.mapper.toModelElement(s); this._insertParagraph(a, r); i.preventDefault(); n.stop() })) } _enableInsertingParagraphsOnEnterKeypress() { const t = this.editor; const e = t.model.document.selection; const n = t.editing.view; this._listenToIfEnabled(n.document, "enter", ((n, i) => { if (n.eventPhase != "atTarget") { return } const o = e.getSelectedElement(); const r = t.editing.mapper.toViewElement(o); const s = t.model.schema; let a; if (this._insertParagraphAccordingToFakeCaretPosition()) { a = true } else if (WD(r, o, s)) { this._insertParagraph(o, i.isSoft ? "before" : "after"); a = true } if (a) { i.preventDefault(); n.stop() } }), { context: SD }) } _enableInsertingParagraphsOnTypingKeystroke() { const t = this.editor; const e = t.editing.view.document; this._listenToIfEnabled(e, "insertText", ((t, n) => { if (this._insertParagraphAccordingToFakeCaretPosition()) { n.selection = e.selection } }), { priority: "high" }); if (l.isAndroid) { this._listenToIfEnabled(e, "keydown", ((t, e) => { if (e.keyCode == 229) { this._insertParagraphAccordingToFakeCaretPosition() } })) } else { this._listenToIfEnabled(e, "compositionstart", (() => { this._insertParagraphAccordingToFakeCaretPosition() }), { priority: "high" }) } } _enableDeleteIntegration() { const t = this.editor; const e = t.editing.view; const n = t.model; const i = n.schema; this._listenToIfEnabled(e.document, "delete", ((e, o) => { if (e.eventPhase != "atTarget") { return } const r = $D(n.document.selection); if (!r) { return } const s = o.direction; const a = n.document.selection.getSelectedElement(); const c = r === "before"; const l = s == "forward"; const d = c === l; if (d) { t.execute("delete", { selection: n.createSelection(a, "on") }) } else { const e = i.getNearestSelectionRange(n.createPositionAt(a, r), s); if (e) { if (!e.isCollapsed) { n.change((n => { n.setSelection(e); t.execute(l ? "deleteForward" : "delete") })) } else { const o = n.createSelection(e.start); n.modifySelection(o, { direction: s }); if (!o.focus.isEqual(e.start)) { n.change((n => { n.setSelection(e); t.execute(l ? "deleteForward" : "delete") })) } else { const t = aI(i, e.start.parent); n.deleteContent(n.createSelection(t, "on"), { doNotAutoparagraph: true }) } } } } o.preventDefault(); e.stop() }), { context: SD }) } _enableInsertContentIntegration() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; this._listenToIfEnabled(t.model, "insertContent", ((t, [i, o]) => { if (o && !o.is("documentSelection")) { return } const r = $D(n); if (!r) { return } t.stop(); return e.change((t => { const o = n.getSelectedElement(); const s = e.createPositionAt(o, r); const a = t.createSelection(s); const c = e.insertContent(i, a); t.setSelection(a); return c })) }), { priority: "high" }) } _enableInsertObjectIntegration() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; this._listenToIfEnabled(t.model, "insertObject", ((t, e) => { const [, i, o = {}] = e; if (i && !i.is("documentSelection")) { return } const r = $D(n); if (!r) { return } o.findOptimalPosition = r; e[3] = o }), { priority: "high" }) } _enableDeleteContentIntegration() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; this._listenToIfEnabled(t.model, "deleteContent", ((t, [e]) => { if (e && !e.is("documentSelection")) { return } const i = $D(n); if (i) { t.stop() } }), { priority: "high" }) } } function oI(t, e, n) { const i = t.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, (function (t) { const n = this.toDomElement(t); rI(n, e); sI(n); return n })); t.insert(t.createPositionAt(n, "end"), i) } function rI(t, e) { for (const n of tI) { const i = new zl({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n}`], title: e[n], "aria-hidden": "true" }, children: [t.ownerDocument.importNode(eI, true)] }); t.appendChild(i.render()) } } function sI(t) { const e = new zl({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } }); t.appendChild(e.render()) } function aI(t, e) { let n = e; for (const i of e.getAncestors({ parentFirst: true })) { if (i.childCount > 1 || t.isLimit(i)) { break } n = i } return n } function cI(t) { const e = t.model; return (n, i) => { const o = i.keyCode == Fc.arrowup; const r = i.keyCode == Fc.arrowdown; const s = i.shiftKey; const a = e.document.selection; if (!o && !r) { return } const c = r; if (s && fI(a, c)) { return } const l = lI(t, a, c); if (!l) { return } if (l.isCollapsed) { if (a.isCollapsed) { return } else if (s) { return } } if (l.isCollapsed || hI(t, l, c)) { e.change((t => { const n = c ? l.end : l.start; if (s) { const i = e.createSelection(a.anchor); i.setFocus(n); t.setSelection(i) } else { t.setSelection(n) } })); n.stop(); i.preventDefault(); i.stopPropagation() } } } function lI(t, e, n) { const i = t.model; if (n) { const t = e.isCollapsed ? e.focus : e.getLastPosition(); const n = dI(i, t, "forward"); if (!n) { return null } const o = i.createRange(t, n); const r = uI(i.schema, o, "backward"); if (r) { return i.createRange(t, r) } return null } else { const t = e.isCollapsed ? e.focus : e.getFirstPosition(); const n = dI(i, t, "backward"); if (!n) { return null } const o = i.createRange(n, t); const r = uI(i.schema, o, "forward"); if (r) { return i.createRange(r, t) } return null } } function dI(t, e, n) { const i = t.schema; const o = t.createRangeIn(e.root); const r = n == "forward" ? "elementStart" : "elementEnd"; for (const { previousPosition: t, item: s, type: a } of o.getWalker({ startPosition: e, direction: n })) { if (i.isLimit(s) && !i.isInline(s)) { return t } if (a == r && i.isBlock(s)) { return null } } return null } function uI(t, e, n) { const i = n == "backward" ? e.end : e.start; if (t.checkChild(i, "$text")) { return i } for (const { nextPosition: i } of e.getWalker({ direction: n })) { if (t.checkChild(i, "$text")) { return i } } return null } function hI(t, e, n) { const i = t.model; const o = t.view.domConverter; if (n) { const t = i.createSelection(e.start); i.modifySelection(t); if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) { e = i.createRange(t.focus, e.end) } } const r = t.mapper.toViewRange(e); const s = o.viewRangeToDom(r); const a = lc.getDomRangeRects(s); let c; for (const t of a) { if (c === undefined) { c = Math.round(t.bottom); continue } if (Math.round(t.top) >= c) { return false } c = Math.max(c, Math.round(t.bottom)) } return true } function fI(t, e) { return !t.isCollapsed && t.isBackward == e } var gI = n(6507); var mI = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; mI.insert = "head"; mI.singleton = true; var pI = Dl()(gI.Z, mI); const kI = gI.Z.locals || {}; class bI extends Kd { constructor() { super(...arguments); this._previouslySelected = new Set } static get pluginName() { return "Widget" } static get requires() { return [iI, SE] } init() { const t = this.editor; const e = t.editing.view; const n = e.document; this.editor.editing.downcastDispatcher.on("selection", ((e, n, i) => { const o = i.writer; const r = n.selection; if (r.isCollapsed) { return } const s = r.getSelectedElement(); if (!s) { return } const a = t.editing.mapper.toViewElement(s); if (!SD(a)) { return } if (!i.consumable.consume(r, "selection")) { return } o.setSelection(o.createRangeOn(a), { fake: true, label: OD(a) }) })); this.editor.editing.downcastDispatcher.on("selection", ((t, e, n) => { this._clearPreviouslySelectedWidgets(n.writer); const i = n.writer; const o = i.document.selection; let r = null; for (const t of o.getRanges()) { for (const e of t) { const t = e.item; if (SD(t) && !_I(t, r)) { i.addClass(MD, t); this._previouslySelected.add(t); r = t } } } }), { priority: "low" }); e.addObserver(kA); this.listenTo(n, "mousedown", ((...t) => this._onMousedown(...t))); this.listenTo(n, "arrowKey", ((...t) => { this._handleSelectionChangeOnArrowKeyPress(...t) }), { context: [SD, "$text"] }); this.listenTo(n, "arrowKey", ((...t) => { this._preventDefaultOnArrowKeyPress(...t) }), { context: "$root" }); this.listenTo(n, "arrowKey", cI(this.editor.editing), { context: "$text" }); this.listenTo(n, "delete", ((t, e) => { if (this._handleDelete(e.direction == "forward")) { e.preventDefault(); t.stop() } }), { context: "$root" }) } _onMousedown(t, e) { const n = this.editor; const i = n.editing.view; const o = i.document; let r = e.target; if (wI(r)) { if ((l.isSafari || l.isGecko) && e.domEvent.detail >= 3) { const t = n.editing.mapper; const i = r.is("attributeElement") ? r.findAncestor((t => !t.is("attributeElement"))) : r; const o = t.toModelElement(i); e.preventDefault(); this.editor.model.change((t => { t.setSelection(o, "in") })) } return } if (!SD(r)) { r = r.findAncestor(SD); if (!r) { return } } if (l.isAndroid) { e.preventDefault() } if (!o.isFocused) { i.focus() } const s = n.editing.mapper.toModelElement(r); this._setSelectionOverElement(s) } _handleSelectionChangeOnArrowKeyPress(t, e) { const n = e.keyCode; const i = this.editor.model; const o = i.schema; const r = i.document.selection; const s = r.getSelectedElement(); const a = Yc(n, this.editor.locale.contentLanguageDirection); const c = a == "down" || a == "right"; const l = a == "up" || a == "down"; if (s && o.isObject(s)) { const n = c ? r.getLastPosition() : r.getFirstPosition(); const s = o.getNearestSelectionRange(n, c ? "forward" : "backward"); if (s) { i.change((t => { t.setSelection(s) })); e.preventDefault(); t.stop() } return } if (!r.isCollapsed && !e.shiftKey) { const n = r.getFirstPosition(); const s = r.getLastPosition(); const a = n.nodeAfter; const l = s.nodeBefore; if (a && o.isObject(a) || l && o.isObject(l)) { i.change((t => { t.setSelection(c ? s : n) })); e.preventDefault(); t.stop() } return } if (!r.isCollapsed) { return } const d = this._getObjectElementNextToSelection(c); if (d && o.isObject(d)) { if (o.isInline(d) && l) { return } this._setSelectionOverElement(d); e.preventDefault(); t.stop() } } _preventDefaultOnArrowKeyPress(t, e) { const n = this.editor.model; const i = n.schema; const o = n.document.selection.getSelectedElement(); if (o && i.isObject(o)) { e.preventDefault(); t.stop() } } _handleDelete(t) { if (this.editor.isReadOnly) { return } const e = this.editor.model.document; const n = e.selection; if (!n.isCollapsed) { return } const i = this._getObjectElementNextToSelection(t); if (i) { this.editor.model.change((t => { let e = n.anchor.parent; while (e.isEmpty) { const n = e; e = n.parent; t.remove(n) } this._setSelectionOverElement(i) })); return true } } _setSelectionOverElement(t) { this.editor.model.change((e => { e.setSelection(e.createRangeOn(t)) })) } _getObjectElementNextToSelection(t) { const e = this.editor.model; const n = e.schema; const i = e.document.selection; const o = e.createSelection(i); e.modifySelection(o, { direction: t ? "forward" : "backward" }); if (o.isEqual(i)) { return null } const r = t ? o.focus.nodeBefore : o.focus.nodeAfter; if (!!r && n.isObject(r)) { return r } return null } _clearPreviouslySelectedWidgets(t) { for (const e of this._previouslySelected) { t.removeClass(MD, e) } this._previouslySelected.clear() } } function wI(t) { let e = t; while (e) { if (e.is("editableElement") && !e.is("rootElement")) { return true } if (SD(e)) { return false } e = e.parent } return false } function _I(t, e) { if (!e) { return false } return Array.from(t.getAncestors()).includes(e) } class AI extends Kd { constructor() { super(...arguments); this._toolbarDefinitions = new Map } static get requires() { return [Ky] } static get pluginName() { return "WidgetToolbarRepository" } init() { const t = this.editor; if (t.plugins.has("BalloonToolbar")) { const e = t.plugins.get("BalloonToolbar"); this.listenTo(e, "show", (e => { if (yI(t.editing.view.document.selection)) { e.stop() } }), { priority: "high" }) } this._balloon = this.editor.plugins.get("ContextualBalloon"); this.on("change:isEnabled", (() => { this._updateToolbarsVisibility() })); this.listenTo(t.ui, "update", (() => { this._updateToolbarsVisibility() })); this.listenTo(t.ui.focusTracker, "change:isFocused", (() => { this._updateToolbarsVisibility() }), { priority: "low" }) } destroy() { super.destroy(); for (const t of this._toolbarDefinitions.values()) { t.view.destroy() } } register(t, { ariaLabel: e, items: n, getRelatedElement: i, balloonClassName: o = "ck-toolbar-container" }) { if (!n.length) { P("widget-toolbar-no-items", { toolbarId: t }); return } const r = this.editor; const s = r.t; const a = new rv(r.locale); a.ariaLabel = e || s("Widget toolbar"); if (this._toolbarDefinitions.has(t)) { throw new z("widget-toolbar-duplicated", this, { toolbarId: t }) } const c = { view: a, getRelatedElement: i, balloonClassName: o, itemsConfig: n, initialized: false }; r.ui.addToolbar(a, { isContextual: true, beforeFocus: () => { const t = i(r.editing.view.document.selection); if (t) { this._showToolbar(c, t) } }, afterBlur: () => { this._hideToolbar(c) } }); this._toolbarDefinitions.set(t, c) } _updateToolbarsVisibility() { let t = 0; let e = null; let n = null; for (const i of this._toolbarDefinitions.values()) { const o = i.getRelatedElement(this.editor.editing.view.document.selection); if (!this.isEnabled || !o) { if (this._isToolbarInBalloon(i)) { this._hideToolbar(i) } } else if (!this.editor.ui.focusTracker.isFocused) { if (this._isToolbarVisible(i)) { this._hideToolbar(i) } } else { const r = o.getAncestors().length; if (r > t) { t = r; e = o; n = i } } } if (n) { this._showToolbar(n, e) } } _hideToolbar(t) { this._balloon.remove(t.view); this.stopListening(this._balloon, "change:visibleView") } _showToolbar(t, e) { if (this._isToolbarVisible(t)) { CI(this.editor, e) } else if (!this._isToolbarInBalloon(t)) { if (!t.initialized) { t.initialized = true; t.view.fillFromConfig(t.itemsConfig, this.editor.ui.componentFactory) } this._balloon.add({ view: t.view, position: vI(this.editor, e), balloonClassName: t.balloonClassName }); this.listenTo(this._balloon, "change:visibleView", (() => { for (const t of this._toolbarDefinitions.values()) { if (this._isToolbarVisible(t)) { const e = t.getRelatedElement(this.editor.editing.view.document.selection); CI(this.editor, e) } } })) } } _isToolbarVisible(t) { return this._balloon.visibleView === t.view } _isToolbarInBalloon(t) { return this._balloon.hasView(t.view) } } function CI(t, e) { const n = t.plugins.get("ContextualBalloon"); const i = vI(t, e); n.updatePosition(i) } function vI(t, e) { const n = t.editing.view; const i = Uv.defaultPositions; return { target: n.domConverter.mapViewToDom(e), positions: [i.northArrowSouth, i.northArrowSouthWest, i.northArrowSouthEast, i.southArrowNorth, i.southArrowNorthWest, i.southArrowNorthEast, i.viewportStickyNorth] } } function yI(t) { const e = t.getSelectedElement(); return !!(e && SD(e)) } class xI extends (ft()) { constructor(t) { super(); this.set("activeHandlePosition", null); this.set("proposedWidthPercents", null); this.set("proposedWidth", null); this.set("proposedHeight", null); this.set("proposedHandleHostWidth", null); this.set("proposedHandleHostHeight", null); this._options = t; this._referenceCoordinates = null } get originalWidth() { return this._originalWidth } get originalHeight() { return this._originalHeight } get originalWidthPercents() { return this._originalWidthPercents } get aspectRatio() { return this._aspectRatio } begin(t, e, n) { const i = new lc(e); this.activeHandlePosition = TI(t); this._referenceCoordinates = DI(e, MI(this.activeHandlePosition)); this._originalWidth = i.width; this._originalHeight = i.height; this._aspectRatio = i.width / i.height; const o = n.style.width; if (o && o.match(/^\d+(\.\d*)?%$/)) { this._originalWidthPercents = parseFloat(o) } else { this._originalWidthPercents = EI(n, i) } } update(t) { this.proposedWidth = t.width; this.proposedHeight = t.height; this.proposedWidthPercents = t.widthPercents; this.proposedHandleHostWidth = t.handleHostWidth; this.proposedHandleHostHeight = t.handleHostHeight } } function EI(t, e) { const n = t.parentElement; let i = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width); const o = 5; let r = 0; let s = n; while (isNaN(i)) { s = s.parentElement; if (++r > o) { return 0 } i = parseFloat(n.ownerDocument.defaultView.getComputedStyle(s).width) } return e.width / i * 100 } function DI(t, e) { const n = new lc(t); const i = e.split("-"); const o = { x: i[1] == "right" ? n.right : n.left, y: i[0] == "bottom" ? n.bottom : n.top }; o.x += t.ownerDocument.defaultView.scrollX; o.y += t.ownerDocument.defaultView.scrollY; return o } function II(t) { return `ck-widget__resizer__handle-${t}` } function TI(t) { const e = ["top-left", "top-right", "bottom-right", "bottom-left"]; for (const n of e) { if (t.classList.contains(II(n))) { return n } } } function MI(t) { const e = t.split("-"); const n = { top: "bottom", bottom: "top", left: "right", right: "left" }; return `${n[e[0]]}-${n[e[1]]}` } class SI extends Nl { constructor() { super(); const t = this.bindTemplate; this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-size-view", t.to("_viewPosition", (t => t ? `ck-orientation-${t}` : ""))], style: { display: t.if("_isVisible", "none", (t => !t)) } }, children: [{ text: t.to("_label") }] }) } _bindToState(t, e) { this.bind("_isVisible").to(e, "proposedWidth", e, "proposedHeight", ((t, e) => t !== null && e !== null)); this.bind("_label").to(e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", e, "proposedWidthPercents", ((e, n, i) => { if (t.unit === "px") { return `${e}×${n}` } else { return `${i}%` } })); this.bind("_viewPosition").to(e, "activeHandlePosition", e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", ((t, e, n) => e < 50 || n < 50 ? "above-center" : t)) } _dismiss() { this.unbind(); this._isVisible = false } } class NI extends (ft()) { constructor(t) { super(); this._viewResizerWrapper = null; this._options = t; this.set("isEnabled", true); this.set("isSelected", false); this.bind("isVisible").to(this, "isEnabled", this, "isSelected", ((t, e) => t && e)); this.decorate("begin"); this.decorate("cancel"); this.decorate("commit"); this.decorate("updateSize"); this.on("commit", (t => { if (!this.state.proposedWidth && !this.state.proposedWidthPercents) { this._cleanup(); t.stop() } }), { priority: "high" }) } get state() { return this._state } show() { const t = this._options.editor.editing.view; t.change((t => { t.removeClass("ck-hidden", this._viewResizerWrapper) })) } hide() { const t = this._options.editor.editing.view; t.change((t => { t.addClass("ck-hidden", this._viewResizerWrapper) })) } attach() { const t = this; const e = this._options.viewElement; const n = this._options.editor.editing.view; n.change((n => { const i = n.createUIElement("div", { class: "ck ck-reset_all ck-widget__resizer" }, (function (e) { const n = this.toDomElement(e); t._appendHandles(n); t._appendSizeUI(n); return n })); n.insert(n.createPositionAt(e, "end"), i); n.addClass("ck-widget_with-resizer", e); this._viewResizerWrapper = i; if (!this.isVisible) { this.hide() } })); this.on("change:isVisible", (() => { if (this.isVisible) { this.show(); this.redraw() } else { this.hide() } })) } begin(t) { this._state = new xI(this._options); this._sizeView._bindToState(this._options, this.state); this._initialViewWidth = this._options.viewElement.getStyle("width"); this.state.begin(t, this._getHandleHost(), this._getResizeHost()) } updateSize(t) { const e = this._proposeNewSize(t); const n = this._options.editor.editing.view; n.change((t => { const n = this._options.unit || "%"; const i = (n === "%" ? e.widthPercents : e.width) + n; t.setStyle("width", i, this._options.viewElement) })); const i = this._getHandleHost(); const o = new lc(i); const r = Math.round(o.width); const s = Math.round(o.height); const a = new lc(i); e.width = Math.round(a.width); e.height = Math.round(a.height); this.redraw(o); this.state.update({ ...e, handleHostWidth: r, handleHostHeight: s }) } commit() { const t = this._options.unit || "%"; const e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t; this._options.editor.editing.view.change((() => { this._cleanup(); this._options.onCommit(e) })) } cancel() { this._cleanup() } destroy() { this.cancel() } redraw(t) { const e = this._domResizerWrapper; if (!PI(e)) { return } const n = e.parentElement; const i = this._getHandleHost(); const o = this._viewResizerWrapper; const r = [o.getStyle("width"), o.getStyle("height"), o.getStyle("left"), o.getStyle("top")]; let s; if (n.isSameNode(i)) { const e = t || new lc(i); s = [e.width + "px", e.height + "px", undefined, undefined] } else { s = [i.offsetWidth + "px", i.offsetHeight + "px", i.offsetLeft + "px", i.offsetTop + "px"] } if (Et(r, s) !== "same") { this._options.editor.editing.view.change((t => { t.setStyle({ width: s[0], height: s[1], left: s[2], top: s[3] }, o) })) } } containsHandle(t) { return this._domResizerWrapper.contains(t) } static isResizeHandle(t) { return t.classList.contains("ck-widget__resizer__handle") } _cleanup() { this._sizeView._dismiss(); const t = this._options.editor.editing.view; t.change((t => { t.setStyle("width", this._initialViewWidth, this._options.viewElement) })) } _proposeNewSize(t) { const e = this.state; const n = zI(t); const i = this._options.isCentered ? this._options.isCentered(this) : true; const o = { x: e._referenceCoordinates.x - (n.x + e.originalWidth), y: n.y - e.originalHeight - e._referenceCoordinates.y }; if (i && e.activeHandlePosition.endsWith("-right")) { o.x = n.x - (e._referenceCoordinates.x + e.originalWidth) } if (i) { o.x *= 2 } let r = Math.abs(e.originalWidth + o.x); let s = Math.abs(e.originalHeight + o.y); const a = r / e.aspectRatio > s ? "width" : "height"; if (a == "width") { s = r / e.aspectRatio } else { r = s * e.aspectRatio } return { width: Math.round(r), height: Math.round(s), widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * r * 100) / 100, 100) } } _getResizeHost() { const t = this._domResizerWrapper.parentElement; return this._options.getResizeHost(t) } _getHandleHost() { const t = this._domResizerWrapper.parentElement; return this._options.getHandleHost(t) } get _domResizerWrapper() { return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper) } _appendHandles(t) { const e = ["top-left", "top-right", "bottom-right", "bottom-left"]; for (const n of e) { t.appendChild(new zl({ tag: "div", attributes: { class: `ck-widget__resizer__handle ${BI(n)}` } }).render()) } } _appendSizeUI(t) { this._sizeView = new SI; this._sizeView.render(); t.appendChild(this._sizeView.element) } } function BI(t) { return `ck-widget__resizer__handle-${t}` } function zI(t) { return { x: t.pageX, y: t.pageY } } function PI(t) { return t && t.ownerDocument && t.ownerDocument.contains(t) } var LI = n(2263); var OI = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; OI.insert = "head"; OI.singleton = true; var RI = Dl()(LI.Z, OI); const jI = LI.Z.locals || {}; class VI extends Kd { constructor() { super(...arguments); this._resizers = new Map } static get pluginName() { return "WidgetResize" } init() { const t = this.editor.editing; const e = nc.window.document; this.set("selectedResizer", null); this.set("_activeResizer", null); t.view.addObserver(kA); this._observer = new (Za()); this.listenTo(t.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }); this._observer.listenTo(e, "mousemove", this._mouseMoveListener.bind(this)); this._observer.listenTo(e, "mouseup", this._mouseUpListener.bind(this)); this._redrawSelectedResizerThrottled = Sx((() => this.redrawSelectedResizer()), 200); this.editor.ui.on("update", this._redrawSelectedResizerThrottled); this.editor.model.document.on("change", (() => { for (const [t, e] of this._resizers) { if (!t.isAttached()) { this._resizers.delete(t); e.destroy() } } }), { priority: "lowest" }); this._observer.listenTo(nc.window, "resize", this._redrawSelectedResizerThrottled); const n = this.editor.editing.view.document.selection; n.on("change", (() => { const t = n.getSelectedElement(); const e = this.getResizerByViewElement(t) || null; if (e) { this.select(e) } else { this.deselect() } })) } redrawSelectedResizer() { if (this.selectedResizer && this.selectedResizer.isVisible) { this.selectedResizer.redraw() } } destroy() { super.destroy(); this._observer.stopListening(); for (const t of this._resizers.values()) { t.destroy() } this._redrawSelectedResizerThrottled.cancel() } select(t) { this.deselect(); this.selectedResizer = t; this.selectedResizer.isSelected = true } deselect() { if (this.selectedResizer) { this.selectedResizer.isSelected = false } this.selectedResizer = null } attachTo(t) { const e = new NI(t); const n = this.editor.plugins; e.attach(); if (n.has("WidgetToolbarRepository")) { const t = n.get("WidgetToolbarRepository"); e.on("begin", (() => { t.forceDisabled("resize") }), { priority: "lowest" }); e.on("cancel", (() => { t.clearForceDisabled("resize") }), { priority: "highest" }); e.on("commit", (() => { t.clearForceDisabled("resize") }), { priority: "highest" }) } this._resizers.set(t.viewElement, e); const i = this.editor.editing.view.document.selection; const o = i.getSelectedElement(); if (this.getResizerByViewElement(o) == e) { this.select(e) } return e } getResizerByViewElement(t) { return this._resizers.get(t) } _getResizerByHandle(t) { for (const e of this._resizers.values()) { if (e.containsHandle(t)) { return e } } } _mouseDownListener(t, e) { const n = e.domTarget; if (!NI.isResizeHandle(n)) { return } this._activeResizer = this._getResizerByHandle(n) || null; if (this._activeResizer) { this._activeResizer.begin(n); t.stop(); e.preventDefault() } } _mouseMoveListener(t, e) { if (this._activeResizer) { this._activeResizer.updateSize(e) } } _mouseUpListener() { if (this._activeResizer) { this._activeResizer.commit(); this._activeResizer = null } } } var FI = n(390); var HI = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; HI.insert = "head"; HI.singleton = true; var UI = Dl()(FI.Z, HI); const WI = FI.Z.locals || {}; class GI extends Kd { static get pluginName() { return "DragDrop" } static get requires() { return [vD, bI] } init() { const t = this.editor; const e = t.editing.view; this._draggedRange = null; this._draggingUid = ""; this._draggableElement = null; this._updateDropMarkerThrottled = Sx((t => this._updateDropMarker(t)), 40); this._removeDropMarkerDelayed = XI((() => this._removeDropMarker()), 40); this._clearDraggableAttributesDelayed = XI((() => this._clearDraggableAttributes()), 40); e.addObserver(kD); e.addObserver(kA); this._setupDragging(); this._setupContentInsertionIntegration(); this._setupClipboardInputIntegration(); this._setupDropMarker(); this._setupDraggableAttributeHandling(); this.listenTo(t, "change:isReadOnly", ((t, e, n) => { if (n) { this.forceDisabled("readOnlyMode") } else { this.clearForceDisabled("readOnlyMode") } })); this.on("change:isEnabled", ((t, e, n) => { if (!n) { this._finalizeDragging(false) } })); if (l.isAndroid) { this.forceDisabled("noAndroidSupport") } } destroy() { if (this._draggedRange) { this._draggedRange.detach(); this._draggedRange = null } this._updateDropMarkerThrottled.cancel(); this._removeDropMarkerDelayed.cancel(); this._clearDraggableAttributesDelayed.cancel(); return super.destroy() } _setupDragging() { const t = this.editor; const e = t.model; const n = e.document; const i = t.editing.view; const o = i.document; this.listenTo(o, "dragstart", ((i, r) => { const s = n.selection; if (r.target && r.target.is("editableElement")) { r.preventDefault(); return } const a = r.target ? tT(r.target) : null; if (a) { const n = t.editing.mapper.toModelElement(a); this._draggedRange = mk.fromRange(e.createRangeOn(n)); if (t.plugins.has("WidgetToolbarRepository")) { const e = t.plugins.get("WidgetToolbarRepository"); e.forceDisabled("dragDrop") } } else if (!o.selection.isCollapsed) { const t = o.selection.getSelectedElement(); if (!t || !SD(t)) { this._draggedRange = mk.fromRange(s.getFirstRange()) } } if (!this._draggedRange) { r.preventDefault(); return } this._draggingUid = T(); r.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy"; r.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid); const c = e.createSelection(this._draggedRange.toRange()); const l = t.data.toView(e.getSelectedContent(c)); o.fire("clipboardOutput", { dataTransfer: r.dataTransfer, content: l, method: "dragstart" }); if (!this.isEnabled) { this._draggedRange.detach(); this._draggedRange = null; this._draggingUid = "" } }), { priority: "low" }); this.listenTo(o, "dragend", ((t, e) => { this._finalizeDragging(!e.dataTransfer.isCanceled && e.dataTransfer.dropEffect == "move") }), { priority: "low" }); this.listenTo(o, "dragenter", (() => { if (!this.isEnabled) { return } i.focus() })); this.listenTo(o, "dragleave", (() => { this._removeDropMarkerDelayed() })); this.listenTo(o, "dragging", ((e, n) => { if (!this.isEnabled) { n.dataTransfer.dropEffect = "none"; return } this._removeDropMarkerDelayed.cancel(); const i = qI(t, n.targetRanges, n.target); if (!this._draggedRange) { n.dataTransfer.dropEffect = "copy" } if (!l.isGecko) { if (n.dataTransfer.effectAllowed == "copy") { n.dataTransfer.dropEffect = "copy" } else if (["all", "copyMove"].includes(n.dataTransfer.effectAllowed)) { n.dataTransfer.dropEffect = "move" } } if (i) { this._updateDropMarkerThrottled(i) } }), { priority: "low" }) } _setupClipboardInputIntegration() { const t = this.editor; const e = t.editing.view; const n = e.document; this.listenTo(n, "clipboardInput", ((e, n) => { if (n.method != "drop") { return } const i = qI(t, n.targetRanges, n.target); this._removeDropMarker(); if (!i) { this._finalizeDragging(false); e.stop(); return } if (this._draggedRange && this._draggingUid != n.dataTransfer.getData("application/ckeditor5-dragging-uid")) { this._draggedRange.detach(); this._draggedRange = null; this._draggingUid = "" } const o = JI(n.dataTransfer) == "move"; if (o && this._draggedRange && this._draggedRange.containsRange(i, true)) { this._finalizeDragging(false); e.stop(); return } n.targetRanges = [t.editing.mapper.toViewRange(i)] }), { priority: "high" }) } _setupContentInsertionIntegration() { const t = this.editor.plugins.get(vD); t.on("contentInsertion", ((t, e) => { if (!this.isEnabled || e.method !== "drop") { return } const n = e.targetRanges.map((t => this.editor.editing.mapper.toModelRange(t))); this.editor.model.change((t => t.setSelection(n))) }), { priority: "high" }); t.on("contentInsertion", ((t, e) => { if (!this.isEnabled || e.method !== "drop") { return } const n = JI(e.dataTransfer) == "move"; const i = !e.resultRange || !e.resultRange.isCollapsed; this._finalizeDragging(i && n) }), { priority: "lowest" }) } _setupDraggableAttributeHandling() { const t = this.editor; const e = t.editing.view; const n = e.document; this.listenTo(n, "mousedown", ((i, o) => { if (l.isAndroid || !o) { return } this._clearDraggableAttributesDelayed.cancel(); let r = tT(o.target); if (l.isBlink && !t.isReadOnly && !r && !n.selection.isCollapsed) { const t = n.selection.getSelectedElement(); if (!t || !SD(t)) { r = n.selection.editableElement } } if (r) { e.change((t => { t.setAttribute("draggable", "true", r) })); this._draggableElement = t.editing.mapper.toModelElement(r) } })); this.listenTo(n, "mouseup", (() => { if (!l.isAndroid) { this._clearDraggableAttributesDelayed() } })) } _clearDraggableAttributes() { const t = this.editor.editing; t.view.change((e => { if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") { e.removeAttribute("draggable", t.mapper.toViewElement(this._draggableElement)) } this._draggableElement = null })) } _setupDropMarker() { const t = this.editor; t.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }); t.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (e, { writer: n }) => { const i = t.model.schema.checkChild(e.markerRange.start, "$text"); if (!i) { return } return n.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, (function (t) { const e = this.toDomElement(t); e.append("⁠", t.createElement("span"), "⁠"); return e })) } }) } _updateDropMarker(t) { const e = this.editor; const n = e.model.markers; e.model.change((e => { if (n.has("drop-target")) { if (!n.get("drop-target").getRange().isEqual(t)) { e.updateMarker("drop-target", { range: t }) } } else { e.addMarker("drop-target", { range: t, usingOperation: false, affectsData: false }) } })) } _removeDropMarker() { const t = this.editor.model; this._removeDropMarkerDelayed.cancel(); this._updateDropMarkerThrottled.cancel(); if (t.markers.has("drop-target")) { t.change((t => { t.removeMarker("drop-target") })) } } _finalizeDragging(t) { const e = this.editor; const n = e.model; this._removeDropMarker(); this._clearDraggableAttributes(); if (e.plugins.has("WidgetToolbarRepository")) { const t = e.plugins.get("WidgetToolbarRepository"); t.clearForceDisabled("dragDrop") } this._draggingUid = ""; if (!this._draggedRange) { return } if (t && this.isEnabled) { n.deleteContent(n.createSelection(this._draggedRange), { doNotAutoparagraph: true }) } this._draggedRange.detach(); this._draggedRange = null } } function qI(t, e, n) { const i = t.model; const o = t.editing.mapper; let r = null; const s = e ? e[0].start : null; if (n.is("uiElement")) { n = n.parent } r = YI(t, n); if (r) { return r } const a = ZI(t, n); const c = s ? o.toModelPosition(s) : null; if (!c) { return $I(t, a) } r = QI(t, c, a); if (r) { return r } r = i.schema.getNearestSelectionRange(c, l.isGecko ? "forward" : "backward"); if (r) { return r } return KI(t, c.parent) } function YI(t, e) { const n = t.model; const i = t.editing.mapper; if (SD(e)) { return n.createRangeOn(i.toModelElement(e)) } if (!e.is("editableElement")) { const t = e.findAncestor((t => SD(t) || t.is("editableElement"))); if (SD(t)) { return n.createRangeOn(i.toModelElement(t)) } } return null } function $I(t, e) { const n = t.model; const i = n.schema; const o = n.createPositionAt(e, 0); return i.getNearestSelectionRange(o, "forward") } function QI(t, e, n) { const i = t.model; if (!i.schema.checkChild(n, "$block")) { return null } const o = i.createPositionAt(n, 0); const r = e.path.slice(0, o.path.length); const s = i.createPositionFromPath(e.root, r); const a = s.nodeAfter; if (a && i.schema.isObject(a)) { return i.createRangeOn(a) } return null } function KI(t, e) { const n = t.model; let i = e; while (i) { if (n.schema.isObject(i)) { return n.createRangeOn(i) } i = i.parent } return null } function ZI(t, e) { const n = t.editing.mapper; const i = t.editing.view; const o = n.toModelElement(e); if (o) { return o } const r = i.createPositionBefore(e); const s = n.findMappedViewAncestor(r); return n.toModelElement(s) } function JI(t) { if (l.isGecko) { return t.dropEffect } return ["all", "copyMove"].includes(t.effectAllowed) ? "move" : "copy" } function XI(t, e) { let n; function i(...o) { i.cancel(); n = setTimeout((() => t(...o)), e) } i.cancel = () => { clearTimeout(n) }; return i } function tT(t) { if (t.is("editableElement")) { return null } if (t.hasClass("ck-widget__selection-handle")) { return t.findAncestor(SD) } if (SD(t)) { return t } const e = t.findAncestor((t => SD(t) || t.is("editableElement"))); if (SD(e)) { return e } return null } class eT extends Kd { static get pluginName() { return "PastePlainText" } static get requires() { return [vD] } init() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = n.document; const o = e.document.selection; let r = false; n.addObserver(kD); this.listenTo(i, "keydown", ((t, e) => { r = e.shiftKey })); t.plugins.get(vD).on("contentInsertion", ((t, n) => { if (!r && !nT(n.content, e.schema)) { return } e.change((t => { const i = Array.from(o.getAttributes()).filter((([t]) => e.schema.getAttributeProperties(t).isFormatting)); if (!o.isCollapsed) { e.deleteContent(o, { doNotAutoparagraph: true }) } i.push(...o.getAttributes()); const r = t.createRangeIn(n.content); for (const e of r.getItems()) { if (e.is("$textProxy")) { t.setAttributes(i, e) } } })) })) } } function nT(t, e) { if (t.childCount > 1) { return false } const n = t.getChild(0); if (e.isObject(n)) { return false } return Array.from(n.getAttributeKeys()).length == 0 } class iT extends Kd { static get pluginName() { return "Clipboard" } static get requires() { return [vD, GI, eT] } } class oT extends Jd { constructor(t) { super(t); this.affectsData = false } execute() { const t = this.editor.model; const e = t.document.selection; let n = t.schema.getLimitElement(e); if (e.containsEntireContent(n) || !rT(t.schema, n)) { do { n = n.parent; if (!n) { return } } while (!rT(t.schema, n)) } t.change((t => { t.setSelection(n, "in") })) } } function rT(t, e) { return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph")) } const sT = Wc("Ctrl+A"); class aT extends Kd { static get pluginName() { return "SelectAllEditing" } init() { const t = this.editor; const e = t.editing.view; const n = e.document; t.commands.add("selectAll", new oT(t)); this.listenTo(n, "keydown", ((e, n) => { if (Uc(n) === sT) { t.execute("selectAll"); n.preventDefault() } })) } } const cT = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>'; class lT extends Kd { static get pluginName() { return "SelectAllUI" } init() { const t = this.editor; t.ui.componentFactory.add("selectAll", (e => { const n = t.commands.get("selectAll"); const i = new kd(e); const o = e.t; i.set({ label: o("Select all"), icon: cT, keystroke: "Ctrl+A", tooltip: true }); i.bind("isEnabled").to(n, "isEnabled"); this.listenTo(i, "execute", (() => { t.execute("selectAll"); t.editing.view.focus() })); return i })) } } class dT extends Kd { static get requires() { return [aT, lT] } static get pluginName() { return "SelectAll" } } class uT extends Jd { constructor(t) { super(t); this._stack = []; this._createdBatches = new WeakSet; this.refresh(); this.listenTo(t.data, "set", ((t, e) => { e[1] = { ...e[1] }; const n = e[1]; if (!n.batchType) { n.batchType = { isUndoable: false } } }), { priority: "high" }); this.listenTo(t.data, "set", ((t, e) => { const n = e[1]; if (!n.batchType.isUndoable) { this.clearStack() } })) } refresh() { this.isEnabled = this._stack.length > 0 } get createdBatches() { return this._createdBatches } addBatch(t) { const e = this.editor.model.document.selection; const n = { ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward }; this._stack.push({ batch: t, selection: n }); this.refresh() } clearStack() { this._stack = []; this.refresh() } _restoreSelection(t, e, n) { const i = this.editor.model; const o = i.document; const r = []; const s = t.map((t => t.getTransformedByOperations(n))); const a = s.flat(); for (const t of s) { const e = t.filter((t => t.root != o.graveyard)).filter((t => !fT(t, a))); if (!e.length) { continue } hT(e); r.push(e[0]) } if (r.length) { i.change((t => { t.setSelection(r, { backward: e }) })) } } _undo(t, e) { const n = this.editor.model; const i = n.document; this._createdBatches.add(e); const o = t.operations.slice().filter((t => t.isDocumentOperation)); o.reverse(); for (const t of o) { const o = t.baseVersion + 1; const r = Array.from(i.history.getOperations(o)); const s = s_([t.getReversed()], r, { useRelations: true, document: this.editor.model.document, padWithNoOps: false, forceWeakRemove: true }); const a = s.operationsA; for (const o of a) { e.addOperation(o); n.applyOperation(o); i.history.setOperationAsUndone(t, o) } } } } function hT(t) { t.sort(((t, e) => t.start.isBefore(e.start) ? -1 : 1)); for (let e = 1; e < t.length; e++) { const n = t[e - 1]; const i = n.getJoined(t[e], true); if (i) { e--; t.splice(e, 2, i) } } } function fT(t, e) { return e.some((e => e !== t && e.containsRange(t, true))) } class gT extends uT { execute(t = null) { const e = t ? this._stack.findIndex((e => e.batch == t)) : this._stack.length - 1; const n = this._stack.splice(e, 1)[0]; const i = this.editor.model.createBatch({ isUndo: true }); this.editor.model.enqueueChange(i, (() => { this._undo(n.batch, i); const t = this.editor.model.document.history.getOperations(n.batch.baseVersion); this._restoreSelection(n.selection.ranges, n.selection.isBackward, t); this.fire("revert", n.batch, i) })); this.refresh() } } class mT extends uT { execute() { const t = this._stack.pop(); const e = this.editor.model.createBatch({ isUndo: true }); this.editor.model.enqueueChange(e, (() => { const n = t.batch.operations[t.batch.operations.length - 1]; const i = n.baseVersion + 1; const o = this.editor.model.document.history.getOperations(i); this._restoreSelection(t.selection.ranges, t.selection.isBackward, o); this._undo(t.batch, e) })); this.refresh() } } class pT extends Kd { constructor() { super(...arguments); this._batchRegistry = new WeakSet } static get pluginName() { return "UndoEditing" } init() { const t = this.editor; this._undoCommand = new gT(t); this._redoCommand = new mT(t); t.commands.add("undo", this._undoCommand); t.commands.add("redo", this._redoCommand); this.listenTo(t.model, "applyOperation", ((t, e) => { const n = e[0]; if (!n.isDocumentOperation) { return } const i = n.batch; const o = this._redoCommand.createdBatches.has(i); const r = this._undoCommand.createdBatches.has(i); const s = this._batchRegistry.has(i); if (s) { return } this._batchRegistry.add(i); if (!i.isUndoable) { return } if (o) { this._undoCommand.addBatch(i) } else if (!r) { this._undoCommand.addBatch(i); this._redoCommand.clearStack() } }), { priority: "highest" }); this.listenTo(this._undoCommand, "revert", ((t, e, n) => { this._redoCommand.addBatch(n) })); t.keystrokes.set("CTRL+Z", "undo"); t.keystrokes.set("CTRL+Y", "redo"); t.keystrokes.set("CTRL+SHIFT+Z", "redo") } } const kT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>'; const bT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>'; class wT extends Kd { static get pluginName() { return "UndoUI" } init() { const t = this.editor; const e = t.locale; const n = t.t; const i = e.uiLanguageDirection == "ltr" ? kT : bT; const o = e.uiLanguageDirection == "ltr" ? bT : kT; this._addButton("undo", n("Undo"), "CTRL+Z", i); this._addButton("redo", n("Redo"), "CTRL+Y", o) } _addButton(t, e, n, i) { const o = this.editor; o.ui.componentFactory.add(t, (r => { const s = o.commands.get(t); const a = new kd(r); a.set({ label: e, icon: i, keystroke: n, tooltip: true }); a.bind("isEnabled").to(s, "isEnabled"); this.listenTo(a, "execute", (() => { o.execute(t); o.editing.view.focus() })); return a })) } } class _T extends Kd { static get requires() { return [pT, wT] } static get pluginName() { return "Undo" } } class AT extends Kd { static get requires() { return [iT, aE, dT, fE, NE, _T] } static get pluginName() { return "Essentials" } } var CT = n(1590); var vT = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; vT.insert = "head"; vT.singleton = true; var yT = Dl()(CT.Z, vT); const xT = CT.Z.locals || {}; var ET = n(9289); var DT = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; DT.insert = "head"; DT.singleton = true; var IT = Dl()(ET.Z, DT); const TT = ET.Z.locals || {}; class MT extends Nl { constructor(t) { super(t); const e = t.t; this.set("matchCount", 0); this.set("highlightOffset", 0); this.set("isDirty", false); this.set("_areCommandsEnabled", {}); this.set("_resultsCounterText", ""); this.set("_matchCase", false); this.set("_wholeWordsOnly", false); this.bind("_searchResultsFound").to(this, "matchCount", this, "isDirty", ((t, e) => t > 0 && !e)); this._findInputView = this._createInputField(e("Find in text…")); this._replaceInputView = this._createInputField(e("Replace with…")); this._findButtonView = this._createButton({ label: e("Find"), class: "ck-button-find ck-button-action", withText: true }); this._findPrevButtonView = this._createButton({ label: e("Previous result"), class: "ck-button-prev", icon: jy, keystroke: "Shift+F3", tooltip: true }); this._findNextButtonView = this._createButton({ label: e("Next result"), class: "ck-button-next", icon: jy, keystroke: "F3", tooltip: true }); this._optionsDropdown = this._createOptionsDropdown(); this._replaceButtonView = this._createButton({ label: e("Replace"), class: "ck-button-replace", withText: true }); this._replaceAllButtonView = this._createButton({ label: e("Replace all"), class: "ck-button-replaceall", withText: true }); this._findFieldsetView = this._createFindFieldset(); this._replaceFieldsetView = this._createReplaceFieldset(); this._focusTracker = new dl; this._keystrokes = new ul; this._focusables = new yl; this._focusCycler = new Wd({ focusables: this._focusables, focusTracker: this._focusTracker, keystrokeHandler: this._keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-find-and-replace-form"], tabindex: "-1" }, children: [new wy(t, { label: e("Find and replace") }), this._findFieldsetView, this._replaceFieldsetView] }) } render() { super.render(); o({ view: this }); this._initFocusCycling(); this._initKeystrokeHandling() } destroy() { super.destroy(); this._focusTracker.destroy(); this._keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } reset() { this._findInputView.errorText = null; this.isDirty = true } get _textToFind() { return this._findInputView.fieldView.element.value } get _textToReplace() { return this._replaceInputView.fieldView.element.value } _createFindFieldset() { const t = this.locale; const e = new Nl(t); this._findInputView.fieldView.on("input", (() => { this.isDirty = true })); this._findButtonView.on("execute", this._onFindButtonExecute.bind(this)); this._findPrevButtonView.delegate("execute").to(this, "findPrevious"); this._findNextButtonView.delegate("execute").to(this, "findNext"); this._findPrevButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", (({ findPrevious: t }) => t)); this._findNextButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", (({ findNext: t }) => t)); this._injectFindResultsCounter(); e.setTemplate({ tag: "fieldset", attributes: { class: ["ck", "ck-find-and-replace-form__find"] }, children: [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView] }); return e } _onFindButtonExecute() { if (!this._textToFind) { const t = this.t; this._findInputView.errorText = t("Text to find must not be empty."); return } this.isDirty = false; this.fire("findNext", { searchText: this._textToFind, matchCase: this._matchCase, wholeWords: this._wholeWordsOnly }) } _injectFindResultsCounter() { const t = this.locale; const e = t.t; const n = this.bindTemplate; const i = new Nl(this.locale); this.bind("_resultsCounterText").to(this, "highlightOffset", this, "matchCount", ((t, n) => e("%0 of %1", [t, n]))); i.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-results-counter", n.if("isDirty", "ck-hidden")] }, children: [{ text: n.to("_resultsCounterText") }] }); const o = () => { const e = this._findInputView.fieldView.element; if (!e || !wc(e)) { return } const n = new lc(i.element).width; const o = t.uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft"; if (!n) { e.style[o] = "" } else { e.style[o] = `calc( 2 * var(--ck-spacing-standard) + ${n}px )` } }; this.on("change:_resultsCounterText", o, { priority: "low" }); this.on("change:isDirty", o, { priority: "low" }); this._findInputView.template.children[0].children.push(i) } _createReplaceFieldset() { const t = this.locale; const e = t.t; const n = new Nl(this.locale); this._replaceButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({ replace: t }, e) => t && e)); this._replaceAllButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({ replaceAll: t }, e) => t && e)); this._replaceInputView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", (({ replace: t }, e) => t && e)); this._replaceInputView.bind("infoText").to(this._replaceInputView, "isEnabled", this._replaceInputView, "isFocused", ((t, n) => { if (t || !n) { return "" } return e("Tip: Find some text first in order to replace it.") })); this._replaceButtonView.on("execute", (() => { this.fire("replace", { searchText: this._textToFind, replaceText: this._textToReplace }) })); this._replaceAllButtonView.on("execute", (() => { this.fire("replaceAll", { searchText: this._textToFind, replaceText: this._textToReplace }); this.focus() })); n.setTemplate({ tag: "fieldset", attributes: { class: ["ck", "ck-find-and-replace-form__replace"] }, children: [this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView] }); return n } _createOptionsDropdown() { const t = this.locale; const e = t.t; const n = yv(this.locale); n.class = "ck-options-dropdown"; n.buttonView.set({ withText: false, label: e("Show options"), icon: JC.cog, tooltip: true }); const i = new Ry({ withText: true, label: e("Match case"), _isMatchCaseSwitch: true }); const o = new Ry({ withText: true, label: e("Whole words only") }); i.bind("isOn").to(this, "_matchCase"); o.bind("isOn").to(this, "_wholeWordsOnly"); n.on("execute", (t => { if (t.source._isMatchCaseSwitch) { this._matchCase = !this._matchCase } else { this._wholeWordsOnly = !this._wholeWordsOnly } this.isDirty = true })); Dv(n, new cl([{ type: "switchbutton", model: i }, { type: "switchbutton", model: o }])); return n } _initFocusCycling() { const t = [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView, this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView]; t.forEach((t => { this._focusables.add(t); this._focusTracker.add(t.element) })) } _initKeystrokeHandling() { const t = t => t.stopPropagation(); const e = t => { t.stopPropagation(); t.preventDefault() }; this._keystrokes.listenTo(this.element); this._keystrokes.set("f3", (t => { e(t); this._findNextButtonView.fire("execute") })); this._keystrokes.set("shift+f3", (t => { e(t); this._findPrevButtonView.fire("execute") })); this._keystrokes.set("enter", (t => { const n = t.target; if (n === this._findInputView.fieldView.element) { if (this._areCommandsEnabled.findNext) { this._findNextButtonView.fire("execute") } else { this._findButtonView.fire("execute") } e(t) } else if (n === this._replaceInputView.fieldView.element && !this.isDirty) { this._replaceButtonView.fire("execute"); e(t) } })); this._keystrokes.set("shift+enter", (t => { const n = t.target; if (n !== this._findInputView.fieldView.element) { return } if (this._areCommandsEnabled.findPrevious) { this._findPrevButtonView.fire("execute") } else { this._findButtonView.fire("execute") } e(t) })); this._keystrokes.set("arrowright", t); this._keystrokes.set("arrowleft", t); this._keystrokes.set("arrowup", t); this._keystrokes.set("arrowdown", t); this.listenTo(this._findInputView.element, "selectstart", ((t, e) => { e.stopPropagation() }), { priority: "high" }); this.listenTo(this._replaceInputView.element, "selectstart", ((t, e) => { e.stopPropagation() }), { priority: "high" }) } _createButton(t) { const e = new kd(this.locale); e.set(t); return e } _createInputField(t) { const e = new By(this.locale, zy); e.label = t; return e } } const ST = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z"/></svg>'; class NT extends Kd { static get pluginName() { return "FindAndReplaceUI" } constructor(t) { super(t); this.formView = null } init() { const t = this.editor; t.ui.componentFactory.add("findAndReplace", (n => { const i = yv(n); const o = t.commands.get("find"); i.bind("isEnabled").to(o); i.once("change:isOpen", (() => { this.formView = new (e(MT))(t.locale); i.panelView.children.add(this.formView); this._setupFormView(this.formView) })); i.on("change:isOpen", ((t, e, n) => { if (n) { this.formView.disableCssTransitions(); this.formView.reset(); this.formView._findInputView.fieldView.select(); this.formView.enableCssTransitions() } else { this.fire("searchReseted") } }), { priority: "low" }); this._setupDropdownButton(i); return i })) } _setupDropdownButton(t) { const e = this.editor; const n = e.locale.t; t.buttonView.set({ icon: ST, label: n("Find and replace"), keystroke: "CTRL+F", tooltip: true }); e.keystrokes.set("Ctrl+F", ((e, n) => { if (t.isEnabled) { t.isOpen = true; n() } })) } _setupFormView(t) { const e = this.editor; const n = e.commands; const i = this.editor.plugins.get("FindAndReplaceEditing"); const o = i.state; const r = { before: -1, same: 0, after: 1, different: 1 }; t.bind("highlightOffset").to(o, "highlightedResult", (t => { if (!t) { return 0 } return Array.from(o.results).sort(((t, e) => r[t.marker.getStart().compareWith(e.marker.getStart())])).indexOf(t) + 1 })); t.listenTo(o.results, "change", (() => { t.matchCount = o.results.length })); const s = n.get("findNext"); const a = n.get("findPrevious"); const c = n.get("replace"); const l = n.get("replaceAll"); t.bind("_areCommandsEnabled").to(s, "isEnabled", a, "isEnabled", c, "isEnabled", l, "isEnabled", ((t, e, n, i) => ({ findNext: t, findPrevious: e, replace: n, replaceAll: i }))); t.delegate("findNext", "findPrevious", "replace", "replaceAll").to(this); t.on("change:isDirty", ((t, e, n) => { if (n) { this.fire("searchReseted") } })) } } class BT extends Jd { constructor(t, e) { super(t); this.isEnabled = true; this.affectsData = false; this._state = e } execute(t, { matchCase: e, wholeWords: n } = {}) { const { editor: i } = this; const { model: o } = i; const r = i.plugins.get("FindAndReplaceUtils"); let s; if (typeof t === "string") { s = r.findByTextCallback(t, { matchCase: e, wholeWords: n }); this._state.searchText = t } else { s = t } const a = o.document.getRootNames().reduce(((t, e) => r.updateFindResultFromRange(o.createRangeIn(o.document.getRoot(e)), o, s, t)), null); this._state.clear(o); this._state.results.addMany(a); this._state.highlightedResult = a.get(0); if (typeof t === "string") { this._state.searchText = t } this._state.matchCase = !!e; this._state.matchWholeWords = !!n; return { results: a, findCallback: s } } } class zT extends Jd { constructor(t, e) { super(t); this.isEnabled = true; this._state = e } _replace(t, e) { const { model: n } = this.editor; n.change((i => { const o = e.marker.getRange(); if (o.root.rootName === "$graveyard") { this._state.results.remove(e); return } let r = {}; for (const t of o.getItems()) { if (t.is("$text") || t.is("$textProxy")) { r = t.getAttributes(); break } } n.insertContent(i.createText(t, r), o); if (this._state.results.has(e)) { this._state.results.remove(e) } })) } } class PT extends zT { execute(t, e) { this._replace(t, e) } } class LT extends zT { execute(t, e) { const { editor: n } = this; const { model: i } = n; const o = n.plugins.get("FindAndReplaceUtils"); const r = e instanceof cl ? e : i.document.getRootNames().reduce(((t, n) => o.updateFindResultFromRange(i.createRangeIn(i.document.getRoot(n)), i, o.findByTextCallback(e, this._state), t)), null); if (r.length) { [...r].forEach((e => { this._replace(t, e) })) } } } class OT extends Jd { constructor(t, e) { super(t); this.affectsData = false; this._state = e; this.isEnabled = false; this.listenTo(this._state.results, "change", (() => { this.isEnabled = this._state.results.length > 1 })) } refresh() { this.isEnabled = this._state.results.length > 1 } execute() { const t = this._state.results; const e = t.getIndex(this._state.highlightedResult); const n = e + 1 >= t.length ? 0 : e + 1; this._state.highlightedResult = this._state.results.get(n) } } class RT extends OT { execute() { const t = this._state.results; const e = t.getIndex(this._state.highlightedResult); const n = e - 1 < 0 ? this._state.results.length - 1 : e - 1; this._state.highlightedResult = this._state.results.get(n) } } class jT extends (ft()) { constructor(t) { super(); this.set("results", new cl); this.set("highlightedResult", null); this.set("searchText", ""); this.set("replaceText", ""); this.set("matchCase", false); this.set("matchWholeWords", false); this.results.on("change", ((e, { removed: n, index: i }) => { if (Array.from(n).length) { let e = false; t.change((i => { for (const o of n) { if (this.highlightedResult === o) { e = true } if (t.markers.has(o.marker.name)) { i.removeMarker(o.marker) } } })); if (e) { const t = i >= this.results.length ? 0 : i; this.highlightedResult = this.results.get(t) } } })) } clear(t) { this.searchText = ""; t.change((e => { if (this.highlightedResult) { const n = this.highlightedResult.marker.name.split(":")[1]; const i = t.markers.get(`findResultHighlighted:${n}`); if (i) { e.removeMarker(i) } } [...this.results].forEach((({ marker: t }) => { e.removeMarker(t) })) })); this.results.clear() } } var VT = /[\\^$.*+?()[\]{}|]/g, FT = RegExp(VT.source); function HT(t) { t = rh(t); return t && FT.test(t) ? t.replace(VT, "\\$&") : t } const UT = HT; class WT extends Kd { static get pluginName() { return "FindAndReplaceUtils" } updateFindResultFromRange(t, e, n, i) { const o = i || new cl; e.change((i => { [...t].forEach((({ type: t, item: r }) => { if (t === "elementStart") { if (e.schema.checkChild(r, "$text")) { const t = n({ item: r, text: this.rangeToText(e.createRangeIn(r)) }); if (!t) { return } t.forEach((t => { const e = `findResult:${T()}`; const n = i.addMarker(e, { usingOperation: false, affectsData: false, range: i.createRange(i.createPositionAt(r, t.start), i.createPositionAt(r, t.end)) }); const s = GT(o, n); o.add({ id: e, label: t.label, marker: n }, s) })) } } })) })); return o } rangeToText(t) { return Array.from(t.getItems()).reduce(((t, e) => { if (!(e.is("$text") || e.is("$textProxy"))) { return `${t}\n` } return t + e.data }), "") } findByTextCallback(t, e) { let n = "gu"; if (!e.matchCase) { n += "i" } let i = `(${UT(t)})`; if (e.wholeWords) { const e = "[^a-zA-ZÀ-ɏḀ-ỿ]"; if (!new RegExp("^" + e).test(t)) { i = `(^|${e}|_)${i}` } if (!new RegExp(e + "$").test(t)) { i = `${i}(?=_|${e}|$)` } } const o = new RegExp(i, n); function r({ text: t }) { const e = [...t.matchAll(o)]; return e.map(qT) } return r } } function GT(t, e) { const n = t.find((({ marker: t }) => e.getStart().isBefore(t.getStart()))); return n ? t.getIndex(n) : t.length } function qT(t) { const e = t.length - 1; let n = t.index; if (t.length === 3) { n += t[1].length } return { label: t[e], start: n, end: n + t[e].length } } var YT = n(5436); var $T = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; $T.insert = "head"; $T.singleton = true; var QT = Dl()(YT.Z, $T); const KT = YT.Z.locals || {}; const ZT = "ck-find-result_selected"; function JT(t, e, n) { const i = new Set; const o = new Set; const r = e.model; const s = r.document.differ.getChanges(); s.forEach((t => { if (t.name === "$text" || r.schema.isInline(t.position.nodeAfter)) { i.add(t.position.parent);[...r.markers.getMarkersAtPosition(t.position)].forEach((t => { o.add(t.name) })) } else if (t.type === "insert") { i.add(t.position.nodeAfter) } })); r.document.differ.getChangedMarkers().forEach((({ name: t, data: { newRange: e } }) => { if (e && e.start.root.rootName === "$graveyard") { o.add(t) } })); i.forEach((t => { const e = [...r.markers.getMarkersIntersectingRange(r.createRangeIn(t))]; e.forEach((t => o.add(t.name))) })); r.change((e => { o.forEach((n => { if (t.has(n)) { t.remove(n) } e.removeMarker(n) })) })); i.forEach((i => { const o = e.plugins.get("FindAndReplaceUtils"); o.updateFindResultFromRange(r.createRangeOn(i), r, n, t) })) } class XT extends Kd { static get requires() { return [WT] } static get pluginName() { return "FindAndReplaceEditing" } init() { this._activeResults = null; this.state = new jT(this.editor.model); this._defineConverters(); this._defineCommands(); this.listenTo(this.state, "change:highlightedResult", ((t, e, n, i) => { const { model: o } = this.editor; o.change((t => { if (i) { const e = i.marker.name.split(":")[1]; const n = o.markers.get(`findResultHighlighted:${e}`); if (n) { t.removeMarker(n) } } if (n) { const e = n.marker.name.split(":")[1]; t.addMarker(`findResultHighlighted:${e}`, { usingOperation: false, affectsData: false, range: n.marker.getRange() }) } })) })); const t = (t, e, n) => { if (n) { const t = this.editor.editing.view.domConverter; const e = this.editor.editing.mapper.toViewRange(n.marker.getRange()); Ic({ target: t.viewRangeToDom(e), viewportOffset: 40 }) } }; const e = xm(t.bind(this), 32); this.listenTo(this.state, "change:highlightedResult", e, { priority: "low" }); this.listenTo(this.editor, "destroy", e.cancel) } find(t) { const { editor: e } = this; const { model: n } = e; const { findCallback: i, results: o } = e.execute("find", t); this._activeResults = o; this.listenTo(n.document, "change:data", (() => JT(this._activeResults, e, i))); return this._activeResults } stop() { if (!this._activeResults) { return } this.stopListening(this.editor.model.document); this.state.clear(this.editor.model); this._activeResults = null } _defineCommands() { this.editor.commands.add("find", new BT(this.editor, this.state)); this.editor.commands.add("findNext", new OT(this.editor, this.state)); this.editor.commands.add("findPrevious", new RT(this.editor, this.state)); this.editor.commands.add("replace", new PT(this.editor, this.state)); this.editor.commands.add("replaceAll", new LT(this.editor, this.state)) } _defineConverters() { const { editor: t } = this; t.conversion.for("editingDowncast").markerToHighlight({ model: "findResult", view: ({ markerName: t }) => { const [, e] = t.split(":"); return { name: "span", classes: ["ck-find-result"], attributes: { "data-find-result": e } } } }); t.conversion.for("editingDowncast").markerToHighlight({ model: "findResultHighlighted", view: ({ markerName: t }) => { const [, e] = t.split(":"); return { name: "span", classes: [ZT], attributes: { "data-find-result": e } } } }) } } class tM extends Kd { static get requires() { return [XT, NT] } static get pluginName() { return "FindAndReplace" } init() { const t = this.editor.plugins.get("FindAndReplaceUI"); const e = this.editor.plugins.get("FindAndReplaceEditing"); const n = e.state; t.on("findNext", ((t, e) => { if (e) { n.searchText = e.searchText; this.editor.execute("find", e.searchText, e) } else { this.editor.execute("findNext") } })); t.on("findPrevious", ((t, e) => { if (e && n.searchText !== e.searchText) { this.editor.execute("find", e.searchText) } else { this.editor.execute("findPrevious") } })); t.on("replace", ((t, e) => { if (n.searchText !== e.searchText) { this.editor.execute("find", e.searchText) } const i = n.highlightedResult; if (i) { this.editor.execute("replace", e.replaceText, i) } })); t.on("replaceAll", ((t, e) => { if (n.searchText !== e.searchText) { this.editor.execute("find", e.searchText) } this.editor.execute("replaceAll", e.replaceText, n.results) })); t.on("searchReseted", (() => { n.clear(this.editor.model); e.stop() })) } } class eM extends Jd { refresh() { const t = this.editor.model; const e = t.document; const n = ll(e.selection.getSelectedBlocks()); this.value = !!n && n.is("element", "paragraph"); this.isEnabled = !!n && nM(n, t.schema) } execute(t = {}) { const e = this.editor.model; const n = e.document; e.change((i => { const o = (t.selection || n.selection).getSelectedBlocks(); for (const t of o) { if (!t.is("element", "paragraph") && nM(t, e.schema)) { i.rename(t, "paragraph") } } })) } } function nM(t, e) { return e.checkChild(t.parent, "paragraph") && !e.isObject(t) } class iM extends Jd { execute(t) { const e = this.editor.model; const n = t.attributes; let i = t.position; e.change((t => { const o = t.createElement("paragraph"); if (n) { e.schema.setAllowedAttributes(o, n, t) } if (!e.schema.checkChild(i.parent, o)) { const n = e.schema.findAllowedParent(i, o); if (!n) { return } i = t.split(i, n).position } e.insertContent(o, i); t.setSelection(o, "in") })) } } class oM extends Kd { static get pluginName() { return "Paragraph" } init() { const t = this.editor; const e = t.model; t.commands.add("paragraph", new eM(t)); t.commands.add("insertParagraph", new iM(t)); e.schema.register("paragraph", { inheritAllFrom: "$block" }); t.conversion.elementToElement({ model: "paragraph", view: "p" }); t.conversion.for("upcast").elementToElement({ model: (t, { writer: e }) => { if (!oM.paragraphLikeElements.has(t.name)) { return null } if (t.isEmpty) { return null } return e.createElement("paragraph") }, view: /.+/, converterPriority: "low" }) } } oM.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]); const rM = JC.paragraph; class sM extends (null && Plugin) { static get requires() { return [Paragraph] } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("paragraph", (n => { const i = new ButtonView(n); const o = t.commands.get("paragraph"); i.label = e("Paragraph"); i.icon = rM; i.tooltip = true; i.isToggleable = true; i.bind("isEnabled").to(o); i.bind("isOn").to(o, "value"); i.on("execute", (() => { t.execute("paragraph") })); return i })) } } class aM extends Jd { constructor(t, e) { super(t); this.modelElements = e } refresh() { const t = ll(this.editor.model.document.selection.getSelectedBlocks()); this.value = !!t && this.modelElements.includes(t.name) && t.name; this.isEnabled = !!t && this.modelElements.some((e => cM(t, e, this.editor.model.schema))) } execute(t) { const e = this.editor.model; const n = e.document; const i = t.value; e.change((t => { const o = Array.from(n.selection.getSelectedBlocks()).filter((t => cM(t, i, e.schema))); for (const e of o) { if (!e.is("element", i)) { t.rename(e, i) } } })) } } function cM(t, e, n) { return n.checkChild(t.parent, e) && !n.isObject(t) } const lM = "paragraph"; class dM extends Kd { static get pluginName() { return "HeadingEditing" } constructor(t) { super(t); t.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] }) } static get requires() { return [oM] } init() { const t = this.editor; const e = t.config.get("heading.options"); const n = []; for (const i of e) { if (i.model === "paragraph") { continue } t.model.schema.register(i.model, { inheritAllFrom: "$block" }); t.conversion.elementToElement(i); n.push(i.model) } this._addDefaultH1Conversion(t); t.commands.add("heading", new aM(t, n)) } afterInit() { const t = this.editor; const e = t.commands.get("enter"); const n = t.config.get("heading.options"); if (e) { this.listenTo(e, "afterExecute", ((e, i) => { const o = t.model.document.selection.getFirstPosition().parent; const r = n.some((t => o.is("element", t.model))); if (r && !o.is("element", lM) && o.childCount === 0) { i.writer.rename(o, lM) } })) } } _addDefaultH1Conversion(t) { t.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: S.get("low") + 1 }) } } function uM(t) { const e = t.t; const n = { Paragraph: e("Paragraph"), "Heading 1": e("Heading 1"), "Heading 2": e("Heading 2"), "Heading 3": e("Heading 3"), "Heading 4": e("Heading 4"), "Heading 5": e("Heading 5"), "Heading 6": e("Heading 6") }; return t.config.get("heading.options").map((t => { const e = n[t.title]; if (e && e != t.title) { t.title = e } return t })) } var hM = n(3230); var fM = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; fM.insert = "head"; fM.singleton = true; var gM = Dl()(hM.Z, fM); const mM = hM.Z.locals || {}; class pM extends Kd { static get pluginName() { return "HeadingUI" } init() { const t = this.editor; const e = t.t; const n = uM(t); const i = e("Choose heading"); const o = e("Heading"); t.ui.componentFactory.add("heading", (e => { const r = {}; const s = new cl; const a = t.commands.get("heading"); const c = t.commands.get("paragraph"); const l = [a]; for (const t of n) { const e = { type: "button", model: new Ry({ label: t.title, class: t.class, withText: true }) }; if (t.model === "paragraph") { e.model.bind("isOn").to(c, "value"); e.model.set("commandName", "paragraph"); l.push(c) } else { e.model.bind("isOn").to(a, "value", (e => e === t.model)); e.model.set({ commandName: "heading", commandValue: t.model }) } s.add(e); r[t.model] = t.title } const d = yv(e); Dv(d, s); d.buttonView.set({ isOn: false, withText: true, tooltip: o }); d.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }); d.bind("isEnabled").toMany(l, "isEnabled", ((...t) => t.some((t => t)))); d.buttonView.bind("label").to(a, "value", c, "value", ((t, e) => { const n = t || e && "paragraph"; if (typeof n === "boolean") { return i } if (!r[n]) { return i } return r[n] })); this.listenTo(d, "execute", (e => { const { commandName: n, commandValue: i } = e.source; t.execute(n, i ? { value: i } : undefined); t.editing.view.focus() })); return d })) } } class kM extends Kd { static get requires() { return [dM, pM] } static get pluginName() { return "Heading" } } class bM extends Jd { refresh() { const t = this.editor.model; const e = t.schema; const n = t.document.selection; this.isEnabled = wM(n, e, t) } execute() { const t = this.editor.model; t.change((e => { const n = e.createElement("horizontalLine"); t.insertObject(n, null, null, { setSelection: "after" }) })) } } function wM(t, e, n) { const i = _M(t, n); return e.checkChild(i, "horizontalLine") } function _M(t, e) { const n = jD(t, e); const i = n.start.parent; if (i.isEmpty && !i.is("element", "$root")) { return i.parent } return i } var AM = n(2536); var CM = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; CM.insert = "head"; CM.singleton = true; var vM = Dl()(AM.Z, CM); const yM = AM.Z.locals || {}; class xM extends Kd { static get pluginName() { return "HorizontalLineEditing" } init() { const t = this.editor; const e = t.model.schema; const n = t.t; const i = t.conversion; e.register("horizontalLine", { inheritAllFrom: "$blockObject" }); i.for("dataDowncast").elementToElement({ model: "horizontalLine", view: (t, { writer: e }) => e.createEmptyElement("hr") }); i.for("editingDowncast").elementToStructure({ model: "horizontalLine", view: (t, { writer: e }) => { const i = n("Horizontal line"); const o = e.createContainerElement("div", null, e.createEmptyElement("hr")); e.addClass("ck-horizontal-line", o); e.setCustomProperty("hr", true, o); return EM(o, e, i) } }); i.for("upcast").elementToElement({ view: "hr", model: "horizontalLine" }); t.commands.add("horizontalLine", new bM(t)) } } function EM(t, e, n) { e.setCustomProperty("horizontalLine", true, t); return ND(t, e, { label: n }) } const DM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>'; class IM extends Kd { static get pluginName() { return "HorizontalLineUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("horizontalLine", (n => { const i = t.commands.get("horizontalLine"); const o = new kd(n); o.set({ label: e("Horizontal line"), icon: DM, tooltip: true }); o.bind("isEnabled").to(i, "isEnabled"); this.listenTo(o, "execute", (() => { t.execute("horizontalLine"); t.editing.view.focus() })); return o })) } } class TM extends Kd { static get requires() { return [xM, IM, bI] } static get pluginName() { return "HorizontalLine" } } class MM extends Jd { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(this.editor.model.document.selection); this.isEnabled = !!n; if (this.isEnabled && n.hasAttribute("alt")) { this.value = n.getAttribute("alt") } else { this.value = false } } execute(t) { const e = this.editor; const n = e.plugins.get("ImageUtils"); const i = e.model; const o = n.getClosestSelectedImageElement(i.document.selection); i.change((e => { e.setAttribute("alt", t.newValue, o) })) } } function SM(t) { return t.createContainerElement("span", { class: "image-inline" }, t.createEmptyElement("img")) } function NM(t) { return t.createContainerElement("figure", { class: "image" }, [t.createEmptyElement("img"), t.createSlot("children")]) } function BM(t, e) { const n = t.plugins.get("ImageUtils"); const i = t.plugins.has("ImageInlineEditing") && t.plugins.has("ImageBlockEditing"); return t => { if (!n.isInlineImageView(t)) { return null } if (!i) { return o(t) } const r = t.getStyle("display") == "block" || t.findAncestor(n.isBlockImageView) ? "imageBlock" : "imageInline"; if (r !== e) { return null } return o(t) }; function o(t) { const e = { name: true }; if (t.hasAttribute("src")) { e.attributes = ["src"] } return e } } function zM(t, e) { const n = ll(e.getSelectedBlocks()); if (!n || t.isObject(n)) { return "imageBlock" } if (n.isEmpty && n.name != "listItem") { return "imageBlock" } return "imageInline" } class PM extends Kd { static get pluginName() { return "ImageUtils" } isImage(t) { return this.isInlineImage(t) || this.isBlockImage(t) } isInlineImageView(t) { return !!t && t.is("element", "img") } isBlockImageView(t) { return !!t && t.is("element", "figure") && t.hasClass("image") } insertImage(t = {}, e = null, n = null) { const i = this.editor; const o = i.model; const r = o.document.selection; n = jM(i, e || r, n); t = { ...Object.fromEntries(r.getAttributes()), ...t }; for (const e in t) { if (!o.schema.checkAttribute(n, e)) { delete t[e] } } return o.change((i => { const r = i.createElement(n, t); o.insertObject(r, e, null, { setSelection: "on", findOptimalPosition: !e && n != "imageInline" ? "auto" : undefined }); if (r.parent) { return r } return null })) } getClosestSelectedImageWidget(t) { const e = t.getFirstPosition(); if (!e) { return null } const n = t.getSelectedElement(); if (n && this.isImageWidget(n)) { return n } let i = e.parent; while (i) { if (i.is("element") && this.isImageWidget(i)) { return i } i = i.parent } return null } getClosestSelectedImageElement(t) { const e = t.getSelectedElement(); return this.isImage(e) ? e : t.getFirstPosition().findAncestor("imageBlock") } isImageAllowed() { const t = this.editor.model; const e = t.document.selection; return LM(this.editor, e) && OM(e) } toImageWidget(t, e, n) { e.setCustomProperty("image", true, t); const i = () => { const e = this.findViewImgElement(t); const i = e.getAttribute("alt"); return i ? `${i} ${n}` : n }; return ND(t, e, { label: i }) } isImageWidget(t) { return !!t.getCustomProperty("image") && SD(t) } isBlockImage(t) { return !!t && t.is("element", "imageBlock") } isInlineImage(t) { return !!t && t.is("element", "imageInline") } findViewImgElement(t) { if (this.isInlineImageView(t)) { return t } const e = this.editor.editing.view; for (const { item: n } of e.createRangeIn(t)) { if (this.isInlineImageView(n)) { return n } } } } function LM(t, e) { const n = jM(t, e, null); if (n == "imageBlock") { const n = RM(e, t.model); if (t.model.schema.checkChild(n, "imageBlock")) { return true } } else if (t.model.schema.checkChild(e.focus, "imageInline")) { return true } return false } function OM(t) { return [...t.focus.getAncestors()].every((t => !t.is("element", "imageBlock"))) } function RM(t, e) { const n = jD(t, e); const i = n.start.parent; if (i.isEmpty && !i.is("element", "$root")) { return i.parent } return i } function jM(t, e, n) { const i = t.model.schema; const o = t.config.get("image.insert.type"); if (!t.plugins.has("ImageBlockEditing")) { return "imageInline" } if (!t.plugins.has("ImageInlineEditing")) { return "imageBlock" } if (n) { return n } if (o === "inline") { return "imageInline" } if (o === "block") { return "imageBlock" } if (e.is("selection")) { return zM(i, e) } return i.checkChild(e, "imageInline") ? "imageInline" : "imageBlock" } class VM extends Kd { static get requires() { return [PM] } static get pluginName() { return "ImageTextAlternativeEditing" } init() { this.editor.commands.add("imageTextAlternative", new MM(this.editor)) } } var FM = n(6831); var HM = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; HM.insert = "head"; HM.singleton = true; var UM = Dl()(FM.Z, HM); const WM = FM.Z.locals || {}; class GM extends Nl { constructor(t) { super(t); const e = this.locale.t; this.focusTracker = new dl; this.keystrokes = new ul; this.labeledInput = this._createLabeledInputView(); this.saveButtonView = this._createButton(e("Save"), JC.check, "ck-button-save"); this.saveButtonView.type = "submit"; this.cancelButtonView = this._createButton(e("Cancel"), JC.cancel, "ck-button-cancel", "cancel"); this._focusables = new yl; this._focusCycler = new Wd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] }) } render() { super.render(); this.keystrokes.listenTo(this.element); o({ view: this });[this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } _createButton(t, e, n, i) { const o = new kd(this.locale); o.set({ label: t, icon: e, tooltip: true }); o.extendTemplate({ attributes: { class: n } }); if (i) { o.delegate("execute").to(this, i) } return o } _createLabeledInputView() { const t = this.locale.t; const e = new By(this.locale, zy); e.label = t("Text alternative"); return e } } function qM(t) { const e = t.plugins.get("ContextualBalloon"); const n = t.plugins.get("ImageUtils"); if (n.getClosestSelectedImageWidget(t.editing.view.document.selection)) { const n = YM(t); e.updatePosition(n) } } function YM(t) { const e = t.editing.view; const n = Uv.defaultPositions; const i = t.plugins.get("ImageUtils"); return { target: e.domConverter.mapViewToDom(i.getClosestSelectedImageWidget(e.document.selection)), positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth] } } class $M extends Kd { static get requires() { return [Ky] } static get pluginName() { return "ImageTextAlternativeUI" } init() { this._createButton() } destroy() { super.destroy(); if (this._form) { this._form.destroy() } } _createButton() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("imageTextAlternative", (n => { const i = t.commands.get("imageTextAlternative"); const o = new kd(n); o.set({ label: e("Change image text alternative"), icon: JC.lowVision, tooltip: true }); o.bind("isEnabled").to(i, "isEnabled"); o.bind("isOn").to(i, "value", (t => !!t)); this.listenTo(o, "execute", (() => { this._showForm() })); return o })) } _createForm() { const n = this.editor; const i = n.editing.view; const o = i.document; const r = n.plugins.get("ImageUtils"); this._balloon = this.editor.plugins.get("ContextualBalloon"); this._form = new (e(GM))(n.locale); this._form.render(); this.listenTo(this._form, "submit", (() => { n.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }); this._hideForm(true) })); this.listenTo(this._form, "cancel", (() => { this._hideForm(true) })); this._form.keystrokes.set("Esc", ((t, e) => { this._hideForm(true); e() })); this.listenTo(n.ui, "update", (() => { if (!r.getClosestSelectedImageWidget(o.selection)) { this._hideForm(true) } else if (this._isVisible) { qM(n) } })); t({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() }) } _showForm() { if (this._isVisible) { return } if (!this._form) { this._createForm() } const t = this.editor; const e = t.commands.get("imageTextAlternative"); const n = this._form.labeledInput; this._form.disableCssTransitions(); if (!this._isInBalloon) { this._balloon.add({ view: this._form, position: YM(t) }) } n.fieldView.value = n.fieldView.element.value = e.value || ""; this._form.labeledInput.fieldView.select(); this._form.enableCssTransitions() } _hideForm(t = false) { if (!this._isInBalloon) { return } if (this._form.focusTracker.isFocused) { this._form.saveButtonView.focus() } this._balloon.remove(this._form); if (t) { this.editor.editing.view.focus() } } get _isVisible() { return !!this._balloon && this._balloon.visibleView === this._form } get _isInBalloon() { return !!this._balloon && this._balloon.hasView(this._form) } } class QM extends Kd { static get requires() { return [VM, $M] } static get pluginName() { return "ImageTextAlternative" } } function KM(t) { const e = (e, n, i) => { if (!i.consumable.test(n.viewItem, { name: true, classes: "image" })) { return } const o = t.findViewImgElement(n.viewItem); if (!o || !i.consumable.test(o, { name: true })) { return } i.consumable.consume(n.viewItem, { name: true, classes: "image" }); const r = i.convertItem(o, n.modelCursor); const s = ll(r.modelRange.getItems()); if (!s) { i.consumable.revert(n.viewItem, { name: true, classes: "image" }); return } i.convertChildren(n.viewItem, s); i.updateConversionResult(s, n) }; return t => { t.on("element:figure", e) } } function ZM(t) { const e = ["srcset", "media", "type", "sizes"]; const n = (n, i, o) => { const r = i.viewItem; if (!o.consumable.test(r, { name: true })) { return } const s = new Map; for (const t of r.getChildren()) { if (t.is("element", "source")) { const n = {}; for (const i of e) { if (t.hasAttribute(i)) { if (o.consumable.test(t, { attributes: i })) { n[i] = t.getAttribute(i) } } } if (Object.keys(n).length) { s.set(t, n) } } } const a = t.findViewImgElement(r); if (!a) { return } let c = i.modelCursor.parent; if (!c.is("element", "imageBlock")) { const t = o.convertItem(a, i.modelCursor); i.modelRange = t.modelRange; i.modelCursor = t.modelCursor; c = first(t.modelRange.getItems()) } o.consumable.consume(r, { name: true }); for (const [t, e] of s) { o.consumable.consume(t, { attributes: Object.keys(e) }) } if (s.size) { o.writer.setAttribute("sources", Array.from(s.values()), c) } o.convertChildren(r, c) }; return t => { t.on("element:picture", n) } } function JM(t, e) { const n = (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = i.writer; const r = i.mapper.toViewElement(n.item); const s = t.findViewImgElement(r); if (n.attributeNewValue === null) { const t = n.attributeOldValue; if (t && t.data) { o.removeAttribute("srcset", s); o.removeAttribute("sizes", s); if (t.width) { o.removeAttribute("width", s) } } } else { const t = n.attributeNewValue; if (t && t.data) { o.setAttribute("srcset", t.data, s); o.setAttribute("sizes", "100vw", s); if (t.width) { o.setAttribute("width", t.width, s) } } } }; return t => { t.on(`attribute:srcset:${e}`, n) } } function XM(t) { const e = (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = i.writer; const r = i.mapper.toViewElement(n.item); const s = t.findViewImgElement(r); const a = n.attributeNewValue; if (a && a.length) { const t = o.createContainerElement("picture", null, a.map((t => o.createEmptyElement("source", t)))); const e = []; let n = s.parent; while (n && n.is("attributeElement")) { const t = n.parent; o.unwrap(o.createRangeOn(s), n); e.unshift(n); n = t } o.insert(o.createPositionBefore(s), t); o.move(o.createRangeOn(s), o.createPositionAt(t, "end")); for (const n of e) { o.wrap(o.createRangeOn(t), n) } } else if (s.parent.is("element", "picture")) { const t = s.parent; o.move(o.createRangeOn(s), o.createPositionBefore(t)); o.remove(t) } }; return t => { t.on("attribute:sources:imageBlock", e); t.on("attribute:sources:imageInline", e) } } function tS(t, e, n) { const i = (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = i.writer; const r = i.mapper.toViewElement(n.item); const s = t.findViewImgElement(r); o.setAttribute(n.attributeKey, n.attributeNewValue || "", s) }; return t => { t.on(`attribute:${n}:${e}`, i) } } class eS extends tm { observe(t) { this.listenTo(t, "load", ((t, e) => { const n = e.target; if (this.checkShouldIgnoreEventFromTarget(n)) { return } if (n.tagName == "IMG") { this._fireEvents(e) } }), { useCapture: true }) } stopObserving(t) { this.stopListening(t) } _fireEvents(t) { if (this.isEnabled) { this.document.fire("layoutChanged"); this.document.fire("imageLoaded", t) } } } class nS extends Jd { constructor(t) { super(t); const e = t.config.get("image.insert.type"); if (!t.plugins.has("ImageBlockEditing")) { if (e === "block") { P("image-block-plugin-required") } } if (!t.plugins.has("ImageInlineEditing")) { if (e === "inline") { P("image-inline-plugin-required") } } } refresh() { const t = this.editor.plugins.get("ImageUtils"); this.isEnabled = t.isImageAllowed() } execute(t) { const e = tl(t.source); const n = this.editor.model.document.selection; const i = this.editor.plugins.get("ImageUtils"); const o = Object.fromEntries(n.getAttributes()); e.forEach(((t, e) => { const r = n.getSelectedElement(); if (typeof t === "string") { t = { src: t } } if (e && r && i.isImage(r)) { const e = this.editor.model.createPositionAfter(r); i.insertImage({ ...t, ...o }, e) } else { i.insertImage({ ...t, ...o }) } })) } } class iS extends Jd { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = this.editor.model.document.selection.getSelectedElement(); this.isEnabled = e.isImage(n); this.value = this.isEnabled ? n.getAttribute("src") : null } execute(t) { const e = this.editor.model.document.selection.getSelectedElement(); this.editor.model.change((n => { n.setAttribute("src", t.source, e); n.removeAttribute("srcset", e); n.removeAttribute("sizes", e) })) } } class oS extends Kd { static get requires() { return [PM] } static get pluginName() { return "ImageEditing" } init() { const t = this.editor; const e = t.conversion; t.editing.view.addObserver(eS); e.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: { key: "srcset", value: t => { const e = { data: t.getAttribute("srcset") }; if (t.hasAttribute("width")) { e.width = t.getAttribute("width") } return e } } }); const n = new nS(t); const i = new iS(t); t.commands.add("insertImage", n); t.commands.add("replaceImageSource", i); t.commands.add("imageInsert", n) } } class rS extends Jd { constructor(t, e) { super(t); this._modelElementName = e } refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(this.editor.model.document.selection); if (this._modelElementName === "imageBlock") { this.isEnabled = e.isInlineImage(n) } else { this.isEnabled = e.isBlockImage(n) } } execute() { const t = this.editor; const e = this.editor.model; const n = t.plugins.get("ImageUtils"); const i = n.getClosestSelectedImageElement(e.document.selection); const o = Object.fromEntries(i.getAttributes()); if (!o.src && !o.uploadId) { return null } return e.change((t => { const r = Array.from(e.markers).filter((t => t.getRange().containsItem(i))); const s = n.insertImage(o, e.createSelection(i, "on"), this._modelElementName); if (!s) { return null } const a = t.createRangeOn(s); for (const e of r) { const n = e.getRange(); const i = n.root.rootName != "$graveyard" ? n.getJoined(a, true) : a; t.updateMarker(e, { range: i }) } return { oldElement: i, newElement: s } })) } } class sS extends Kd { static get requires() { return [oS, PM, vD] } static get pluginName() { return "ImageBlockEditing" } init() { const t = this.editor; const e = t.model.schema; e.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }); this._setupConversion(); if (t.plugins.has("ImageInlineEditing")) { t.commands.add("imageTypeBlock", new rS(this.editor, "imageBlock")); this._setupClipboardIntegration() } } _setupConversion() { const t = this.editor; const e = t.t; const n = t.conversion; const i = t.plugins.get("ImageUtils"); n.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (t, { writer: e }) => NM(e) }); n.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (t, { writer: n }) => i.toImageWidget(NM(n), n, e("image widget")) }); n.for("downcast").add(tS(i, "imageBlock", "src")).add(tS(i, "imageBlock", "alt")).add(JM(i, "imageBlock")); n.for("upcast").elementToElement({ view: BM(t, "imageBlock"), model: (t, { writer: e }) => e.createElement("imageBlock", t.hasAttribute("src") ? { src: t.getAttribute("src") } : undefined) }).add(KM(i)) } _setupClipboardIntegration() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = t.plugins.get("ImageUtils"); const o = t.plugins.get("ClipboardPipeline"); this.listenTo(o, "inputTransformation", ((o, r) => { const s = Array.from(r.content.getChildren()); let a; if (!s.every(i.isInlineImageView)) { return } if (r.targetRanges) { a = t.editing.mapper.toModelRange(r.targetRanges[0]) } else { a = e.document.selection.getFirstRange() } const c = e.createSelection(a); if (zM(e.schema, c) === "imageBlock") { const t = new bA(n.document); const e = s.map((e => t.createElement("figure", { class: "image" }, e))); r.content = t.createDocumentFragment(e) } })) } } var aS = n(9048); var cS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; cS.insert = "head"; cS.singleton = true; var lS = Dl()(aS.Z, cS); const dS = aS.Z.locals || {}; class uS extends Kd { static get requires() { return [sS, bI, QM] } static get pluginName() { return "ImageBlock" } } class hS extends Kd { static get requires() { return [oS, PM, vD] } static get pluginName() { return "ImageInlineEditing" } init() { const t = this.editor; const e = t.model.schema; e.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"] }); e.addChildCheck(((t, e) => { if (t.endsWith("caption") && e.name === "imageInline") { return false } })); this._setupConversion(); if (t.plugins.has("ImageBlockEditing")) { t.commands.add("imageTypeInline", new rS(this.editor, "imageInline")); this._setupClipboardIntegration() } } _setupConversion() { const t = this.editor; const e = t.t; const n = t.conversion; const i = t.plugins.get("ImageUtils"); n.for("dataDowncast").elementToElement({ model: "imageInline", view: (t, { writer: e }) => e.createEmptyElement("img") }); n.for("editingDowncast").elementToStructure({ model: "imageInline", view: (t, { writer: n }) => i.toImageWidget(SM(n), n, e("image widget")) }); n.for("downcast").add(tS(i, "imageInline", "src")).add(tS(i, "imageInline", "alt")).add(JM(i, "imageInline")); n.for("upcast").elementToElement({ view: BM(t, "imageInline"), model: (t, { writer: e }) => e.createElement("imageInline", t.hasAttribute("src") ? { src: t.getAttribute("src") } : undefined) }) } _setupClipboardIntegration() { const t = this.editor; const e = t.model; const n = t.editing.view; const i = t.plugins.get("ImageUtils"); const o = t.plugins.get("ClipboardPipeline"); this.listenTo(o, "inputTransformation", ((o, r) => { const s = Array.from(r.content.getChildren()); let a; if (!s.every(i.isBlockImageView)) { return } if (r.targetRanges) { a = t.editing.mapper.toModelRange(r.targetRanges[0]) } else { a = e.document.selection.getFirstRange() } const c = e.createSelection(a); if (zM(e.schema, c) === "imageInline") { const t = new bA(n.document); const e = s.map((e => { if (e.childCount === 1) { Array.from(e.getAttributes()).forEach((n => t.setAttribute(...n, i.findViewImgElement(e)))); return e.getChild(0) } else { return e } })); r.content = t.createDocumentFragment(e) } })) } } class fS extends Kd { static get requires() { return [hS, bI, QM] } static get pluginName() { return "ImageInline" } } class gS extends Kd { static get requires() { return [uS, fS] } static get pluginName() { return "Image" } } class mS extends Jd { refresh() { const t = this.editor; const e = t.plugins.get("ImageCaptionUtils"); const n = t.plugins.get("ImageUtils"); if (!t.plugins.has(sS)) { this.isEnabled = false; this.value = false; return } const i = t.model.document.selection; const o = i.getSelectedElement(); if (!o) { const t = e.getCaptionFromModelSelection(i); this.isEnabled = !!t; this.value = !!t; return } this.isEnabled = n.isImage(o); if (!this.isEnabled) { this.value = false } else { this.value = !!e.getCaptionFromImageModelElement(o) } } execute(t = {}) { const { focusCaptionOnShow: e } = t; this.editor.model.change((t => { if (this.value) { this._hideImageCaption(t) } else { this._showImageCaption(t, e) } })) } _showImageCaption(t, e) { const n = this.editor.model; const i = n.document.selection; const o = this.editor.plugins.get("ImageCaptionEditing"); const r = this.editor.plugins.get("ImageUtils"); let s = i.getSelectedElement(); const a = o._getSavedCaption(s); if (r.isInlineImage(s)) { this.editor.execute("imageTypeBlock"); s = i.getSelectedElement() } const c = a || t.createElement("caption"); t.append(c, s); if (e) { t.setSelection(c, "in") } } _hideImageCaption(t) { const e = this.editor; const n = e.model.document.selection; const i = e.plugins.get("ImageCaptionEditing"); const o = e.plugins.get("ImageCaptionUtils"); let r = n.getSelectedElement(); let s; if (r) { s = o.getCaptionFromImageModelElement(r) } else { s = o.getCaptionFromModelSelection(n); r = s.parent } i._saveCaption(r, s); t.setSelection(r, "on"); t.remove(s) } } class pS extends Kd { static get pluginName() { return "ImageCaptionUtils" } static get requires() { return [PM] } getCaptionFromImageModelElement(t) { for (const e of t.getChildren()) { if (!!e && e.is("element", "caption")) { return e } } return null } getCaptionFromModelSelection(t) { const e = this.editor.plugins.get("ImageUtils"); const n = t.getFirstPosition().findAncestor("caption"); if (!n) { return null } if (e.isBlockImage(n.parent)) { return n } return null } matchImageCaptionViewElement(t) { const e = this.editor.plugins.get("ImageUtils"); if (t.name == "figcaption" && e.isBlockImageView(t.parent)) { return { name: true } } return null } } class kS extends Kd { static get requires() { return [PM, pS] } static get pluginName() { return "ImageCaptionEditing" } constructor(t) { super(t); this._savedCaptionsMap = new WeakMap } init() { const t = this.editor; const e = t.model.schema; if (!e.isRegistered("caption")) { e.register("caption", { allowIn: "imageBlock", allowContentOf: "$block", isLimit: true }) } else { e.extend("caption", { allowIn: "imageBlock" }) } t.commands.add("toggleImageCaption", new mS(this.editor)); this._setupConversion(); this._setupImageTypeCommandsIntegration(); this._registerCaptionReconversion() } _setupConversion() { const t = this.editor; const e = t.editing.view; const n = t.plugins.get("ImageUtils"); const i = t.plugins.get("ImageCaptionUtils"); const o = t.t; t.conversion.for("upcast").elementToElement({ view: t => i.matchImageCaptionViewElement(t), model: "caption" }); t.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (t, { writer: e }) => { if (!n.isBlockImage(t.parent)) { return null } return e.createContainerElement("figcaption") } }); t.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (t, { writer: i }) => { if (!n.isBlockImage(t.parent)) { return null } const r = i.createEditableElement("figcaption"); i.setCustomProperty("imageCaption", true, r); lu({ view: e, element: r, text: o("Enter image caption"), keepOnFocus: true }); const s = t.parent.getAttribute("alt"); const a = s ? o("Caption for image: %0", [s]) : o("Caption for the image"); return RD(r, i, { label: a }) } }) } _setupImageTypeCommandsIntegration() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = t.plugins.get("ImageCaptionUtils"); const i = t.commands.get("imageTypeInline"); const o = t.commands.get("imageTypeBlock"); const r = t => { if (!t.return) { return } const { oldElement: i, newElement: o } = t.return; if (!i) { return } if (e.isBlockImage(i)) { const t = n.getCaptionFromImageModelElement(i); if (t) { this._saveCaption(o, t); return } } const r = this._getSavedCaption(i); if (r) { this._saveCaption(o, r) } }; if (i) { this.listenTo(i, "execute", r, { priority: "low" }) } if (o) { this.listenTo(o, "execute", r, { priority: "low" }) } } _getSavedCaption(t) { const e = this._savedCaptionsMap.get(t); return e ? Hp.fromJSON(e) : null } _saveCaption(t, e) { this._savedCaptionsMap.set(t, e.toJSON()) } _registerCaptionReconversion() { const t = this.editor; const e = t.model; const n = t.plugins.get("ImageUtils"); const i = t.plugins.get("ImageCaptionUtils"); e.document.on("change:data", (() => { const o = e.document.differ.getChanges(); for (const e of o) { if (e.attributeKey !== "alt") { continue } const o = e.range.start.nodeAfter; if (n.isBlockImage(o)) { const e = i.getCaptionFromImageModelElement(o); if (!e) { return } t.editing.reconvertItem(e) } } })) } } class bS extends Kd { static get requires() { return [pS] } static get pluginName() { return "ImageCaptionUI" } init() { const t = this.editor; const e = t.editing.view; const n = t.plugins.get("ImageCaptionUtils"); const i = t.t; t.ui.componentFactory.add("toggleImageCaption", (o => { const r = t.commands.get("toggleImageCaption"); const s = new kd(o); s.set({ icon: JC.caption, tooltip: true, isToggleable: true }); s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"); s.bind("label").to(r, "value", (t => t ? i("Toggle caption off") : i("Toggle caption on"))); this.listenTo(s, "execute", (() => { t.execute("toggleImageCaption", { focusCaptionOnShow: true }); const i = n.getCaptionFromModelSelection(t.model.document.selection); if (i) { const n = t.editing.mapper.toViewElement(i); e.scrollToTheSelection(); e.change((t => { t.addClass("image__caption_highlighted", n) })) } t.editing.view.focus() })); return s })) } } var wS = n(8662); var _S = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; _S.insert = "head"; _S.singleton = true; var AS = Dl()(wS.Z, _S); const CS = wS.Z.locals || {}; class vS extends Kd { static get requires() { return [kS, bS] } static get pluginName() { return "ImageCaption" } } class yS extends (ft()) { constructor() { super(); const t = new window.FileReader; this._reader = t; this._data = undefined; this.set("loaded", 0); t.onprogress = t => { this.loaded = t.loaded } } get error() { return this._reader.error } get data() { return this._data } read(t) { const e = this._reader; this.total = t.size; return new Promise(((n, i) => { e.onload = () => { const t = e.result; this._data = t; n(t) }; e.onerror = () => { i("error") }; e.onabort = () => { i("aborted") }; this._reader.readAsDataURL(t) })) } abort() { this._reader.abort() } } class xS extends Kd { constructor() { super(...arguments); this.loaders = new cl; this._loadersMap = new Map; this._pendingAction = null } static get pluginName() { return "FileRepository" } static get requires() { return [kC] } init() { this.loaders.on("change", (() => this._updatePendingAction())); this.set("uploaded", 0); this.set("uploadTotal", null); this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0)) } getLoader(t) { return this._loadersMap.get(t) || null } createLoader(t) { if (!this.createUploadAdapter) { P("filerepository-no-upload-adapter"); return null } const e = new ES(Promise.resolve(t), this.createUploadAdapter); this.loaders.add(e); this._loadersMap.set(t, e); if (t instanceof Promise) { e.file.then((t => { this._loadersMap.set(t, e) })).catch((() => { })) } e.on("change:uploaded", (() => { let t = 0; for (const e of this.loaders) { t += e.uploaded } this.uploaded = t })); e.on("change:uploadTotal", (() => { let t = 0; for (const e of this.loaders) { if (e.uploadTotal) { t += e.uploadTotal } } this.uploadTotal = t })); return e } destroyLoader(t) { const e = t instanceof ES ? t : this.getLoader(t); e._destroy(); this.loaders.remove(e); this._loadersMap.forEach(((t, n) => { if (t === e) { this._loadersMap.delete(n) } })) } _updatePendingAction() { const t = this.editor.plugins.get(kC); if (this.loaders.length) { if (!this._pendingAction) { const e = this.editor.t; const n = t => `${e("Upload in progress")} ${parseInt(t)}%.`; this._pendingAction = t.add(n(this.uploadedPercent)); this._pendingAction.bind("message").to(this, "uploadedPercent", n) } } else { t.remove(this._pendingAction); this._pendingAction = null } } } class ES extends (ft()) { constructor(t, e) { super(); this.id = T(); this._filePromiseWrapper = this._createFilePromiseWrapper(t); this._adapter = e(this); this._reader = new yS; this.set("status", "idle"); this.set("uploaded", 0); this.set("uploadTotal", null); this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0)); this.set("uploadResponse", null) } get file() { if (!this._filePromiseWrapper) { return Promise.resolve(null) } else { return this._filePromiseWrapper.promise.then((t => this._filePromiseWrapper ? t : null)) } } get data() { return this._reader.data } read() { if (this.status != "idle") { throw new z("filerepository-read-wrong-status", this) } this.status = "reading"; return this.file.then((t => this._reader.read(t))).then((t => { if (this.status !== "reading") { throw this.status } this.status = "idle"; return t })).catch((t => { if (t === "aborted") { this.status = "aborted"; throw "aborted" } this.status = "error"; throw this._reader.error ? this._reader.error : t })) } upload() { if (this.status != "idle") { throw new z("filerepository-upload-wrong-status", this) } this.status = "uploading"; return this.file.then((() => this._adapter.upload())).then((t => { this.uploadResponse = t; this.status = "idle"; return t })).catch((t => { if (this.status === "aborted") { throw "aborted" } this.status = "error"; throw t })) } abort() { const t = this.status; this.status = "aborted"; if (!this._filePromiseWrapper.isFulfilled) { this._filePromiseWrapper.promise.catch((() => { })); this._filePromiseWrapper.rejecter("aborted") } else if (t == "reading") { this._reader.abort() } else if (t == "uploading" && this._adapter.abort) { this._adapter.abort() } this._destroy() } _destroy() { this._filePromiseWrapper = undefined; this._reader = undefined; this._adapter = undefined; this.uploadResponse = undefined } _createFilePromiseWrapper(t) { const e = {}; e.promise = new Promise(((n, i) => { e.rejecter = i; e.isFulfilled = false; t.then((t => { e.isFulfilled = true; n(t) })).catch((t => { e.isFulfilled = true; i(t) })) })); return e } } class DS extends Nl { constructor(t) { super(t); this.buttonView = new kd(t); this._fileInputView = new IS(t); this._fileInputView.bind("acceptedType").to(this); this._fileInputView.bind("allowMultipleFiles").to(this); this._fileInputView.delegate("done").to(this); this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }); this.buttonView.on("execute", (() => { this._fileInputView.open() })) } focus() { this.buttonView.focus() } } class IS extends Nl { constructor(t) { super(t); this.set("acceptedType", undefined); this.set("allowMultipleFiles", false); const e = this.bindTemplate; this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: e.to("acceptedType"), multiple: e.to("allowMultipleFiles") }, on: { change: e.to((() => { if (this.element && this.element.files && this.element.files.length) { this.fire("done", this.element.files) } this.element.value = "" })) } }) } open() { this.element.click() } } class TS extends (null && Plugin) { static get requires() { return [FileRepository] } static get pluginName() { return "Base64UploadAdapter" } init() { this.editor.plugins.get(FileRepository).createUploadAdapter = t => new MS(t) } } class MS { constructor(t) { this.loader = t } upload() { return new Promise(((t, e) => { const n = this.reader = new window.FileReader; n.addEventListener("load", (() => { t({ default: n.result }) })); n.addEventListener("error", (t => { e(t) })); n.addEventListener("abort", (() => { e() })); this.loader.file.then((t => { n.readAsDataURL(t) })) })) } abort() { this.reader.abort() } } class SS extends Kd { static get requires() { return [xS] } static get pluginName() { return "SimpleUploadAdapter" } init() { const t = this.editor.config.get("simpleUpload"); if (!t) { return } if (!t.uploadUrl) { P("simple-upload-adapter-missing-uploadurl"); return } this.editor.plugins.get(xS).createUploadAdapter = e => new NS(e, t) } } class NS { constructor(t, e) { this.loader = t; this.options = e } upload() { return this.loader.file.then((t => new Promise(((e, n) => { this._initRequest(); this._initListeners(e, n, t); this._sendRequest(t) })))) } abort() { if (this.xhr) { this.xhr.abort() } } _initRequest() { const t = this.xhr = new XMLHttpRequest; t.open("POST", this.options.uploadUrl, true); t.responseType = "json" } _initListeners(t, e, n) { const i = this.xhr; const o = this.loader; const r = `Couldn't upload file: ${n.name}.`; i.addEventListener("error", (() => e(r))); i.addEventListener("abort", (() => e())); i.addEventListener("load", (() => { const n = i.response; if (!n || n.error) { return e(n && n.error && n.error.message ? n.error.message : r) } const o = n.url ? { default: n.url } : n.urls; t({ ...n, urls: o }) })); if (i.upload) { i.upload.addEventListener("progress", (t => { if (t.lengthComputable) { o.uploadTotal = t.total; o.uploaded = t.loaded } })) } } _sendRequest(t) { const e = this.options.headers || {}; const n = this.options.withCredentials || false; for (const t of Object.keys(e)) { this.xhr.setRequestHeader(t, e[t]) } this.xhr.withCredentials = n; const i = new FormData; i.append("upload", t); this.xhr.send(i) } } function BS(t) { const e = t.map((t => t.replace("+", "\\+"))); return new RegExp(`^image\\/(${e.join("|")})$`) } function zS(t) { return new Promise(((e, n) => { const i = t.getAttribute("src"); fetch(i).then((t => t.blob())).then((t => { const n = LS(t, i); const o = n.replace("image/", ""); const r = `image.${o}`; const s = new File([t], r, { type: n }); e(s) })).catch((t => t && t.name === "TypeError" ? OS(i).then(e).catch(n) : n(t))) })) } function PS(t, e) { if (!t.isInlineImageView(e) || !e.getAttribute("src")) { return false } return !!e.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!e.getAttribute("src").match(/^blob:/g) } function LS(t, e) { if (t.type) { return t.type } else if (e.match(/data:(image\/\w+);base64/)) { return e.match(/data:(image\/\w+);base64/)[1].toLowerCase() } else { return "image/jpeg" } } function OS(t) { return RS(t).then((e => { const n = LS(e, t); const i = n.replace("image/", ""); const o = `image.${i}`; return new File([e], o, { type: n }) })) } function RS(t) { return new Promise(((e, n) => { const i = nc.document.createElement("img"); i.addEventListener("load", (() => { const t = nc.document.createElement("canvas"); t.width = i.width; t.height = i.height; const o = t.getContext("2d"); o.drawImage(i, 0, 0); t.toBlob((t => t ? e(t) : n())) })); i.addEventListener("error", (() => n())); i.src = t })) } class jS extends Kd { static get pluginName() { return "ImageUploadUI" } init() { const t = this.editor; const e = t.t; const n = n => { const i = new DS(n); const o = t.commands.get("uploadImage"); const r = t.config.get("image.upload.types"); const s = BS(r); i.set({ acceptedType: r.map((t => `image/${t}`)).join(","), allowMultipleFiles: true }); i.buttonView.set({ label: e("Insert image"), icon: JC.image, tooltip: true }); i.buttonView.bind("isEnabled").to(o); i.on("done", ((e, n) => { const i = Array.from(n).filter((t => s.test(t.type))); if (i.length) { t.execute("uploadImage", { file: i }); t.editing.view.focus() } })); return i }; t.ui.componentFactory.add("uploadImage", n); t.ui.componentFactory.add("imageUpload", n) } } var VS = n(5870); var FS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; FS.insert = "head"; FS.singleton = true; var HS = Dl()(VS.Z, FS); const US = VS.Z.locals || {}; var WS = n(9899); var GS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; GS.insert = "head"; GS.singleton = true; var qS = Dl()(WS.Z, GS); const YS = WS.Z.locals || {}; var $S = n(9825); var QS = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; QS.insert = "head"; QS.singleton = true; var KS = Dl()($S.Z, QS); const ZS = $S.Z.locals || {}; class JS extends Kd { static get pluginName() { return "ImageUploadProgress" } constructor(t) { super(t); this.uploadStatusChange = (t, e, n) => { const i = this.editor; const o = e.item; const r = o.getAttribute("uploadId"); if (!n.consumable.consume(e.item, t.name)) { return } const s = i.plugins.get("ImageUtils"); const a = i.plugins.get(xS); const c = r ? e.attributeNewValue : null; const l = this.placeholder; const d = i.editing.mapper.toViewElement(o); const u = n.writer; if (c == "reading") { XS(d, u); eN(s, l, d, u); return } if (c == "uploading") { const t = a.loaders.get(r); XS(d, u); if (!t) { eN(s, l, d, u) } else { nN(d, u); iN(d, u, t, i.editing.view); dN(s, d, u, t) } return } if (c == "complete" && a.loaders.get(r)) { rN(d, u, i.editing.view) } oN(d, u); nN(d, u); tN(d, u) }; this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" } init() { const t = this.editor; if (t.plugins.has("ImageBlockEditing")) { t.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange) } if (t.plugins.has("ImageInlineEditing")) { t.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange) } } } function XS(t, e) { if (!t.hasClass("ck-appear")) { e.addClass("ck-appear", t) } } function tN(t, e) { e.removeClass("ck-appear", t) } function eN(t, e, n, i) { if (!n.hasClass("ck-image-upload-placeholder")) { i.addClass("ck-image-upload-placeholder", n) } const o = t.findViewImgElement(n); if (o.getAttribute("src") !== e) { i.setAttribute("src", e, o) } if (!cN(n, "placeholder")) { i.insert(i.createPositionAfter(o), aN(i)) } } function nN(t, e) { if (t.hasClass("ck-image-upload-placeholder")) { e.removeClass("ck-image-upload-placeholder", t) } lN(t, e, "placeholder") } function iN(t, e, n, i) { const o = sN(e); e.insert(e.createPositionAt(t, "end"), o); n.on("change:uploadedPercent", ((t, e, n) => { i.change((t => { t.setStyle("width", n + "%", o) })) })) } function oN(t, e) { lN(t, e, "progressBar") } function rN(t, e, n) { const i = e.createUIElement("div", { class: "ck-image-upload-complete-icon" }); e.insert(e.createPositionAt(t, "end"), i); setTimeout((() => { n.change((t => t.remove(t.createRangeOn(i)))) }), 3e3) } function sN(t) { const e = t.createUIElement("div", { class: "ck-progress-bar" }); t.setCustomProperty("progressBar", true, e); return e } function aN(t) { const e = t.createUIElement("div", { class: "ck-upload-placeholder-loader" }); t.setCustomProperty("placeholder", true, e); return e } function cN(t, e) { for (const n of t.getChildren()) { if (n.getCustomProperty(e)) { return n } } } function lN(t, e, n) { const i = cN(t, n); if (i) { e.remove(e.createRangeOn(i)) } } function dN(t, e, n, i) { if (i.data) { const o = t.findViewImgElement(e); n.setAttribute("src", i.data, o) } } class uN extends Jd { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = t.model.document.selection.getSelectedElement(); this.isEnabled = e.isImageAllowed() || e.isImage(n) } execute(t) { const e = tl(t.file); const n = this.editor.model.document.selection; const i = this.editor.plugins.get("ImageUtils"); const o = Object.fromEntries(n.getAttributes()); e.forEach(((t, e) => { const r = n.getSelectedElement(); if (e && r && i.isImage(r)) { const e = this.editor.model.createPositionAfter(r); this._uploadImage(t, o, e) } else { this._uploadImage(t, o) } })) } _uploadImage(t, e, n) { const i = this.editor; const o = i.plugins.get(xS); const r = o.createLoader(t); const s = i.plugins.get("ImageUtils"); if (!r) { return } s.insertImage({ ...e, uploadId: r.id }, n) } } class hN extends Kd { static get requires() { return [xS, Oy, vD, PM] } static get pluginName() { return "ImageUploadEditing" } constructor(t) { super(t); t.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }); this._uploadImageElements = new Map } init() { const t = this.editor; const e = t.model.document; const n = t.conversion; const i = t.plugins.get(xS); const o = t.plugins.get("ImageUtils"); const r = t.plugins.get("ClipboardPipeline"); const s = BS(t.config.get("image.upload.types")); const a = new uN(t); t.commands.add("uploadImage", a); t.commands.add("imageUpload", a); n.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }); this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => { if (fN(n.dataTransfer)) { return } const i = Array.from(n.dataTransfer.files).filter((t => { if (!t) { return false } return s.test(t.type) })); if (!i.length) { return } e.stop(); t.model.change((e => { if (n.targetRanges) { e.setSelection(n.targetRanges.map((e => t.editing.mapper.toModelRange(e)))) } t.model.enqueueChange((() => { t.execute("uploadImage", { file: i }) })) })) })); this.listenTo(r, "inputTransformation", ((e, n) => { const r = Array.from(t.editing.view.createRangeIn(n.content)).map((t => t.item)).filter((t => PS(o, t) && !t.getAttribute("uploadProcessed"))).map((t => ({ promise: zS(t), imageElement: t }))); if (!r.length) { return } const s = new bA(t.editing.view.document); for (const t of r) { s.setAttribute("uploadProcessed", true, t.imageElement); const e = i.createLoader(t.promise); if (e) { s.setAttribute("src", "", t.imageElement); s.setAttribute("uploadId", e.id, t.imageElement) } } })); t.editing.view.document.on("dragover", ((t, e) => { e.preventDefault() })); e.on("change", (() => { const n = e.differ.getChanges({ includeChangesInGraveyard: true }).reverse(); const o = new Set; for (const e of n) { if (e.type == "insert" && e.name != "$text") { const n = e.position.nodeAfter; const r = e.position.root.rootName == "$graveyard"; for (const e of gN(t, n)) { const t = e.getAttribute("uploadId"); if (!t) { continue } const n = i.loaders.get(t); if (!n) { continue } if (r) { if (!o.has(t)) { n.abort() } } else { o.add(t); this._uploadImageElements.set(t, e); if (n.status == "idle") { this._readAndUpload(n) } } } } } })); this.on("uploadComplete", ((t, { imageElement: e, data: n }) => { const i = n.urls ? n.urls : n; this.editor.model.change((t => { t.setAttribute("src", i.default, e); this._parseAndSetSrcsetAttributeOnImage(i, e, t) })) }), { priority: "low" }) } afterInit() { const t = this.editor.model.schema; if (this.editor.plugins.has("ImageBlockEditing")) { t.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }) } if (this.editor.plugins.has("ImageInlineEditing")) { t.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] }) } } _readAndUpload(t) { const e = this.editor; const n = e.model; const i = e.locale.t; const o = e.plugins.get(xS); const r = e.plugins.get(Oy); const s = e.plugins.get("ImageUtils"); const a = this._uploadImageElements; n.enqueueChange({ isUndoable: false }, (e => { e.setAttribute("uploadStatus", "reading", a.get(t.id)) })); return t.read().then((() => { const i = t.upload(); const o = a.get(t.id); if (l.isSafari) { const t = e.editing.mapper.toViewElement(o); const n = s.findViewImgElement(t); e.editing.view.once("render", (() => { if (!n.parent) { return } const t = e.editing.view.domConverter.mapViewToDom(n.parent); if (!t) { return } const i = t.style.display; t.style.display = "none"; t._ckHack = t.offsetHeight; t.style.display = i })) } n.enqueueChange({ isUndoable: false }, (t => { t.setAttribute("uploadStatus", "uploading", o) })); return i })).then((e => { n.enqueueChange({ isUndoable: false }, (n => { const i = a.get(t.id); n.setAttribute("uploadStatus", "complete", i); this.fire("uploadComplete", { data: e, imageElement: i }) })); c() })).catch((e => { if (t.status !== "error" && t.status !== "aborted") { throw e } if (t.status == "error" && e) { r.showWarning(e, { title: i("Upload failed"), namespace: "upload" }) } n.enqueueChange({ isUndoable: false }, (e => { e.remove(a.get(t.id)) })); c() })); function c() { n.enqueueChange({ isUndoable: false }, (e => { const n = a.get(t.id); e.removeAttribute("uploadId", n); e.removeAttribute("uploadStatus", n); a.delete(t.id) })); o.destroyLoader(t) } } _parseAndSetSrcsetAttributeOnImage(t, e, n) { let i = 0; const o = Object.keys(t).filter((t => { const e = parseInt(t, 10); if (!isNaN(e)) { i = Math.max(i, e); return true } })).map((e => `${t[e]} ${e}w`)).join(", "); if (o != "") { n.setAttribute("srcset", { data: o, width: i }, e) } } } function fN(t) { return Array.from(t.types).includes("text/html") && t.getData("text/html") !== "" } function gN(t, e) { const n = t.plugins.get("ImageUtils"); return Array.from(t.model.createRangeOn(e)).filter((t => n.isImage(t.item))).map((t => t.item)) } class mN extends Kd { static get pluginName() { return "ImageUpload" } static get requires() { return [hN, jS, JS] } } var pN = n(5150); var kN = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; kN.insert = "head"; kN.singleton = true; var bN = Dl()(pN.Z, kN); const wN = pN.Z.locals || {}; class _N extends Nl { constructor(t, e = {}) { super(t); const n = this.bindTemplate; this.set("class", e.class || null); this.children = this.createCollection(); if (e.children) { e.children.forEach((t => this.children.add(t))) } this.set("_role", null); this.set("_ariaLabelledBy", null); if (e.labelView) { this.set({ _role: "group", _ariaLabelledBy: e.labelView.id }) } this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form__row", n.to("class")], role: n.to("_role"), "aria-labelledby": n.to("_ariaLabelledBy") }, children: this.children }) } } var AN = n(9292); var CN = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; CN.insert = "head"; CN.singleton = true; var vN = Dl()(AN.Z, CN); const yN = AN.Z.locals || {}; class xN extends Nl { constructor(t, e = {}) { super(t); const { insertButtonView: n, cancelButtonView: i } = this._createActionButtons(t); this.insertButtonView = n; this.cancelButtonView = i; this.set("imageURLInputValue", ""); this.focusTracker = new dl; this.keystrokes = new ul; this._focusables = new yl; this._focusCycler = new Wd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.set("_integrations", new cl); for (const [t, n] of Object.entries(e)) { if (t === "insertImageViaUrl") { n.fieldView.bind("value").to(this, "imageURLInputValue", (t => t || "")); n.fieldView.on("input", (() => { this.imageURLInputValue = n.fieldView.element.value.trim() })) } n.name = t; this._integrations.add(n) } this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-image-insert-form"], tabindex: "-1" }, children: [...this._integrations, new _N(t, { children: [this.insertButtonView, this.cancelButtonView], class: "ck-image-insert-form__action-row" })] }) } render() { super.render(); o({ view: this }); const t = [...this._integrations, this.insertButtonView, this.cancelButtonView]; t.forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element); const e = t => t.stopPropagation(); this.keystrokes.set("arrowright", e); this.keystrokes.set("arrowleft", e); this.keystrokes.set("arrowup", e); this.keystrokes.set("arrowdown", e); this.listenTo(t[0].element, "selectstart", ((t, e) => { e.stopPropagation() }), { priority: "high" }) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } getIntegration(t) { return this._integrations.find((e => e.name === t)) } _createActionButtons(t) { const e = t.t; const n = new kd(t); const i = new kd(t); n.set({ label: e("Insert"), icon: JC.check, class: "ck-button-save", type: "submit", withText: true, isEnabled: this.imageURLInputValue }); i.set({ label: e("Cancel"), icon: JC.cancel, class: "ck-button-cancel", withText: true }); n.bind("isEnabled").to(this, "imageURLInputValue", (t => !!t)); n.delegate("execute").to(this, "submit"); i.delegate("execute").to(this, "cancel"); return { insertButtonView: n, cancelButtonView: i } } focus() { this._focusCycler.focusFirst() } } function EN(t) { const e = t.config.get("image.insert.integrations"); const n = t.plugins.get("ImageInsertUI"); const i = { insertImageViaUrl: DN(t.locale) }; if (!e) { return i } if (e.find((t => t === "openCKFinder")) && t.ui.componentFactory.has("ckfinder")) { const e = t.ui.componentFactory.create("ckfinder"); e.set({ withText: true, class: "ck-image-insert__ck-finder-button" }); e.delegate("execute").to(n, "cancel"); i.openCKFinder = e } return e.reduce(((e, n) => { if (i[n]) { e[n] = i[n] } else if (t.ui.componentFactory.has(n)) { e[n] = t.ui.componentFactory.create(n) } return e }), {}) } function DN(t) { const e = t.t; const n = new By(t, zy); n.set({ label: e("Insert image via URL") }); n.fieldView.placeholder = "https://example.com/image.png"; return n } class IN extends Kd { static get pluginName() { return "ImageInsertUI" } init() { const t = this.editor; const e = t => this._createDropdownView(t); t.ui.componentFactory.add("insertImage", e); t.ui.componentFactory.add("imageInsert", e) } _createDropdownView(t) { const e = this.editor; const n = t.t; const i = e.commands.get("uploadImage"); const o = e.commands.get("insertImage"); this.dropdownView = yv(t, i ? Ud : undefined); const r = this.dropdownView.buttonView; const s = this.dropdownView.panelView; r.set({ label: n("Insert image"), icon: JC.image, tooltip: true }); s.extendTemplate({ attributes: { class: "ck-image-insert__panel" } }); if (i) { const t = this.dropdownView.buttonView; t.actionView = e.ui.componentFactory.create("uploadImage"); t.actionView.extendTemplate({ attributes: { class: "ck ck-button ck-splitbutton__action" } }) } return this._setUpDropdown(i || o) } _setUpDropdown(t) { const e = this.editor; const n = e.t; const i = this.dropdownView; const o = i.panelView; const r = this.editor.plugins.get("ImageUtils"); const s = e.commands.get("replaceImageSource"); let a; i.bind("isEnabled").to(t); i.once("change:isOpen", (() => { a = new xN(e.locale, EN(e)); a.delegate("submit", "cancel").to(i); o.children.add(a) })); i.on("change:isOpen", (() => { const t = e.model.document.selection.getSelectedElement(); const o = a.insertButtonView; const c = a.getIntegration("insertImageViaUrl"); if (i.isOpen) { if (r.isImage(t)) { a.imageURLInputValue = s.value; o.label = n("Update"); c.label = n("Update image URL") } else { a.imageURLInputValue = ""; o.label = n("Insert"); c.label = n("Insert image via URL") } } }), { priority: "low" }); this.delegate("cancel").to(i); i.on("submit", (() => { l(); c() })); i.on("cancel", (() => { l() })); function c() { const t = e.model.document.selection.getSelectedElement(); if (r.isImage(t)) { e.execute("replaceImageSource", { source: a.imageURLInputValue }) } else { e.execute("insertImage", { source: a.imageURLInputValue }) } } function l() { e.editing.view.focus(); i.isOpen = false } return i } } class TN extends Kd { static get pluginName() { return "ImageInsertViaUrl" } static get requires() { return [IN] } } class MN extends Kd { static get pluginName() { return "ImageInsert" } static get requires() { return [mN, TN, IN] } } class SN extends Jd { refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(t.model.document.selection); this.isEnabled = !!n; if (!n || !n.hasAttribute("width")) { this.value = null } else { this.value = { width: n.getAttribute("width"), height: null } } } execute(t) { const e = this.editor; const n = e.model; const i = e.plugins.get("ImageUtils"); const o = i.getClosestSelectedImageElement(n.document.selection); this.value = { width: t.width, height: null }; if (o) { n.change((e => { e.setAttribute("width", t.width, o) })) } } } class NN extends Kd { static get requires() { return [PM] } static get pluginName() { return "ImageResizeEditing" } constructor(t) { super(t); t.config.define("image", { resizeUnit: "%", resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:25", value: "25", icon: "small" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] }) } init() { const t = this.editor; const e = new SN(t); this._registerSchema(); this._registerConverters("imageBlock"); this._registerConverters("imageInline"); t.commands.add("resizeImage", e); t.commands.add("imageResize", e) } _registerSchema() { if (this.editor.plugins.has("ImageBlockEditing")) { this.editor.model.schema.extend("imageBlock", { allowAttributes: "width" }) } if (this.editor.plugins.has("ImageInlineEditing")) { this.editor.model.schema.extend("imageInline", { allowAttributes: "width" }) } } _registerConverters(t) { const e = this.editor; e.conversion.for("downcast").add((e => e.on(`attribute:width:${t}`, ((t, e, n) => { if (!n.consumable.consume(e.item, t.name)) { return } const i = n.writer; const o = n.mapper.toViewElement(e.item); if (e.attributeNewValue !== null) { i.setStyle("width", e.attributeNewValue, o); i.addClass("image_resized", o) } else { i.removeStyle("width", o); i.removeClass("image_resized", o) } })))); e.conversion.for("upcast").attributeToAttribute({ view: { name: t === "imageBlock" ? "figure" : "img", styles: { width: /.+/ } }, model: { key: "width", value: t => t.getStyle("width") } }) } } const BN = { small: JC.objectSizeSmall, medium: JC.objectSizeMedium, large: JC.objectSizeLarge, original: JC.objectSizeFull }; class zN extends Kd { static get requires() { return [NN] } static get pluginName() { return "ImageResizeButtons" } constructor(t) { super(t); this._resizeUnit = t.config.get("image.resizeUnit") } init() { const t = this.editor; const e = t.config.get("image.resizeOptions"); const n = t.commands.get("resizeImage"); this.bind("isEnabled").to(n); for (const t of e) { this._registerImageResizeButton(t) } this._registerImageResizeDropdown(e) } _registerImageResizeButton(t) { const e = this.editor; const { name: n, value: i, icon: o } = t; const r = i ? i + this._resizeUnit : null; e.ui.componentFactory.add(n, (n => { const i = new kd(n); const s = e.commands.get("resizeImage"); const a = this._getOptionLabelValue(t, true); if (!BN[o]) { throw new z("imageresizebuttons-missing-icon", e, t) } i.set({ label: a, icon: BN[o], tooltip: a, isToggleable: true }); i.bind("isEnabled").to(this); i.bind("isOn").to(s, "value", PN(r)); this.listenTo(i, "execute", (() => { e.execute("resizeImage", { width: r }) })); return i })) } _registerImageResizeDropdown(t) { const e = this.editor; const n = e.t; const i = t.find((t => !t.value)); const o = o => { const r = e.commands.get("resizeImage"); const s = yv(o, Rd); const a = s.buttonView; a.set({ tooltip: n("Resize image"), commandValue: i.value, icon: BN.medium, isToggleable: true, label: this._getOptionLabelValue(i), withText: true, class: "ck-resize-image-button" }); a.bind("label").to(r, "value", (t => { if (t && t.width) { return t.width } else { return this._getOptionLabelValue(i) } })); s.bind("isEnabled").to(this); Dv(s, (() => this._getResizeDropdownListItemDefinitions(t, r)), { ariaLabel: n("Image resize list") }); this.listenTo(s, "execute", (t => { e.execute(t.source.commandName, { width: t.source.commandValue }); e.editing.view.focus() })); return s }; e.ui.componentFactory.add("resizeImage", o); e.ui.componentFactory.add("imageResize", o) } _getOptionLabelValue(t, e = false) { const n = this.editor.t; if (t.label) { return t.label } else if (e) { if (t.value) { return n("Resize image to %0", t.value + this._resizeUnit) } else { return n("Resize image to the original size") } } else { if (t.value) { return t.value + this._resizeUnit } else { return n("Original") } } } _getResizeDropdownListItemDefinitions(t, e) { const n = new cl; t.map((t => { const i = t.value ? t.value + this._resizeUnit : null; const o = { type: "button", model: new Ry({ commandName: "resizeImage", commandValue: i, label: this._getOptionLabelValue(t), withText: true, icon: null }) }; o.model.bind("isOn").to(e, "value", PN(i)); n.add(o) })); return n } } function PN(t) { return e => { const n = e; if (t === null && n === t) { return true } return n !== null && n.width === t } } const LN = "figure.image.ck-widget > img," + "figure.image.ck-widget > picture > img," + "figure.image.ck-widget > a > img," + "figure.image.ck-widget > a > picture > img," + "span.image-inline.ck-widget > img," + "span.image-inline.ck-widget > picture > img"; const ON = /(image|image-inline)/; const RN = "image_resized"; class jN extends Kd { static get requires() { return [VI] } static get pluginName() { return "ImageResizeHandles" } init() { const t = this.editor.commands.get("resizeImage"); this.bind("isEnabled").to(t); this._setupResizerCreator() } _setupResizerCreator() { const t = this.editor; const e = t.editing.view; e.addObserver(eS); this.listenTo(e.document, "imageLoaded", ((n, i) => { if (!i.target.matches(LN)) { return } const o = t.editing.view.domConverter; const r = o.domToView(i.target); const s = r.findAncestor({ classes: ON }); let a = this.editor.plugins.get(VI).getResizerByViewElement(s); if (a) { a.redraw(); return } const c = t.editing.mapper; const l = c.toModelElement(s); a = t.plugins.get(VI).attachTo({ unit: t.config.get("image.resizeUnit"), modelElement: l, viewElement: s, editor: t, getHandleHost(t) { return t.querySelector("img") }, getResizeHost() { return o.mapViewToDom(c.toViewElement(l.parent)) }, isCentered() { const t = l.getAttribute("imageStyle"); return !t || t == "block" || t == "alignCenter" }, onCommit(n) { e.change((t => { t.removeClass(RN, s) })); t.execute("resizeImage", { width: n }) } }); a.on("updateSize", (() => { if (!s.hasClass(RN)) { e.change((t => { t.addClass(RN, s) })) } })); a.bind("isEnabled").to(this) })) } } var VN = n(1043); var FN = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; FN.insert = "head"; FN.singleton = true; var HN = Dl()(VN.Z, FN); const UN = VN.Z.locals || {}; class WN extends Kd { static get requires() { return [NN, jN, zN] } static get pluginName() { return "ImageResize" } } class GN extends Jd { constructor(t, e) { super(t); this._defaultStyles = { imageBlock: false, imageInline: false }; this._styles = new Map(e.map((t => { if (t.isDefault) { for (const e of t.modelElements) { this._defaultStyles[e] = t.name } } return [t.name, t] }))) } refresh() { const t = this.editor; const e = t.plugins.get("ImageUtils"); const n = e.getClosestSelectedImageElement(this.editor.model.document.selection); this.isEnabled = !!n; if (!this.isEnabled) { this.value = false } else if (n.hasAttribute("imageStyle")) { this.value = n.getAttribute("imageStyle") } else { this.value = this._defaultStyles[n.name] } } execute(t = {}) { const e = this.editor; const n = e.model; const i = e.plugins.get("ImageUtils"); n.change((e => { const o = t.value; let r = i.getClosestSelectedImageElement(n.document.selection); if (o && this.shouldConvertImageType(o, r)) { this.editor.execute(i.isBlockImage(r) ? "imageTypeInline" : "imageTypeBlock"); r = i.getClosestSelectedImageElement(n.document.selection) } if (!o || this._styles.get(o).isDefault) { e.removeAttribute("imageStyle", r) } else { e.setAttribute("imageStyle", o, r) } })) } shouldConvertImageType(t, e) { const n = this._styles.get(t).modelElements; return !n.includes(e.name) } } const { objectFullWidth: qN, objectInline: YN, objectLeft: $N, objectRight: QN, objectCenter: KN, objectBlockLeft: ZN, objectBlockRight: JN } = JC; const XN = { get inline() { return { name: "inline", title: "In line", icon: YN, modelElements: ["imageInline"], isDefault: true } }, get alignLeft() { return { name: "alignLeft", title: "Left aligned image", icon: $N, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" } }, get alignBlockLeft() { return { name: "alignBlockLeft", title: "Left aligned image", icon: ZN, modelElements: ["imageBlock"], className: "image-style-block-align-left" } }, get alignCenter() { return { name: "alignCenter", title: "Centered image", icon: KN, modelElements: ["imageBlock"], className: "image-style-align-center" } }, get alignRight() { return { name: "alignRight", title: "Right aligned image", icon: QN, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" } }, get alignBlockRight() { return { name: "alignBlockRight", title: "Right aligned image", icon: JN, modelElements: ["imageBlock"], className: "image-style-block-align-right" } }, get block() { return { name: "block", title: "Centered image", icon: KN, modelElements: ["imageBlock"], isDefault: true } }, get side() { return { name: "side", title: "Side image", icon: QN, modelElements: ["imageBlock"], className: "image-style-side" } } }; const tB = { full: qN, left: ZN, right: JN, center: KN, inlineLeft: $N, inlineRight: QN, inline: YN }; const eB = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }]; function nB(t) { const e = t.configuredStyles.options || []; const n = e.map((t => rB(t))).filter((e => sB(e, t))); return n } function iB(t, e) { if (t && e) { return { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } } else if (t) { return { options: ["block", "side"] } } else if (e) { return { options: ["inline", "alignLeft", "alignRight"] } } return {} } function oB(t) { if (t.has("ImageBlockEditing") && t.has("ImageInlineEditing")) { return [...eB] } else { return [] } } function rB(t) { if (typeof t === "string") { if (!XN[t]) { t = { name: t } } else { t = { ...XN[t] } } } else { t = aB(XN[t.name], t) } if (typeof t.icon === "string") { t.icon = tB[t.icon] || t.icon } return t } function sB(t, { isBlockPluginLoaded: e, isInlinePluginLoaded: n }) { const { modelElements: i, name: o } = t; if (!i || !i.length || !o) { cB({ style: t }); return false } else { const o = [e ? "imageBlock" : null, n ? "imageInline" : null]; if (!i.some((t => o.includes(t)))) { P("image-style-missing-dependency", { style: t, missingPlugins: i.map((t => t === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")) }); return false } } return true } function aB(t, e) { const n = { ...e }; for (const i in t) { if (!Object.prototype.hasOwnProperty.call(e, i)) { n[i] = t[i] } } return n } function cB(t) { P("image-style-configuration-definition-invalid", t) } const lB = { normalizeStyles: nB, getDefaultStylesConfiguration: iB, getDefaultDropdownDefinitions: oB, warnInvalidStyle: cB, DEFAULT_OPTIONS: XN, DEFAULT_ICONS: tB, DEFAULT_DROPDOWN_DEFINITIONS: eB }; function dB(t) { return (e, n, i) => { if (!i.consumable.consume(n.item, e.name)) { return } const o = hB(n.attributeNewValue, t); const r = hB(n.attributeOldValue, t); const s = i.mapper.toViewElement(n.item); const a = i.writer; if (r) { a.removeClass(r.className, s) } if (o) { a.addClass(o.className, s) } } } function uB(t) { const e = { imageInline: t.filter((t => !t.isDefault && t.modelElements.includes("imageInline"))), imageBlock: t.filter((t => !t.isDefault && t.modelElements.includes("imageBlock"))) }; return (t, n, i) => { if (!n.modelRange) { return } const o = n.viewItem; const r = ll(n.modelRange.getItems()); if (!r) { return } if (!i.schema.checkAttribute(r, "imageStyle")) { return } for (const t of e[r.name]) { if (i.consumable.consume(o, { classes: t.className })) { i.writer.setAttribute("imageStyle", t.name, r) } } } } function hB(t, e) { for (const n of e) { if (n.name === t) { return n } } } class fB extends Kd { static get pluginName() { return "ImageStyleEditing" } static get requires() { return [PM] } init() { const { normalizeStyles: t, getDefaultStylesConfiguration: e } = lB; const n = this.editor; const i = n.plugins.has("ImageBlockEditing"); const o = n.plugins.has("ImageInlineEditing"); n.config.define("image.styles", e(i, o)); this.normalizedStyles = t({ configuredStyles: n.config.get("image.styles"), isBlockPluginLoaded: i, isInlinePluginLoaded: o }); this._setupConversion(i, o); this._setupPostFixer(); n.commands.add("imageStyle", new GN(n, this.normalizedStyles)) } _setupConversion(t, e) { const n = this.editor; const i = n.model.schema; const o = dB(this.normalizedStyles); const r = uB(this.normalizedStyles); n.editing.downcastDispatcher.on("attribute:imageStyle", o); n.data.downcastDispatcher.on("attribute:imageStyle", o); if (t) { i.extend("imageBlock", { allowAttributes: "imageStyle" }); n.data.upcastDispatcher.on("element:figure", r, { priority: "low" }) } if (e) { i.extend("imageInline", { allowAttributes: "imageStyle" }); n.data.upcastDispatcher.on("element:img", r, { priority: "low" }) } } _setupPostFixer() { const t = this.editor; const e = t.model.document; const n = t.plugins.get(PM); const i = new Map(this.normalizedStyles.map((t => [t.name, t]))); e.registerPostFixer((t => { let o = false; for (const r of e.differ.getChanges()) { if (r.type == "insert" || r.type == "attribute" && r.attributeKey == "imageStyle") { let e = r.type == "insert" ? r.position.nodeAfter : r.range.start.nodeAfter; if (e && e.is("element", "paragraph") && e.childCount > 0) { e = e.getChild(0) } if (!n.isImage(e)) { continue } const s = e.getAttribute("imageStyle"); if (!s) { continue } const a = i.get(s); if (!a || !a.modelElements.includes(e.name)) { t.removeAttribute("imageStyle", e); o = true } } } return o })) } } var gB = n(4622); var mB = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; mB.insert = "head"; mB.singleton = true; var pB = Dl()(gB.Z, mB); const kB = gB.Z.locals || {}; class bB extends Kd { static get requires() { return [fB] } static get pluginName() { return "ImageStyleUI" } get localizedDefaultStylesTitles() { const t = this.editor.t; return { "Wrap text": t("Wrap text"), "Break text": t("Break text"), "In line": t("In line"), "Full size image": t("Full size image"), "Side image": t("Side image"), "Left aligned image": t("Left aligned image"), "Centered image": t("Centered image"), "Right aligned image": t("Right aligned image") } } init() { const t = this.editor.plugins; const e = this.editor.config.get("image.toolbar") || []; const n = t.get("ImageStyleEditing"); const i = wB(n.normalizedStyles, this.localizedDefaultStylesTitles); for (const t of i) { this._createButton(t) } const o = wB([...e.filter(st), ...lB.getDefaultDropdownDefinitions(t)], this.localizedDefaultStylesTitles); for (const t of o) { this._createDropdown(t, i) } } _createDropdown(t, e) { const n = this.editor.ui.componentFactory; n.add(t.name, (i => { let o; const { defaultItem: r, items: s, title: a } = t; const c = s.filter((t => e.find((({ name: e }) => _B(e) === t)))).map((t => { const e = n.create(t); if (t === r) { o = e } return e })); if (s.length !== c.length) { lB.warnInvalidStyle({ dropdown: t }) } const l = yv(i, Ud); const d = l.buttonView; const u = d.arrowView; xv(l, c, { enableActiveItemFocusOnDropdownOpen: true }); d.set({ label: AB(a, o.label), class: null, tooltip: true }); u.unbind("label"); u.set({ label: a }); d.bind("icon").toMany(c, "isOn", ((...t) => { const e = t.findIndex(Hh); return e < 0 ? o.icon : c[e].icon })); d.bind("label").toMany(c, "isOn", ((...t) => { const e = t.findIndex(Hh); return AB(a, e < 0 ? o.label : c[e].label) })); d.bind("isOn").toMany(c, "isOn", ((...t) => t.some(Hh))); d.bind("class").toMany(c, "isOn", ((...t) => t.some(Hh) ? "ck-splitbutton_flatten" : undefined)); d.on("execute", (() => { if (!c.some((({ isOn: t }) => t))) { o.fire("execute") } else { l.isOpen = !l.isOpen } })); l.bind("isEnabled").toMany(c, "isEnabled", ((...t) => t.some(Hh))); this.listenTo(l, "execute", (() => { this.editor.editing.view.focus() })); return l })) } _createButton(t) { const e = t.name; this.editor.ui.componentFactory.add(_B(e), (n => { const i = this.editor.commands.get("imageStyle"); const o = new kd(n); o.set({ label: t.title, icon: t.icon, tooltip: true, isToggleable: true }); o.bind("isEnabled").to(i, "isEnabled"); o.bind("isOn").to(i, "value", (t => t === e)); o.on("execute", this._executeCommand.bind(this, e)); return o })) } _executeCommand(t) { this.editor.execute("imageStyle", { value: t }); this.editor.editing.view.focus() } } function wB(t, e) { for (const n of t) { if (e[n.title]) { n.title = e[n.title] } } return t } function _B(t) { return `imageStyle:${t}` } function AB(t, e) { return (t ? t + ": " : "") + e } class CB extends Kd { static get requires() { return [fB, bB] } static get pluginName() { return "ImageStyle" } } class vB extends Kd { static get requires() { return [AI, PM] } static get pluginName() { return "ImageToolbar" } afterInit() { const t = this.editor; const e = t.t; const n = t.plugins.get(AI); const i = t.plugins.get("ImageUtils"); n.register("image", { ariaLabel: e("Image toolbar"), items: yB(t.config.get("image.toolbar") || []), getRelatedElement: t => i.getClosestSelectedImageWidget(t) }) } } function yB(t) { return t.map((t => st(t) ? t.name : t)) } class xB extends Kd { static get pluginName() { return "IndentEditing" } init() { const t = this.editor; t.commands.add("indent", new tu(t)); t.commands.add("outdent", new tu(t)) } } const EB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>'; const DB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>'; class IB extends Kd { static get pluginName() { return "IndentUI" } init() { const t = this.editor; const e = t.locale; const n = t.t; const i = e.uiLanguageDirection == "ltr" ? EB : DB; const o = e.uiLanguageDirection == "ltr" ? DB : EB; this._defineButton("indent", n("Increase indent"), i); this._defineButton("outdent", n("Decrease indent"), o) } _defineButton(t, e, n) { const i = this.editor; i.ui.componentFactory.add(t, (o => { const r = i.commands.get(t); const s = new kd(o); s.set({ label: e, icon: n, tooltip: true }); s.bind("isEnabled").to(r, "isEnabled"); this.listenTo(s, "execute", (() => { i.execute(t); i.editing.view.focus() })); return s })) } } class TB extends Kd { static get pluginName() { return "Indent" } static get requires() { return [xB, IB] } } class MB extends Jd { constructor(t, e) { super(t); this._indentBehavior = e } refresh() { const t = this.editor; const e = t.model; const n = ll(e.document.selection.getSelectedBlocks()); if (!n || !e.schema.checkAttribute(n, "blockIndent")) { this.isEnabled = false; return } this.isEnabled = this._indentBehavior.checkEnabled(n.getAttribute("blockIndent")) } execute() { const t = this.editor.model; const e = SB(t); t.change((t => { for (const n of e) { const e = n.getAttribute("blockIndent"); const i = this._indentBehavior.getNextIndent(e); if (i) { t.setAttribute("blockIndent", i, n) } else { t.removeAttribute("blockIndent", n) } } })) } } function SB(t) { const e = t.document.selection; const n = t.schema; const i = Array.from(e.getSelectedBlocks()); return i.filter((t => n.checkAttribute(t, "blockIndent"))) } class NB { constructor(t) { this.isForward = t.direction === "forward"; this.offset = t.offset; this.unit = t.unit } checkEnabled(t) { const e = parseFloat(t || "0"); return this.isForward || e > 0 } getNextIndent(t) { const e = parseFloat(t || "0"); const n = !t || t.endsWith(this.unit); if (!n) { return this.isForward ? this.offset + this.unit : undefined } const i = this.isForward ? this.offset : -this.offset; const o = e + i; return o > 0 ? o + this.unit : undefined } } class BB { constructor(t) { this.isForward = t.direction === "forward"; this.classes = t.classes } checkEnabled(t) { const e = this.classes.indexOf(t); if (this.isForward) { return e < this.classes.length - 1 } else { return e >= 0 } } getNextIndent(t) { const e = this.classes.indexOf(t); const n = this.isForward ? 1 : -1; return this.classes[e + n] } } const zB = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"]; class PB extends Kd { constructor(t) { super(t); t.config.define("indentBlock", { offset: 40, unit: "px" }) } static get pluginName() { return "IndentBlock" } init() { const t = this.editor; const e = t.config.get("indentBlock"); if (e.classes && e.classes.length) { this._setupConversionUsingClasses(e.classes); t.commands.add("indentBlock", new MB(t, new BB({ direction: "forward", classes: e.classes }))); t.commands.add("outdentBlock", new MB(t, new BB({ direction: "backward", classes: e.classes }))) } else { t.data.addStyleProcessorRules(aC); this._setupConversionUsingOffset(); t.commands.add("indentBlock", new MB(t, new NB({ direction: "forward", offset: e.offset, unit: e.unit }))); t.commands.add("outdentBlock", new MB(t, new NB({ direction: "backward", offset: e.offset, unit: e.unit }))) } } afterInit() { const t = this.editor; const e = t.model.schema; const n = t.commands.get("indent"); const i = t.commands.get("outdent"); const o = t.config.get("heading.options"); const r = o && o.map((t => t.model)); const s = r || zB; s.forEach((t => { if (e.isRegistered(t)) { e.extend(t, { allowAttributes: "blockIndent" }) } })); e.setAttributeProperties("blockIndent", { isFormatting: true }); n.registerChildCommand(t.commands.get("indentBlock")); i.registerChildCommand(t.commands.get("outdentBlock")) } _setupConversionUsingOffset() { const t = this.editor.conversion; const e = this.editor.locale; const n = e.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left"; t.for("upcast").attributeToAttribute({ view: { styles: { [n]: /[\s\S]+/ } }, model: { key: "blockIndent", value: t => t.getStyle(n) } }); t.for("downcast").attributeToAttribute({ model: "blockIndent", view: t => ({ key: "style", value: { [n]: t } }) }) } _setupConversionUsingClasses(t) { const e = { model: { key: "blockIndent", values: [] }, view: {} }; for (const n of t) { e.model.values.push(n); e.view[n] = { key: "class", value: [n] } } this.editor.conversion.attributeToAttribute(e) } } const LB = "italic"; class OB extends Kd { static get pluginName() { return "ItalicEditing" } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: LB }); t.model.schema.setAttributeProperties(LB, { isFormatting: true, copyOnEnter: true }); t.conversion.attributeToElement({ model: LB, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }); t.commands.add(LB, new uD(t, LB)); t.keystrokes.set("CTRL+I", LB) } } const RB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>'; const jB = "italic"; class VB extends Kd { static get pluginName() { return "ItalicUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(jB, (n => { const i = t.commands.get(jB); const o = new kd(n); o.set({ label: e("Italic"), icon: RB, keystroke: "CTRL+I", tooltip: true, isToggleable: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(jB); t.editing.view.focus() })); return o })) } } class FB extends Kd { static get requires() { return [OB, VB] } static get pluginName() { return "Italic" } } class HB { constructor() { this._definitions = new Set } get length() { return this._definitions.size } add(t) { if (Array.isArray(t)) { t.forEach((t => this._definitions.add(t))) } else { this._definitions.add(t) } } getDispatcher() { return t => { t.on("attribute:linkHref", ((t, e, n) => { if (!n.consumable.test(e.item, "attribute:linkHref")) { return } if (!(e.item.is("selection") || n.schema.isInline(e.item))) { return } const i = n.writer; const o = i.document.selection; for (const t of this._definitions) { const r = i.createAttributeElement("a", t.attributes, { priority: 5 }); if (t.classes) { i.addClass(t.classes, r) } for (const e in t.styles) { i.setStyle(e, t.styles[e], r) } i.setCustomProperty("link", true, r); if (t.callback(e.attributeNewValue)) { if (e.item.is("selection")) { i.wrap(o.getFirstRange(), r) } else { i.wrap(n.mapper.toViewRange(e.range), r) } } else { i.unwrap(n.mapper.toViewRange(e.range), r) } } }), { priority: "high" }) } } getDispatcherForLinkedImage() { return t => { t.on("attribute:linkHref:imageBlock", ((t, e, { writer: n, mapper: i }) => { const o = i.toViewElement(e.item); const r = Array.from(o.getChildren()).find((t => t.is("element", "a"))); for (const t of this._definitions) { const i = fl(t.attributes); if (t.callback(e.attributeNewValue)) { for (const [t, e] of i) { if (t === "class") { n.addClass(e, r) } else { n.setAttribute(t, e, r) } } if (t.classes) { n.addClass(t.classes, r) } for (const e in t.styles) { n.setStyle(e, t.styles[e], r) } } else { for (const [t, e] of i) { if (t === "class") { n.removeClass(e, r) } else { n.removeAttribute(t, r) } } if (t.classes) { n.removeClass(t.classes, r) } for (const e in t.styles) { n.removeStyle(e, r) } } } })) } } } function UB(t, e, n) { var i = t.length; n = n === undefined ? i : n; return !e && n >= i ? t : ph(t, e, n) } const WB = UB; var GB = "\\ud800-\\udfff", qB = "\\u0300-\\u036f", YB = "\\ufe20-\\ufe2f", $B = "\\u20d0-\\u20ff", QB = qB + YB + $B, KB = "\\ufe0e\\ufe0f"; var ZB = "\\u200d"; var JB = RegExp("[" + ZB + GB + QB + KB + "]"); function XB(t) { return JB.test(t) } const tz = XB; function ez(t) { return t.split("") } const nz = ez; var iz = "\\ud800-\\udfff", oz = "\\u0300-\\u036f", rz = "\\ufe20-\\ufe2f", sz = "\\u20d0-\\u20ff", az = oz + rz + sz, cz = "\\ufe0e\\ufe0f"; var lz = "[" + iz + "]", dz = "[" + az + "]", uz = "\\ud83c[\\udffb-\\udfff]", hz = "(?:" + dz + "|" + uz + ")", fz = "[^" + iz + "]", gz = "(?:\\ud83c[\\udde6-\\uddff]){2}", mz = "[\\ud800-\\udbff][\\udc00-\\udfff]", pz = "\\u200d"; var kz = hz + "?", bz = "[" + cz + "]?", wz = "(?:" + pz + "(?:" + [fz, gz, mz].join("|") + ")" + bz + kz + ")*", _z = bz + kz + wz, Az = "(?:" + [fz + dz + "?", dz, gz, mz, lz].join("|") + ")"; var Cz = RegExp(uz + "(?=" + uz + ")|" + Az + _z, "g"); function vz(t) { return t.match(Cz) || [] } const yz = vz; function xz(t) { return tz(t) ? yz(t) : nz(t) } const Ez = xz; function Dz(t) { return function (e) { e = rh(e); var n = tz(e) ? Ez(e) : undefined; var i = n ? n[0] : e.charAt(0); var o = n ? WB(n, 1).join("") : e.slice(1); return i[t]() + o } } const Iz = Dz; var Tz = Iz("toUpperCase"); const Mz = Tz; const Sz = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; const Nz = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i; const Bz = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i; const zz = /^((\w+:(\/{2,})?)|(\W))/i; const Pz = "Ctrl+K"; function Lz(t) { return t.is("attributeElement") && !!t.getCustomProperty("link") } function Oz(t, { writer: e }) { const n = e.createAttributeElement("a", { href: t }, { priority: 5 }); e.setCustomProperty("link", true, n); return n } function Rz(t) { const e = String(t); return jz(e) ? e : "#" } function jz(t) { const e = t.replace(Sz, ""); return !!e.match(Nz) } function Vz(t, e) { const n = { "Open in a new tab": t("Open in a new tab"), Downloadable: t("Downloadable") }; e.forEach((t => { if ("label" in t && n[t.label]) { t.label = n[t.label] } return t })); return e } function Fz(t) { const e = []; if (t) { for (const [n, i] of Object.entries(t)) { const t = Object.assign({}, i, { id: `link${Mz(n)}` }); e.push(t) } } return e } function Hz(t, e) { if (!t) { return false } return e.checkAttribute(t.name, "linkHref") } function Uz(t) { return Bz.test(t) } function Wz(t, e) { const n = Uz(t) ? "mailto:" : e; const i = !!n && !Gz(t); return t && i ? n + t : t } function Gz(t) { return zz.test(t) } function qz(t) { window.open(t, "_blank", "noopener") } class Yz extends Jd { constructor() { super(...arguments); this.manualDecorators = new cl; this.automaticDecorators = new HB } restoreManualDecoratorStates() { for (const t of this.manualDecorators) { t.value = this._getDecoratorStateFromModel(t.id) } } refresh() { const t = this.editor.model; const e = t.document.selection; const n = e.getSelectedElement() || ll(e.getSelectedBlocks()); if (Hz(n, t.schema)) { this.value = n.getAttribute("linkHref"); this.isEnabled = t.schema.checkAttribute(n, "linkHref") } else { this.value = e.getAttribute("linkHref"); this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref") } for (const t of this.manualDecorators) { t.value = this._getDecoratorStateFromModel(t.id) } } execute(t, e = {}) { const n = this.editor.model; const i = n.document.selection; const o = []; const r = []; for (const t in e) { if (e[t]) { o.push(t) } else { r.push(t) } } n.change((e => { if (i.isCollapsed) { const s = i.getFirstPosition(); if (i.hasAttribute("linkHref")) { const a = $z(i); let c = ZE(s, "linkHref", i.getAttribute("linkHref"), n); if (i.getAttribute("linkHref") === a) { c = this._updateLinkContent(n, e, c, t) } e.setAttribute("linkHref", t, c); o.forEach((t => { e.setAttribute(t, true, c) })); r.forEach((t => { e.removeAttribute(t, c) })); e.setSelection(e.createPositionAfter(c.end.nodeBefore)) } else if (t !== "") { const r = fl(i.getAttributes()); r.set("linkHref", t); o.forEach((t => { r.set(t, true) })); const { end: a } = n.insertContent(e.createText(t, r), s); e.setSelection(a) } ["linkHref", ...o, ...r].forEach((t => { e.removeSelectionAttribute(t) })) } else { const s = n.schema.getValidRanges(i.getRanges(), "linkHref"); const a = []; for (const t of i.getSelectedBlocks()) { if (n.schema.checkAttribute(t, "linkHref")) { a.push(e.createRangeOn(t)) } } const c = a.slice(); for (const t of s) { if (this._isRangeToUpdate(t, a)) { c.push(t) } } for (const s of c) { let a = s; if (c.length === 1) { const o = $z(i); if (i.getAttribute("linkHref") === o) { a = this._updateLinkContent(n, e, s, t); e.setSelection(e.createSelection(a)) } } e.setAttribute("linkHref", t, a); o.forEach((t => { e.setAttribute(t, true, a) })); r.forEach((t => { e.removeAttribute(t, a) })) } } })) } _getDecoratorStateFromModel(t) { const e = this.editor.model; const n = e.document.selection; const i = n.getSelectedElement(); if (Hz(i, e.schema)) { return i.getAttribute(t) } return n.getAttribute(t) } _isRangeToUpdate(t, e) { for (const n of e) { if (n.containsRange(t)) { return false } } return true } _updateLinkContent(t, e, n, i) { const o = e.createText(i, { linkHref: i }); return t.insertContent(o, n) } } function $z(t) { if (t.isCollapsed) { const e = t.getFirstPosition(); return e.textNode && e.textNode.data } else { const e = Array.from(t.getFirstRange().getItems()); if (e.length > 1) { return null } const n = e[0]; if (n.is("$text") || n.is("$textProxy")) { return n.data } return null } } class Qz extends Jd { refresh() { const t = this.editor.model; const e = t.document.selection; const n = e.getSelectedElement(); if (Hz(n, t.schema)) { this.isEnabled = t.schema.checkAttribute(n, "linkHref") } else { this.isEnabled = t.schema.checkAttributeInSelection(e, "linkHref") } } execute() { const t = this.editor; const e = this.editor.model; const n = e.document.selection; const i = t.commands.get("link"); e.change((t => { const o = n.isCollapsed ? [ZE(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), e)] : e.schema.getValidRanges(n.getRanges(), "linkHref"); for (const e of o) { t.removeAttribute("linkHref", e); if (i) { for (const n of i.manualDecorators) { t.removeAttribute(n.id, e) } } } })) } } class Kz extends (ft()) { constructor({ id: t, label: e, attributes: n, classes: i, styles: o, defaultValue: r }) { super(); this.id = t; this.set("value", undefined); this.defaultValue = r; this.label = e; this.attributes = n; this.classes = i; this.styles = o } _createPattern() { return { attributes: this.attributes, classes: this.classes, styles: this.styles } } } var Zz = n(399); var Jz = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; Jz.insert = "head"; Jz.singleton = true; var Xz = Dl()(Zz.Z, Jz); const tP = Zz.Z.locals || {}; const eP = "ck-link_selected"; const nP = "automatic"; const iP = "manual"; const oP = /^(https?:)?\/\//; class rP extends Kd { static get pluginName() { return "LinkEditing" } static get requires() { return [PE, bE, vD] } constructor(t) { super(t); t.config.define("link", { addTargetToExternalLinks: false }) } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: "linkHref" }); t.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: Oz }); t.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (t, e) => Oz(Rz(t), e) }); t.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: true } }, model: { key: "linkHref", value: t => t.getAttribute("href") } }); t.commands.add("link", new Yz(t)); t.commands.add("unlink", new Qz(t)); const e = Vz(t.t, Fz(t.config.get("link.decorators"))); this._enableAutomaticDecorators(e.filter((t => t.mode === nP))); this._enableManualDecorators(e.filter((t => t.mode === iP))); const n = t.plugins.get(PE); n.registerAttribute("linkHref"); XE(t, "linkHref", "a", eP); this._enableLinkOpen(); this._enableInsertContentSelectionAttributesFixer(); this._enableClickingAfterLink(); this._enableTypingOverLink(); this._handleDeleteContentAfterLink(); this._enableClipboardIntegration() } _enableAutomaticDecorators(t) { const e = this.editor; const n = e.commands.get("link"); const i = n.automaticDecorators; if (e.config.get("link.addTargetToExternalLinks")) { i.add({ id: "linkIsExternal", mode: nP, callback: t => !!t && oP.test(t), attributes: { target: "_blank", rel: "noopener noreferrer" } }) } i.add(t); if (i.length) { e.conversion.for("downcast").add(i.getDispatcher()) } } _enableManualDecorators(t) { if (!t.length) { return } const e = this.editor; const n = e.commands.get("link"); const i = n.manualDecorators; t.forEach((t => { e.model.schema.extend("$text", { allowAttributes: t.id }); const n = new Kz(t); i.add(n); e.conversion.for("downcast").attributeToElement({ model: n.id, view: (t, { writer: e, schema: i }, { item: o }) => { if (!(o.is("selection") || i.isInline(o))) { return } if (t) { const t = e.createAttributeElement("a", n.attributes, { priority: 5 }); if (n.classes) { e.addClass(n.classes, t) } for (const i in n.styles) { e.setStyle(i, n.styles[i], t) } e.setCustomProperty("link", true, t); return t } } }); e.conversion.for("upcast").elementToAttribute({ view: { name: "a", ...n._createPattern() }, model: { key: n.id } }) })) } _enableLinkOpen() { const t = this.editor; const e = t.editing.view; const n = e.document; this.listenTo(n, "click", ((t, e) => { const n = l.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey; if (!n) { return } let i = e.domTarget; if (i.tagName.toLowerCase() != "a") { i = i.closest("a") } if (!i) { return } const o = i.getAttribute("href"); if (!o) { return } t.stop(); e.preventDefault(); qz(o) }), { context: "$capture" }); this.listenTo(n, "keydown", ((e, n) => { const i = t.commands.get("link"); const o = i.value; const r = !!o && n.keyCode === Fc.enter && n.altKey; if (!r) { return } e.stop(); qz(o) })) } _enableInsertContentSelectionAttributesFixer() { const t = this.editor; const e = t.model; const n = e.document.selection; this.listenTo(e, "insertContent", (() => { const t = n.anchor.nodeBefore; const i = n.anchor.nodeAfter; if (!n.hasAttribute("linkHref")) { return } if (!t) { return } if (!t.hasAttribute("linkHref")) { return } if (i && i.hasAttribute("linkHref")) { return } e.change((t => { sP(t, lP(e.schema)) })) }), { priority: "low" }) } _enableClickingAfterLink() { const t = this.editor; const e = t.model; t.editing.view.addObserver(kA); let n = false; this.listenTo(t.editing.view.document, "mousedown", (() => { n = true })); this.listenTo(t.editing.view.document, "selectionChange", (() => { if (!n) { return } n = false; const t = e.document.selection; if (!t.isCollapsed) { return } if (!t.hasAttribute("linkHref")) { return } const i = t.getFirstPosition(); const o = ZE(i, "linkHref", t.getAttribute("linkHref"), e); if (i.isTouching(o.start) || i.isTouching(o.end)) { e.change((t => { sP(t, lP(e.schema)) })) } })) } _enableTypingOverLink() { const t = this.editor; const e = t.editing.view; let n = null; let i = false; this.listenTo(e.document, "delete", (() => { i = true }), { priority: "high" }); this.listenTo(t.model, "deleteContent", (() => { const e = t.model.document.selection; if (e.isCollapsed) { return } if (i) { i = false; return } if (!cP(t)) { return } if (aP(t.model)) { n = e.getAttributes() } }), { priority: "high" }); this.listenTo(t.model, "insertContent", ((e, [o]) => { i = false; if (!cP(t)) { return } if (!n) { return } t.model.change((t => { for (const [e, i] of n) { t.setAttribute(e, i, o) } })); n = null }), { priority: "high" }) } _handleDeleteContentAfterLink() { const t = this.editor; const e = t.model; const n = e.document.selection; const i = t.editing.view; let o = false; let r = false; this.listenTo(i.document, "delete", ((t, e) => { r = e.direction === "backward" }), { priority: "high" }); this.listenTo(e, "deleteContent", (() => { o = false; const t = n.getFirstPosition(); const i = n.getAttribute("linkHref"); if (!i) { return } const r = ZE(t, "linkHref", i, e); o = r.containsPosition(t) || r.end.isEqual(t) }), { priority: "high" }); this.listenTo(e, "deleteContent", (() => { if (!r) { return } r = false; if (o) { return } t.model.enqueueChange((t => { sP(t, lP(e.schema)) })) }), { priority: "low" }) } _enableClipboardIntegration() { const t = this.editor; const e = t.model; const n = this.editor.config.get("link.defaultProtocol"); if (!n) { return } this.listenTo(t.plugins.get("ClipboardPipeline"), "contentInsertion", ((t, i) => { e.change((t => { const e = t.createRangeIn(i.content); for (const i of e.getItems()) { if (i.hasAttribute("linkHref")) { const e = Wz(i.getAttribute("linkHref"), n); t.setAttribute("linkHref", e, i) } } })) })) } } function sP(t, e) { t.removeSelectionAttribute("linkHref"); for (const n of e) { t.removeSelectionAttribute(n) } } function aP(t) { const e = t.document.selection; const n = e.getFirstPosition(); const i = e.getLastPosition(); const o = n.nodeAfter; if (!o) { return false } if (!o.is("$text")) { return false } if (!o.hasAttribute("linkHref")) { return false } const r = i.textNode || i.nodeBefore; if (o === r) { return true } const s = ZE(n, "linkHref", o.getAttribute("linkHref"), t); return s.containsRange(t.createRange(n, i), true) } function cP(t) { const e = t.model.change((t => t.batch)); return e.isTyping } function lP(t) { const e = t.getDefinition("$text").allowAttributes; return e.filter((t => t.startsWith("link"))) } var dP = n(4827); var uP = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; uP.insert = "head"; uP.singleton = true; var hP = Dl()(dP.Z, uP); const fP = dP.Z.locals || {}; class gP extends Nl { constructor(t, e) { super(t); this.focusTracker = new dl; this.keystrokes = new ul; this._focusables = new yl; const n = t.t; this.urlInputView = this._createUrlInput(); this.saveButtonView = this._createButton(n("Save"), JC.check, "ck-button-save"); this.saveButtonView.type = "submit"; this.cancelButtonView = this._createButton(n("Cancel"), JC.cancel, "ck-button-cancel", "cancel"); this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e); this.children = this._createFormChildren(e.manualDecorators); this._focusCycler = new Wd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); const i = ["ck", "ck-link-form", "ck-responsive-form"]; if (e.manualDecorators.length) { i.push("ck-link-form_layout-vertical", "ck-vertical-form") } this.setTemplate({ tag: "form", attributes: { class: i, tabindex: "-1" }, children: this.children }) } getDecoratorSwitchesState() { return Array.from(this._manualDecoratorSwitches).reduce(((t, e) => { t[e.name] = e.isOn; return t }), {}) } render() { super.render(); o({ view: this }); const t = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView]; t.forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } _createUrlInput() { const t = this.locale.t; const e = new By(this.locale, zy); e.label = t("Link URL"); return e } _createButton(t, e, n, i) { const o = new kd(this.locale); o.set({ label: t, icon: e, tooltip: true }); o.extendTemplate({ attributes: { class: n } }); if (i) { o.delegate("execute").to(this, i) } return o } _createManualDecoratorSwitches(t) { const e = this.createCollection(); for (const n of t.manualDecorators) { const i = new Cd(this.locale); i.set({ name: n.id, label: n.label, withText: true }); i.bind("isOn").toMany([n, t], "value", ((t, e) => e === undefined && t === undefined ? !!n.defaultValue : !!t)); i.on("execute", (() => { n.set("value", !i.isOn) })); e.add(i) } return e } _createFormChildren(t) { const e = this.createCollection(); e.add(this.urlInputView); if (t.length) { const t = new Nl; t.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((t => ({ tag: "li", children: [t], attributes: { class: ["ck", "ck-list__item"] } }))), attributes: { class: ["ck", "ck-reset", "ck-list"] } }); e.add(t) } e.add(this.saveButtonView); e.add(this.cancelButtonView); return e } } var mP = n(9465); var pP = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; pP.insert = "head"; pP.singleton = true; var kP = Dl()(mP.Z, pP); const bP = mP.Z.locals || {}; const wP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>'; class _P extends Nl { constructor(t) { super(t); this.focusTracker = new dl; this.keystrokes = new ul; this._focusables = new yl; const e = t.t; this.previewButtonView = this._createPreviewButton(); this.unlinkButtonView = this._createButton(e("Unlink"), wP, "unlink"); this.editButtonView = this._createButton(e("Edit link"), JC.pencil, "edit"); this.set("href", undefined); this._focusCycler = new Wd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] }) } render() { super.render(); const t = [this.previewButtonView, this.editButtonView, this.unlinkButtonView]; t.forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } _createButton(t, e, n) { const i = new kd(this.locale); i.set({ label: t, icon: e, tooltip: true }); i.delegate("execute").to(this, n); return i } _createPreviewButton() { const t = new kd(this.locale); const e = this.bindTemplate; const n = this.t; t.set({ withText: true, tooltip: n("Open link in new tab") }); t.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: e.to("href", (t => t && Rz(t))), target: "_blank", rel: "noopener noreferrer" } }); t.bind("label").to(this, "href", (t => t || n("This link has no URL"))); t.bind("isEnabled").to(this, "href", (t => !!t)); t.template.tag = "a"; t.template.eventListeners = {}; return t } } const AP = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>'; const CP = "link-ui"; class vP extends Kd { constructor() { super(...arguments); this.actionsView = null; this.formView = null } static get requires() { return [Ky] } static get pluginName() { return "LinkUI" } init() { const t = this.editor; t.editing.view.addObserver(pA); this._balloon = t.plugins.get(Ky); this._createToolbarLinkButton(); this._enableBalloonActivators(); t.conversion.for("editingDowncast").markerToHighlight({ model: CP, view: { classes: ["ck-fake-link-selection"] } }); t.conversion.for("editingDowncast").markerToElement({ model: CP, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } }) } destroy() { super.destroy(); if (this.formView) { this.formView.destroy() } if (this.actionsView) { this.actionsView.destroy() } } _createViews() { this.actionsView = this._createActionsView(); this.formView = this._createFormView(); this._enableUserBalloonInteractions() } _createActionsView() { const t = this.editor; const e = new _P(t.locale); const n = t.commands.get("link"); const i = t.commands.get("unlink"); e.bind("href").to(n, "value"); e.editButtonView.bind("isEnabled").to(n); e.unlinkButtonView.bind("isEnabled").to(i); this.listenTo(e, "edit", (() => { this._addFormView() })); this.listenTo(e, "unlink", (() => { t.execute("unlink"); this._hideUI() })); e.keystrokes.set("Esc", ((t, e) => { this._hideUI(); e() })); e.keystrokes.set(Pz, ((t, e) => { this._addFormView(); e() })); return e } _createFormView() { const t = this.editor; const n = t.commands.get("link"); const i = t.config.get("link.defaultProtocol"); const o = new (e(gP))(t.locale, n); o.urlInputView.fieldView.bind("value").to(n, "value"); o.urlInputView.bind("isEnabled").to(n, "isEnabled"); o.saveButtonView.bind("isEnabled").to(n); this.listenTo(o, "submit", (() => { const { value: e } = o.urlInputView.fieldView.element; const n = Wz(e, i); t.execute("link", n, o.getDecoratorSwitchesState()); this._closeFormView() })); this.listenTo(o, "cancel", (() => { this._closeFormView() })); o.keystrokes.set("Esc", ((t, e) => { this._closeFormView(); e() })); return o } _createToolbarLinkButton() { const t = this.editor; const e = t.commands.get("link"); const n = t.t; t.ui.componentFactory.add("link", (t => { const i = new kd(t); i.isEnabled = true; i.label = n("Link"); i.icon = AP; i.keystroke = Pz; i.tooltip = true; i.isToggleable = true; i.bind("isEnabled").to(e, "isEnabled"); i.bind("isOn").to(e, "value", (t => !!t)); this.listenTo(i, "execute", (() => this._showUI(true))); return i })) } _enableBalloonActivators() { const t = this.editor; const e = t.editing.view.document; this.listenTo(e, "click", (() => { const t = this._getSelectedLinkElement(); if (t) { this._showUI() } })); t.keystrokes.set(Pz, ((e, n) => { n(); if (t.commands.get("link").isEnabled) { this._showUI(true) } })) } _enableUserBalloonInteractions() { this.editor.keystrokes.set("Tab", ((t, e) => { if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) { this.actionsView.focus(); e() } }), { priority: "high" }); this.editor.keystrokes.set("Esc", ((t, e) => { if (this._isUIVisible) { this._hideUI(); e() } })); t({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => this._hideUI() }) } _addActionsView() { if (!this.actionsView) { this._createViews() } if (this._areActionsInPanel) { return } this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() }) } _addFormView() { if (!this.formView) { this._createViews() } if (this._isFormInPanel) { return } const t = this.editor; const e = t.commands.get("link"); this.formView.disableCssTransitions(); this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }); if (this._balloon.visibleView === this.formView) { this.formView.urlInputView.fieldView.select() } this.formView.enableCssTransitions(); this.formView.urlInputView.fieldView.element.value = e.value || "" } _closeFormView() { const t = this.editor.commands.get("link"); t.restoreManualDecoratorStates(); if (t.value !== undefined) { this._removeFormView() } else { this._hideUI() } } _removeFormView() { if (this._isFormInPanel) { this.formView.saveButtonView.focus(); this._balloon.remove(this.formView); this.editor.editing.view.focus(); this._hideFakeVisualSelection() } } _showUI(t = false) { if (!this.formView) { this._createViews() } if (!this._getSelectedLinkElement()) { this._showFakeVisualSelection(); this._addActionsView(); if (t) { this._balloon.showStack("main") } this._addFormView() } else { if (this._areActionsVisible) { this._addFormView() } else { this._addActionsView() } if (t) { this._balloon.showStack("main") } } this._startUpdatingUI() } _hideUI() { if (!this._isUIInPanel) { return } const t = this.editor; this.stopListening(t.ui, "update"); this.stopListening(this._balloon, "change:visibleView"); t.editing.view.focus(); this._removeFormView(); this._balloon.remove(this.actionsView); this._hideFakeVisualSelection() } _startUpdatingUI() { const t = this.editor; const e = t.editing.view.document; let n = this._getSelectedLinkElement(); let i = r(); const o = () => { const t = this._getSelectedLinkElement(); const e = r(); if (n && !t || !n && e !== i) { this._hideUI() } else if (this._isUIVisible) { this._balloon.updatePosition(this._getBalloonPositionData()) } n = t; i = e }; function r() { return e.selection.focus.getAncestors().reverse().find((t => t.is("element"))) } this.listenTo(t.ui, "update", o); this.listenTo(this._balloon, "change:visibleView", o) } get _isFormInPanel() { return !!this.formView && this._balloon.hasView(this.formView) } get _areActionsInPanel() { return !!this.actionsView && this._balloon.hasView(this.actionsView) } get _areActionsVisible() { return !!this.actionsView && this._balloon.visibleView === this.actionsView } get _isUIInPanel() { return this._isFormInPanel || this._areActionsInPanel } get _isUIVisible() { const t = this._balloon.visibleView; return !!this.formView && t == this.formView || this._areActionsVisible } _getBalloonPositionData() { const t = this.editor.editing.view; const e = this.editor.model; const n = t.document; let i; if (e.markers.has(CP)) { const e = Array.from(this.editor.editing.mapper.markerNameToElements(CP)); const n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1])); i = t.domConverter.viewRangeToDom(n) } else { i = () => { const e = this._getSelectedLinkElement(); return e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(n.selection.getFirstRange()) } } return { target: i } } _getSelectedLinkElement() { const t = this.editor.editing.view; const e = t.document.selection; const n = e.getSelectedElement(); if (e.isCollapsed || n && SD(n)) { return yP(e.getFirstPosition()) } else { const n = e.getFirstRange().getTrimmed(); const i = yP(n.start); const o = yP(n.end); if (!i || i != o) { return null } if (t.createRangeIn(i).getTrimmed().isEqual(n)) { return i } else { return null } } } _showFakeVisualSelection() { const t = this.editor.model; t.change((e => { const n = t.document.selection.getFirstRange(); if (t.markers.has(CP)) { e.updateMarker(CP, { range: n }) } else { if (n.start.isAtEnd) { const i = n.start.getLastMatchingPosition((({ item: e }) => !t.schema.isContent(e)), { boundaries: n }); e.addMarker(CP, { usingOperation: false, affectsData: false, range: e.createRange(i, n.end) }) } else { e.addMarker(CP, { usingOperation: false, affectsData: false, range: n }) } } })) } _hideFakeVisualSelection() { const t = this.editor.model; if (t.markers.has(CP)) { t.change((t => { t.removeMarker(CP) })) } } } function yP(t) { return t.getAncestors().find((t => Lz(t))) || null } const xP = 4; const EP = new RegExp("(^|\\s)" + "(" + "(" + "(?:(?:(?:https?|ftp):)?\\/\\/)" + "(?:\\S+(?::\\S*)?@)?" + "(?:" + "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + "(" + "((?!www\\.)|(www\\.))" + "(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+" + "(?:[a-z\\u00a1-\\uffff]{2,63})" + ")" + ")" + "(?::\\d{2,5})?" + "(?:[/?#]\\S*)?" + ")" + "|" + "(" + "(www.|(\\S+@))" + "((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+" + "(?:[a-z\\u00a1-\\uffff]{2,63})" + ")" + ")$", "i"); const DP = 2; class IP extends Kd { static get requires() { return [SE] } static get pluginName() { return "AutoLink" } init() { const t = this.editor; const e = t.model.document.selection; e.on("change:range", (() => { this.isEnabled = !e.anchor.parent.is("element", "codeBlock") })); this._enableTypingHandling() } afterInit() { this._enableEnterHandling(); this._enableShiftEnterHandling() } _enableTypingHandling() { const t = this.editor; const e = new zE(t.model, (t => { if (!TP(t)) { return } const e = MP(t.substr(0, t.length - 1)); if (e) { return { url: e } } })); e.on("matched:data", ((e, n) => { const { batch: i, range: o, url: r } = n; if (!i.isTyping) { return } const s = o.end.getShiftedBy(-1); const a = s.getShiftedBy(-r.length); const c = t.model.createRange(a, s); this._applyAutoLink(r, c) })); e.bind("isEnabled").to(this) } _enableEnterHandling() { const t = this.editor; const e = t.model; const n = t.commands.get("enter"); if (!n) { return } n.on("execute", (() => { const t = e.document.selection.getFirstPosition(); if (!t.parent.previousSibling) { return } const n = e.createRangeIn(t.parent.previousSibling); this._checkAndApplyAutoLinkOnRange(n) })) } _enableShiftEnterHandling() { const t = this.editor; const e = t.model; const n = t.commands.get("shiftEnter"); if (!n) { return } n.on("execute", (() => { const t = e.document.selection.getFirstPosition(); const n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1)); this._checkAndApplyAutoLinkOnRange(n) })) } _checkAndApplyAutoLinkOnRange(t) { const e = this.editor.model; const { text: n, range: i } = BE(t, e); const o = MP(n); if (o) { const t = e.createRange(i.end.getShiftedBy(-o.length), i.end); this._applyAutoLink(o, t) } } _applyAutoLink(t, e) { const n = this.editor.model; const i = this.editor.config.get("link.defaultProtocol"); const o = Wz(t, i); if (!this.isEnabled || !SP(e, n) || !Gz(o) || NP(e)) { return } this._persistAutoLink(o, e) } _persistAutoLink(t, e) { const n = this.editor.model; const i = this.editor.plugins.get("Delete"); n.enqueueChange((o => { o.setAttribute("linkHref", t, e); n.enqueueChange((() => { i.requestUndoOnBackspace() })) })) } } function TP(t) { return t.length > xP && t[t.length - 1] === " " && t[t.length - 2] !== " " } function MP(t) { const e = EP.exec(t); return e ? e[DP] : null } function SP(t, e) { return e.schema.checkAttributeInSelection(e.createSelection(t), "linkHref") } function NP(t) { const e = t.start.nodeAfter; return !!e && e.hasAttribute("linkHref") } class BP extends Kd { static get requires() { return [rP, vP, IP] } static get pluginName() { return "Link" } } class zP extends Kd { static get requires() { return ["ImageEditing", "ImageUtils", rP] } static get pluginName() { return "LinkImageEditing" } init() { const t = this.editor; const e = t.model.schema; if (t.plugins.has("ImageBlockEditing")) { e.extend("imageBlock", { allowAttributes: ["linkHref"] }) } t.conversion.for("upcast").add(PP(t)); t.conversion.for("downcast").add(LP(t)); this._enableAutomaticDecorators(); this._enableManualDecorators() } _enableAutomaticDecorators() { const t = this.editor; const e = t.commands.get("link"); const n = e.automaticDecorators; if (n.length) { t.conversion.for("downcast").add(n.getDispatcherForLinkedImage()) } } _enableManualDecorators() { const t = this.editor; const e = t.commands.get("link"); for (const n of e.manualDecorators) { if (t.plugins.has("ImageBlockEditing")) { t.model.schema.extend("imageBlock", { allowAttributes: n.id }) } if (t.plugins.has("ImageInlineEditing")) { t.model.schema.extend("imageInline", { allowAttributes: n.id }) } t.conversion.for("downcast").add(OP(n)); t.conversion.for("upcast").add(RP(t, n)) } } } function PP(t) { const e = t.plugins.has("ImageInlineEditing"); const n = t.plugins.get("ImageUtils"); return t => { t.on("element:a", ((t, i, o) => { const r = i.viewItem; const s = n.findViewImgElement(r); if (!s) { return } const a = s.findAncestor((t => n.isBlockImageView(t))); if (e && !a) { return } const c = { attributes: ["href"] }; if (!o.consumable.consume(r, c)) { return } const l = r.getAttribute("href"); if (!l) { return } let d = i.modelCursor.parent; if (!d.is("element", "imageBlock")) { const t = o.convertItem(s, i.modelCursor); i.modelRange = t.modelRange; i.modelCursor = t.modelCursor; d = i.modelCursor.nodeBefore } if (d && d.is("element", "imageBlock")) { o.writer.setAttribute("linkHref", l, d) } }), { priority: "high" }) } } function LP(t) { const e = t.plugins.get("ImageUtils"); return t => { t.on("attribute:linkHref:imageBlock", ((t, n, i) => { if (!i.consumable.consume(n.item, t.name)) { return } const o = i.mapper.toViewElement(n.item); const r = i.writer; const s = Array.from(o.getChildren()).find((t => t.is("element", "a"))); const a = e.findViewImgElement(o); const c = a.parent.is("element", "picture") ? a.parent : a; if (s) { if (n.attributeNewValue) { r.setAttribute("href", n.attributeNewValue, s) } else { r.move(r.createRangeOn(c), r.createPositionAt(o, 0)); r.remove(s) } } else { const t = r.createContainerElement("a", { href: n.attributeNewValue }); r.insert(r.createPositionAt(o, 0), t); r.move(r.createRangeOn(c), r.createPositionAt(t, 0)) } }), { priority: "high" }) } } function OP(t) { return e => { e.on(`attribute:${t.id}:imageBlock`, ((e, n, i) => { const o = i.mapper.toViewElement(n.item); const r = Array.from(o.getChildren()).find((t => t.is("element", "a"))); if (!r) { return } for (const [e, n] of fl(t.attributes)) { i.writer.setAttribute(e, n, r) } if (t.classes) { i.writer.addClass(t.classes, r) } for (const e in t.styles) { i.writer.setStyle(e, t.styles[e], r) } })) } } function RP(t, e) { const n = t.plugins.has("ImageInlineEditing"); const i = t.plugins.get("ImageUtils"); return t => { t.on("element:a", ((t, o, r) => { const s = o.viewItem; const a = i.findViewImgElement(s); if (!a) { return } const c = a.findAncestor((t => i.isBlockImageView(t))); if (n && !c) { return } const l = new yu(e._createPattern()); const d = l.match(s); if (!d) { return } if (!r.consumable.consume(s, d.match)) { return } const u = o.modelCursor.nodeBefore || o.modelCursor.parent; r.writer.setAttribute(e.id, true, u) }), { priority: "high" }) } } class jP extends Kd { static get requires() { return [rP, vP, "ImageBlockEditing"] } static get pluginName() { return "LinkImageUI" } init() { const t = this.editor; const e = t.editing.view.document; this.listenTo(e, "click", ((e, n) => { if (this._isSelectedLinkedImage(t.model.document.selection)) { n.preventDefault(); e.stop() } }), { priority: "high" }); this._createToolbarLinkImageButton() } _createToolbarLinkImageButton() { const t = this.editor; const e = t.t; t.ui.componentFactory.add("linkImage", (n => { const i = new kd(n); const o = t.plugins.get("LinkUI"); const r = t.commands.get("link"); i.set({ isEnabled: true, label: e("Link image"), icon: AP, keystroke: Pz, tooltip: true, isToggleable: true }); i.bind("isEnabled").to(r, "isEnabled"); i.bind("isOn").to(r, "value", (t => !!t)); this.listenTo(i, "execute", (() => { if (this._isSelectedLinkedImage(t.model.document.selection)) { o._addActionsView() } else { o._showUI(true) } })); return i })) } _isSelectedLinkedImage(t) { const e = t.getSelectedElement(); const n = this.editor.plugins.get("ImageUtils"); return n.isImage(e) && e.hasAttribute("linkHref") } } var VP = n(3858); var FP = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; FP.insert = "head"; FP.singleton = true; var HP = Dl()(VP.Z, FP); const UP = VP.Z.locals || {}; class WP extends Kd { static get requires() { return [zP, jP] } static get pluginName() { return "LinkImage" } } class GP extends Jd { constructor(t, e) { super(t); this.type = e } refresh() { this.value = this._getValue(); this.isEnabled = this._checkEnabled() } execute(t = {}) { const e = this.editor.model; const n = e.document; const i = Array.from(n.selection.getSelectedBlocks()).filter((t => YP(t, e.schema))); const o = t.forceValue !== undefined ? !t.forceValue : this.value; e.change((t => { if (o) { let e = i[i.length - 1].nextSibling; let n = Number.POSITIVE_INFINITY; let o = []; while (e && e.name == "listItem" && e.getAttribute("listIndent") !== 0) { const t = e.getAttribute("listIndent"); if (t < n) { n = t } const i = t - n; o.push({ element: e, listIndent: i }); e = e.nextSibling } o = o.reverse(); for (const e of o) { t.setAttribute("listIndent", e.listIndent, e.element) } } if (!o) { let t = Number.POSITIVE_INFINITY; for (const e of i) { if (e.is("element", "listItem") && e.getAttribute("listIndent") < t) { t = e.getAttribute("listIndent") } } t = t === 0 ? 1 : t; qP(i, true, t); qP(i, false, t) } for (const e of i.reverse()) { if (o && e.name == "listItem") { t.rename(e, "paragraph") } else if (!o && e.name != "listItem") { t.setAttributes({ listType: this.type, listIndent: 0 }, e); t.rename(e, "listItem") } else if (!o && e.name == "listItem" && e.getAttribute("listType") != this.type) { t.setAttribute("listType", this.type, e) } } this.fire("_executeCleanup", i) })) } _getValue() { const t = ll(this.editor.model.document.selection.getSelectedBlocks()); return !!t && t.is("element", "listItem") && t.getAttribute("listType") == this.type } _checkEnabled() { if (this.value) { return true } const t = this.editor.model.document.selection; const e = this.editor.model.schema; const n = ll(t.getSelectedBlocks()); if (!n) { return false } return YP(n, e) } } function qP(t, e, n) { const i = e ? t[0] : t[t.length - 1]; if (i.is("element", "listItem")) { let o = i[e ? "previousSibling" : "nextSibling"]; let r = i.getAttribute("listIndent"); while (o && o.is("element", "listItem") && o.getAttribute("listIndent") >= n) { if (r > o.getAttribute("listIndent")) { r = o.getAttribute("listIndent") } if (o.getAttribute("listIndent") == r) { t[e ? "unshift" : "push"](o) } o = o[e ? "previousSibling" : "nextSibling"] } } } function YP(t, e) { return e.checkChild(t.parent, "listItem") && !e.isObject(t) } class $P extends Jd { constructor(t, e) { super(t); this._indentBy = e == "forward" ? 1 : -1 } refresh() { this.isEnabled = this._checkEnabled() } execute() { const t = this.editor.model; const e = t.document; let n = Array.from(e.selection.getSelectedBlocks()); t.change((t => { const e = n[n.length - 1]; let i = e.nextSibling; while (i && i.name == "listItem" && i.getAttribute("listIndent") > e.getAttribute("listIndent")) { n.push(i); i = i.nextSibling } if (this._indentBy < 0) { n = n.reverse() } for (const e of n) { const n = e.getAttribute("listIndent") + this._indentBy; if (n < 0) { t.rename(e, "paragraph") } else { t.setAttribute("listIndent", n, e) } } this.fire("_executeCleanup", n) })) } _checkEnabled() { const t = ll(this.editor.model.document.selection.getSelectedBlocks()); if (!t || !t.is("element", "listItem")) { return false } if (this._indentBy > 0) { const e = t.getAttribute("listIndent"); const n = t.getAttribute("listType"); let i = t.previousSibling; while (i && i.is("element", "listItem") && i.getAttribute("listIndent") >= e) { if (i.getAttribute("listIndent") == e) { return i.getAttribute("listType") == n } i = i.previousSibling } return false } return true } } function QP(t) { const e = t.createContainerElement("li"); e.getFillerOffset = cL; return e } function KP(t, e) { const n = e.mapper; const i = e.writer; const o = t.getAttribute("listType") == "numbered" ? "ol" : "ul"; const r = QP(i); const s = i.createContainerElement(o, null); i.insert(i.createPositionAt(s, 0), r); n.bindElements(t, r); return r } function ZP(t, e, n, i) { const o = e.parent; const r = n.mapper; const s = n.writer; let a = r.toViewPosition(i.createPositionBefore(t)); const c = tL(t.previousSibling, { sameIndent: true, smallerIndent: true, listIndent: t.getAttribute("listIndent") }); const l = t.previousSibling; if (c && c.getAttribute("listIndent") == t.getAttribute("listIndent")) { const t = r.toViewElement(c); a = s.breakContainer(s.createPositionAfter(t)) } else { if (l && l.name == "listItem") { a = r.toViewPosition(i.createPositionAt(l, "end")); const t = r.findMappedViewAncestor(a); const e = nL(t); if (e) { a = s.createPositionBefore(e) } else { a = s.createPositionAt(t, "end") } } else { a = r.toViewPosition(i.createPositionBefore(t)) } } a = XP(a); s.insert(a, o); if (l && l.name == "listItem") { const t = r.toViewElement(l); const n = s.createRange(s.createPositionAt(t, 0), a); const i = n.getWalker({ ignoreElementEnd: true }); for (const t of i) { if (t.item.is("element", "li")) { const n = s.breakContainer(s.createPositionBefore(t.item)); const o = t.item.parent; const r = s.createPositionAt(e, "end"); JP(s, r.nodeBefore, r.nodeAfter); s.move(s.createRangeOn(o), r); i._position = n } } } else { const n = o.nextSibling; if (n && (n.is("element", "ul") || n.is("element", "ol"))) { let i = null; for (const e of n.getChildren()) { const n = r.toModelElement(e); if (n && n.getAttribute("listIndent") > t.getAttribute("listIndent")) { i = e } else { break } } if (i) { s.breakContainer(s.createPositionAfter(i)); s.move(s.createRangeOn(i.parent), s.createPositionAt(e, "end")) } } } JP(s, o, o.nextSibling); JP(s, o.previousSibling, o) } function JP(t, e, n) { if (!e || !n || e.name != "ul" && e.name != "ol") { return null } if (e.name != n.name || e.getAttribute("class") !== n.getAttribute("class")) { return null } return t.mergeContainers(t.createPositionAfter(e)) } function XP(t) { return t.getLastMatchingPosition((t => t.item.is("uiElement"))) } function tL(t, e) { const n = !!e.sameIndent; const i = !!e.smallerIndent; const o = e.listIndent; let r = t; while (r && r.name == "listItem") { const t = r.getAttribute("listIndent"); if (n && o == t || i && o > t) { return r } if (e.direction === "forward") { r = r.nextSibling } else { r = r.previousSibling } } return null } function eL(t, e, n, i) { t.ui.componentFactory.add(e, (o => { const r = t.commands.get(e); const s = new kd(o); s.set({ label: n, icon: i, tooltip: true, isToggleable: true }); s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"); s.on("execute", (() => { t.execute(e); t.editing.view.focus() })); return s })) } function nL(t) { for (const e of t.getChildren()) { if (e.name == "ul" || e.name == "ol") { return e } } return null } function iL(t, e) { const n = []; const i = t.parent; const o = { ignoreElementEnd: false, startPosition: t, shallow: true, direction: e }; const r = i.getAttribute("listIndent"); const s = [...new Wp(o)].filter((t => t.item.is("element"))).map((t => t.item)); for (const t of s) { if (!t.is("element", "listItem")) { break } if (t.getAttribute("listIndent") < r) { break } if (t.getAttribute("listIndent") > r) { continue } if (t.getAttribute("listType") !== i.getAttribute("listType")) { break } if (t.getAttribute("listStyle") !== i.getAttribute("listStyle")) { break } if (t.getAttribute("listReversed") !== i.getAttribute("listReversed")) { break } if (t.getAttribute("listStart") !== i.getAttribute("listStart")) { break } if (e === "backward") { n.unshift(t) } else { n.push(t) } } return n } function oL(t) { const e = t.document; let n = [...e.selection.getSelectedBlocks()].filter((t => t.is("element", "listItem"))).map((e => { const n = t.change((t => t.createPositionAt(e, 0))); return [...iL(n, "backward"), ...iL(n, "forward")] })).flat(); n = [...new Set(n)]; return n } const rL = ["disc", "circle", "square"]; const sL = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"]; function aL(t) { if (rL.includes(t)) { return "bulleted" } if (sL.includes(t)) { return "numbered" } return null } function cL() { const t = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol"); if (this.isEmpty || t) { return 0 } return If.call(this) } class lL extends Kd { static get pluginName() { return "ListUtils" } getListTypeFromListStyleType(t) { return aL(t) } getSelectedListItems(t) { return oL(t) } getSiblingNodes(t, e) { return iL(t, e) } } function dL(t) { return (e, n, i) => { const o = i.consumable; if (!o.test(n.item, "insert") || !o.test(n.item, "attribute:listType") || !o.test(n.item, "attribute:listIndent")) { return } o.consume(n.item, "insert"); o.consume(n.item, "attribute:listType"); o.consume(n.item, "attribute:listIndent"); const r = n.item; const s = KP(r, i); ZP(r, s, i, t) } } function uL(t) { return (e, n, i) => { const o = i.mapper.toViewPosition(n.position); const r = o.getLastMatchingPosition((t => !t.item.is("element", "li"))); const s = r.nodeAfter; const a = i.writer; a.breakContainer(a.createPositionBefore(s)); a.breakContainer(a.createPositionAfter(s)); const c = s.parent; const l = c.previousSibling; const d = a.createRangeOn(c); const u = a.remove(d); if (l && l.nextSibling) { JP(a, l, l.nextSibling) } const h = i.mapper.toModelElement(s); EL(h.getAttribute("listIndent") + 1, n.position, d.start, s, i, t); for (const t of a.createRangeIn(u).getItems()) { i.mapper.unbindViewElement(t) } e.stop() } } const hL = (t, e, n) => { if (!n.consumable.test(e.item, t.name)) { return } const i = n.mapper.toViewElement(e.item); const o = n.writer; o.breakContainer(o.createPositionBefore(i)); o.breakContainer(o.createPositionAfter(i)); const r = i.parent; const s = e.attributeNewValue == "numbered" ? "ol" : "ul"; o.rename(s, r) }; const fL = (t, e, n) => { n.consumable.consume(e.item, t.name); const i = n.mapper.toViewElement(e.item); const o = i.parent; const r = n.writer; JP(r, o, o.nextSibling); JP(r, o.previousSibling, o) }; function gL(t) { return (e, n, i) => { if (!i.consumable.consume(n.item, "attribute:listIndent")) { return } const o = i.mapper.toViewElement(n.item); const r = i.writer; r.breakContainer(r.createPositionBefore(o)); r.breakContainer(r.createPositionAfter(o)); const s = o.parent; const a = s.previousSibling; const c = r.createRangeOn(s); r.remove(c); if (a && a.nextSibling) { JP(r, a, a.nextSibling) } EL(n.attributeOldValue + 1, n.range.start, c.start, o, i, t); ZP(n.item, o, i, t); for (const t of n.item.getChildren()) { i.consumable.consume(t, "insert") } } } const mL = (t, e, n) => { if (!n.consumable.test(e.item, t.name)) { return } if (e.item.name != "listItem") { let t = n.mapper.toViewPosition(e.range.start); const i = n.writer; const o = []; while (t.parent.name == "ul" || t.parent.name == "ol") { t = i.breakContainer(t); if (t.parent.name != "li") { break } const e = t; const n = i.createPositionAt(t.parent, "end"); if (!e.isEqual(n)) { const t = i.remove(i.createRange(e, n)); o.push(t) } t = i.createPositionAfter(t.parent) } if (o.length > 0) { for (let e = 0; e < o.length; e++) { const n = t.nodeBefore; const r = i.insert(t, o[e]); t = r.end; if (e > 0) { const e = JP(i, n, n.nextSibling); if (e && e.parent == n) { t.offset-- } } } JP(i, t.nodeBefore, t.nodeAfter) } } }; const pL = (t, e, n) => { const i = n.mapper.toViewPosition(e.position); const o = i.nodeBefore; const r = i.nodeAfter; JP(n.writer, o, r) }; const kL = (t, e, n) => { if (n.consumable.consume(e.viewItem, { name: true })) { const t = n.writer; const i = t.createElement("listItem"); const o = IL(e.viewItem); t.setAttribute("listIndent", o, i); const r = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted"; t.setAttribute("listType", r, i); if (!n.safeInsert(i, e.modelCursor)) { return } const s = yL(i, e.viewItem.getChildren(), n); e.modelRange = t.createRange(e.modelCursor, s); n.updateConversionResult(i, e) } }; const bL = (t, e, n) => { if (n.consumable.test(e.viewItem, { name: true })) { const t = Array.from(e.viewItem.getChildren()); for (const e of t) { const t = !(e.is("element", "li") || DL(e)); if (t) { e._remove() } } } }; const wL = (t, e, n) => { if (n.consumable.test(e.viewItem, { name: true })) { if (e.viewItem.childCount === 0) { return } const t = [...e.viewItem.getChildren()]; let n = false; for (const e of t) { if (n && !DL(e)) { e._remove() } if (DL(e)) { n = true } } } }; function _L(t) { return (e, n) => { if (n.isPhantom) { return } const i = n.modelPosition.nodeBefore; if (i && i.is("element", "listItem")) { const e = n.mapper.toViewElement(i); const o = e.getAncestors().find(DL); const r = t.createPositionAt(e, 0).getWalker(); for (const t of r) { if (t.type == "elementStart" && t.item.is("element", "li")) { n.viewPosition = t.previousPosition; break } else if (t.type == "elementEnd" && t.item == o) { n.viewPosition = t.nextPosition; break } } } } } function AL(t) { return (e, n) => { const i = n.viewPosition; const o = i.parent; const r = n.mapper; if (o.name == "ul" || o.name == "ol") { if (!i.isAtEnd) { const e = r.toModelElement(i.nodeAfter); n.modelPosition = t.createPositionBefore(e) } else { const e = r.toModelElement(i.nodeBefore); const o = r.getModelLength(i.nodeBefore); n.modelPosition = t.createPositionBefore(e).getShiftedBy(o) } e.stop() } else if (o.name == "li" && i.nodeBefore && (i.nodeBefore.name == "ul" || i.nodeBefore.name == "ol")) { const s = r.toModelElement(o); let a = 1; let c = i.nodeBefore; while (c && DL(c)) { a += r.getModelLength(c); c = c.previousSibling } n.modelPosition = t.createPositionBefore(s).getShiftedBy(a); e.stop() } } } function CL(t, e) { const n = t.document.differ.getChanges(); const i = new Map; let o = false; for (const i of n) { if (i.type == "insert" && i.name == "listItem") { r(i.position) } else if (i.type == "insert" && i.name != "listItem") { if (i.name != "$text") { const n = i.position.nodeAfter; if (n.hasAttribute("listIndent")) { e.removeAttribute("listIndent", n); o = true } if (n.hasAttribute("listType")) { e.removeAttribute("listType", n); o = true } if (n.hasAttribute("listStyle")) { e.removeAttribute("listStyle", n); o = true } if (n.hasAttribute("listReversed")) { e.removeAttribute("listReversed", n); o = true } if (n.hasAttribute("listStart")) { e.removeAttribute("listStart", n); o = true } for (const e of Array.from(t.createRangeIn(n)).filter((t => t.item.is("element", "listItem")))) { r(e.previousPosition) } } const n = i.position.getShiftedBy(i.length); r(n) } else if (i.type == "remove" && i.name == "listItem") { r(i.position) } else if (i.type == "attribute" && i.attributeKey == "listIndent") { r(i.range.start) } else if (i.type == "attribute" && i.attributeKey == "listType") { r(i.range.start) } } for (const t of i.values()) { s(t); a(t) } return o; function r(t) { const e = t.nodeBefore; if (!e || !e.is("element", "listItem")) { const e = t.nodeAfter; if (e && e.is("element", "listItem")) { i.set(e, e) } } else { let t = e; if (i.has(t)) { return } for (let e = t.previousSibling; e && e.is("element", "listItem"); e = t.previousSibling) { t = e; if (i.has(t)) { return } } i.set(e, t) } } function s(t) { let n = 0; let i = null; while (t && t.is("element", "listItem")) { const r = t.getAttribute("listIndent"); if (r > n) { let s; if (i === null) { i = r - n; s = n } else { if (i > r) { i = r } s = r - i } e.setAttribute("listIndent", s, t); o = true } else { i = null; n = t.getAttribute("listIndent") + 1 } t = t.nextSibling } } function a(t) { let n = []; let i = null; while (t && t.is("element", "listItem")) { const r = t.getAttribute("listIndent"); if (i && i.getAttribute("listIndent") > r) { n = n.slice(0, r + 1) } if (r != 0) { if (n[r]) { const i = n[r]; if (t.getAttribute("listType") != i) { e.setAttribute("listType", i, t); o = true } } else { n[r] = t.getAttribute("listType") } } i = t; t = t.nextSibling } } } const vL = function (t, [e, n]) { const i = this; let o = e.is("documentFragment") ? e.getChild(0) : e; let r; if (!n) { r = i.document.selection } else { r = i.createSelection(n) } if (o && o.is("element", "listItem")) { const t = r.getFirstPosition(); let e = null; if (t.parent.is("element", "listItem")) { e = t.parent } else if (t.nodeBefore && t.nodeBefore.is("element", "listItem")) { e = t.nodeBefore } if (e) { const t = e.getAttribute("listIndent"); if (t > 0) { while (o && o.is("element", "listItem")) { o._setAttribute("listIndent", o.getAttribute("listIndent") + t); o = o.nextSibling } } } } }; function yL(t, e, n) { const { writer: i, schema: o } = n; let r = i.createPositionAfter(t); for (const s of e) { if (s.name == "ul" || s.name == "ol") { r = n.convertItem(s, r).modelCursor } else { const e = n.convertItem(s, i.createPositionAt(t, "end")); const a = e.modelRange.start.nodeAfter; const c = a && a.is("element") && !o.checkChild(t, a.name); if (c) { if (e.modelCursor.parent.is("element", "listItem")) { t = e.modelCursor.parent } else { t = xL(e.modelCursor) } r = i.createPositionAfter(t) } } } return r } function xL(t) { const e = new Wp({ startPosition: t }); let n; do { n = e.next() } while (!n.value.item.is("element", "listItem")); return n.value.item } function EL(t, e, n, i, o, r) { const s = tL(e.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: t }); const a = o.mapper; const c = o.writer; const l = s ? s.getAttribute("listIndent") : null; let d; if (!s) { d = n } else if (l == t) { const t = a.toViewElement(s).parent; d = c.createPositionAfter(t) } else { const t = r.createPositionAt(s, "end"); d = a.toViewPosition(t) } d = XP(d); for (const t of [...i.getChildren()]) { if (DL(t)) { d = c.move(c.createRangeOn(t), d).end; JP(c, t, t.nextSibling); JP(c, t.previousSibling, t) } } } function DL(t) { return t.is("element", "ol") || t.is("element", "ul") } function IL(t) { let e = 0; let n = t.parent; while (n) { if (n.is("element", "li")) { e++ } else { const t = n.previousSibling; if (t && t.is("element", "li")) { e++ } } n = n.parent } return e } var TL = n(9989); var ML = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; ML.insert = "head"; ML.singleton = true; var SL = Dl()(TL.Z, ML); const NL = TL.Z.locals || {}; class BL extends Kd { static get pluginName() { return "ListEditing" } static get requires() { return [aE, SE, lL] } init() { const t = this.editor; t.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] }); const e = t.data; const n = t.editing; t.model.document.registerPostFixer((e => CL(t.model, e))); n.mapper.registerViewToModelLength("li", zL); e.mapper.registerViewToModelLength("li", zL); n.mapper.on("modelToViewPosition", _L(n.view)); n.mapper.on("viewToModelPosition", AL(t.model)); e.mapper.on("modelToViewPosition", _L(n.view)); t.conversion.for("editingDowncast").add((e => { e.on("insert", mL, { priority: "high" }); e.on("insert:listItem", dL(t.model)); e.on("attribute:listType:listItem", hL, { priority: "high" }); e.on("attribute:listType:listItem", fL, { priority: "low" }); e.on("attribute:listIndent:listItem", gL(t.model)); e.on("remove:listItem", uL(t.model)); e.on("remove", pL, { priority: "low" }) })); t.conversion.for("dataDowncast").add((e => { e.on("insert", mL, { priority: "high" }); e.on("insert:listItem", dL(t.model)) })); t.conversion.for("upcast").add((t => { t.on("element:ul", bL, { priority: "high" }); t.on("element:ol", bL, { priority: "high" }); t.on("element:li", wL, { priority: "high" }); t.on("element:li", kL) })); t.model.on("insertContent", vL, { priority: "high" }); t.commands.add("numberedList", new GP(t, "numbered")); t.commands.add("bulletedList", new GP(t, "bulleted")); t.commands.add("indentList", new $P(t, "forward")); t.commands.add("outdentList", new $P(t, "backward")); const i = n.view.document; this.listenTo(i, "enter", ((t, e) => { const n = this.editor.model.document; const i = n.selection.getLastPosition().parent; if (n.selection.isCollapsed && i.name == "listItem" && i.isEmpty) { this.editor.execute("outdentList"); e.preventDefault(); t.stop() } }), { context: "li" }); this.listenTo(i, "delete", ((t, e) => { if (e.direction !== "backward") { return } const n = this.editor.model.document.selection; if (!n.isCollapsed) { return } const i = n.getFirstPosition(); if (!i.isAtStart) { return } const o = i.parent; if (o.name !== "listItem") { return } const r = o.previousSibling && o.previousSibling.name === "listItem"; if (r) { return } this.editor.execute("outdentList"); e.preventDefault(); t.stop() }), { context: "li" }); this.listenTo(t.editing.view.document, "tab", ((e, n) => { const i = n.shiftKey ? "outdentList" : "indentList"; const o = this.editor.commands.get(i); if (o.isEnabled) { t.execute(i); n.stopPropagation(); n.preventDefault(); e.stop() } }), { context: "li" }) } afterInit() { const t = this.editor.commands; const e = t.get("indent"); const n = t.get("outdent"); if (e) { e.registerChildCommand(t.get("indentList")) } if (n) { n.registerChildCommand(t.get("outdentList")) } } } function zL(t) { let e = 1; for (const n of t.getChildren()) { if (n.name == "ul" || n.name == "ol") { for (const t of n.getChildren()) { e += zL(t) } } } return e } const PL = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'; const LL = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>'; class OL extends Kd { static get pluginName() { return "ListUI" } init() { const t = this.editor.t; eL(this.editor, "numberedList", t("Numbered List"), PL); eL(this.editor, "bulletedList", t("Bulleted List"), LL) } } class RL extends Kd { static get requires() { return [BL, OL] } static get pluginName() { return "List" } } class jL extends Jd { constructor(t, e) { super(t); this.defaultType = e } refresh() { this.value = this._getValue(); this.isEnabled = this._checkEnabled() } execute(t = {}) { this._tryToConvertItemsToList(t); const e = this.editor.model; const n = oL(e); if (!n.length) { return } e.change((e => { for (const i of n) { e.setAttribute("listStyle", t.type || this.defaultType, i) } })) } _getValue() { const t = this.editor.model.document.selection.getFirstPosition().parent; if (t && t.is("element", "listItem")) { return t.getAttribute("listStyle") } return null } _checkEnabled() { const t = this.editor; const e = t.commands.get("numberedList"); const n = t.commands.get("bulletedList"); return e.isEnabled || n.isEnabled } _tryToConvertItemsToList(t) { if (!t.type) { return } const e = aL(t.type); if (!e) { return } const n = this.editor; const i = `${e}List`; const o = n.commands.get(i); if (!o.value) { n.execute(i) } } } class VL extends Jd { refresh() { const t = this._getValue(); this.value = t; this.isEnabled = t != null } execute(t = {}) { const e = this.editor.model; const n = oL(e).filter((t => t.getAttribute("listType") == "numbered")); e.change((e => { for (const i of n) { e.setAttribute("listReversed", !!t.reversed, i) } })) } _getValue() { const t = this.editor.model.document.selection.getFirstPosition().parent; if (t && t.is("element", "listItem") && t.getAttribute("listType") == "numbered") { return t.getAttribute("listReversed") } return null } } class FL extends Jd { refresh() { const t = this._getValue(); this.value = t; this.isEnabled = t != null } execute({ startIndex: t = 1 } = {}) { const e = this.editor.model; const n = oL(e).filter((t => t.getAttribute("listType") == "numbered")); e.change((e => { for (const i of n) { e.setAttribute("listStart", t >= 0 ? t : 1, i) } })) } _getValue() { const t = this.editor.model.document.selection.getFirstPosition().parent; if (t && t.is("element", "listItem") && t.getAttribute("listType") == "numbered") { return t.getAttribute("listStart") } return null } } const HL = "default"; class UL extends Kd { static get requires() { return [BL] } static get pluginName() { return "ListPropertiesEditing" } constructor(t) { super(t); t.config.define("list", { properties: { styles: true, startIndex: false, reversed: false } }) } init() { const t = this.editor; const e = t.model; const n = t.config.get("list.properties"); const i = WL(n); e.schema.extend("listItem", { allowAttributes: i.map((t => t.attributeName)) }); for (const e of i) { e.addCommand(t) } this.listenTo(t.commands.get("indentList"), "_executeCleanup", YL(t, i)); this.listenTo(t.commands.get("outdentList"), "_executeCleanup", $L(t, i)); this.listenTo(t.commands.get("bulletedList"), "_executeCleanup", XL(t)); this.listenTo(t.commands.get("numberedList"), "_executeCleanup", XL(t)); e.document.registerPostFixer(QL(t, i)); t.conversion.for("upcast").add(GL(i)); t.conversion.for("downcast").add(qL(i)); this._mergeListAttributesWhileMergingLists(i) } afterInit() { const t = this.editor; if (t.commands.get("todoList")) { t.model.document.registerPostFixer(JL(t)) } } _mergeListAttributesWhileMergingLists(t) { const e = this.editor; const n = e.model; let i; this.listenTo(n, "deleteContent", ((t, [e]) => { const n = e.getFirstPosition(); const o = e.getLastPosition(); if (n.parent === o.parent) { return } if (!n.parent.is("element", "listItem")) { return } const r = o.parent.nextSibling; if (!r || !r.is("element", "listItem")) { return } const s = tL(n.parent, { sameIndent: true, listIndent: r.getAttribute("listIndent") }); if (!s) { return } if (s.getAttribute("listType") === r.getAttribute("listType")) { i = s } }), { priority: "high" }); this.listenTo(n, "deleteContent", (() => { if (!i) { return } n.change((e => { const n = tL(i.nextSibling, { sameIndent: true, listIndent: i.getAttribute("listIndent"), direction: "forward" }); if (!n) { i = null; return } const o = [n, ...iL(e.createPositionAt(n, 0), "forward")]; for (const n of o) { for (const o of t) { if (o.appliesToListItem(n)) { const t = o.attributeName; const r = i.getAttribute(t); e.setAttribute(t, r, n) } } } })); i = null }), { priority: "low" }) } } function WL(t) { const e = []; if (t.styles) { e.push({ attributeName: "listStyle", defaultValue: HL, addCommand(t) { t.commands.add("listStyle", new jL(t, HL)) }, appliesToListItem() { return true }, setAttributeOnDowncast(t, e, n) { if (e && e !== HL) { t.setStyle("list-style-type", e, n) } else { t.removeStyle("list-style-type", n) } }, getAttributeOnUpcast(t) { return t.getStyle("list-style-type") || HL } }) } if (t.reversed) { e.push({ attributeName: "listReversed", defaultValue: false, addCommand(t) { t.commands.add("listReversed", new VL(t)) }, appliesToListItem(t) { return t.getAttribute("listType") == "numbered" }, setAttributeOnDowncast(t, e, n) { if (e) { t.setAttribute("reversed", "reversed", n) } else { t.removeAttribute("reversed", n) } }, getAttributeOnUpcast(t) { return t.hasAttribute("reversed") } }) } if (t.startIndex) { e.push({ attributeName: "listStart", defaultValue: 1, addCommand(t) { t.commands.add("listStart", new FL(t)) }, appliesToListItem(t) { return t.getAttribute("listType") == "numbered" }, setAttributeOnDowncast(t, e, n) { if (e == 0 || e > 1) { t.setAttribute("start", e, n) } else { t.removeAttribute("start", n) } }, getAttributeOnUpcast(t) { const e = t.getAttribute("start"); return e >= 0 ? e : 1 } }) } return e } function GL(t) { return e => { e.on("element:li", ((e, n, i) => { if (!n.modelRange) { return } const o = n.viewItem.parent; const r = n.modelRange.start.nodeAfter || n.modelRange.end.nodeBefore; for (const e of t) { if (e.appliesToListItem(r)) { const t = e.getAttributeOnUpcast(o); i.writer.setAttribute(e.attributeName, t, r) } } }), { priority: "low" }) } } function qL(t) { return n => { for (const i of t) { n.on(`attribute:${i.attributeName}:listItem`, ((t, n, o) => { const r = o.writer; const s = n.item; const a = tL(s.previousSibling, { sameIndent: true, listIndent: s.getAttribute("listIndent"), direction: "backward" }); const c = o.mapper.toViewElement(s); if (!e(s, a)) { r.breakContainer(r.createPositionBefore(c)) } i.setAttributeOnDowncast(r, n.attributeNewValue, c.parent) }), { priority: "low" }) } }; function e(t, e) { return e && t.getAttribute("listType") === e.getAttribute("listType") && t.getAttribute("listIndent") === e.getAttribute("listIndent") && t.getAttribute("listStyle") === e.getAttribute("listStyle") && t.getAttribute("listReversed") === e.getAttribute("listReversed") && t.getAttribute("listStart") === e.getAttribute("listStart") } } function YL(t, e) { return (n, i) => { const o = i[0]; const r = o.getAttribute("listIndent"); const s = i.filter((t => t.getAttribute("listIndent") === r)); let a = null; if (o.previousSibling.getAttribute("listIndent") + 1 !== r) { a = tL(o.previousSibling, { sameIndent: true, direction: "backward", listIndent: r }) } t.model.change((t => { for (const n of s) { for (const i of e) { if (i.appliesToListItem(n)) { const e = a == null ? i.defaultValue : a.getAttribute(i.attributeName); t.setAttribute(i.attributeName, e, n) } } } })) } } function $L(t, e) { return (n, i) => { i = i.reverse().filter((t => t.is("element", "listItem"))); if (!i.length) { return } const o = i[0].getAttribute("listIndent"); const r = i[0].getAttribute("listType"); let s = i[0].previousSibling; if (s.is("element", "listItem")) { while (s.getAttribute("listIndent") !== o) { s = s.previousSibling } } else { s = null } if (!s) { s = i[i.length - 1].nextSibling } if (!s || !s.is("element", "listItem")) { return } if (s.getAttribute("listType") !== r) { return } t.model.change((t => { const n = i.filter((t => t.getAttribute("listIndent") === o)); for (const i of n) { for (const n of e) { if (n.appliesToListItem(i)) { const e = n.attributeName; const o = s.getAttribute(e); t.setAttribute(e, o, i) } } } })) } } function QL(t, e) { return n => { let i = false; const o = tO(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") !== "todo")); if (!o.length) { return i } let r = o[o.length - 1].nextSibling; if (!r || !r.is("element", "listItem")) { r = o[0].previousSibling; if (r) { const t = o[0].getAttribute("listIndent"); while (r.is("element", "listItem") && r.getAttribute("listIndent") !== t) { r = r.previousSibling; if (!r) { break } } } } for (const t of e) { const e = t.attributeName; for (const s of o) { if (!t.appliesToListItem(s)) { n.removeAttribute(e, s); continue } if (!s.hasAttribute(e)) { if (KL(r, s, t)) { n.setAttribute(e, r.getAttribute(e), s) } else { n.setAttribute(e, t.defaultValue, s) } i = true } else { const o = s.previousSibling; if (ZL(o, s, t.attributeName)) { n.setAttribute(e, o.getAttribute(e), s); i = true } } } } return i } } function KL(t, e, n) { if (!t) { return false } const i = t.getAttribute(n.attributeName); if (!i) { return false } if (i == n.defaultValue) { return false } if (t.getAttribute("listType") !== e.getAttribute("listType")) { return false } return true } function ZL(t, e, n) { if (!t || !t.is("element", "listItem")) { return false } if (e.getAttribute("listType") !== t.getAttribute("listType")) { return false } const i = t.getAttribute("listIndent"); if (i < 1 || i !== e.getAttribute("listIndent")) { return false } const o = t.getAttribute(n); if (!o || o === e.getAttribute(n)) { return false } return true } function JL(t) { return e => { const n = tO(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") === "todo" && (t.hasAttribute("listStyle") || t.hasAttribute("listReversed") || t.hasAttribute("listStart")))); if (!n.length) { return false } for (const t of n) { e.removeAttribute("listStyle", t); e.removeAttribute("listReversed", t); e.removeAttribute("listStart", t) } return true } } function XL(t) { return (e, n) => { n = n.filter((t => t.is("element", "listItem"))); t.model.change((t => { for (const e of n) { t.removeAttribute("listStyle", e) } })) } } function tO(t) { const e = []; for (const n of t) { const t = eO(n); if (t && t.is("element", "listItem")) { e.push(t) } } return e } function eO(t) { if (t.type === "attribute") { return t.range.start.nodeAfter } if (t.type === "insert") { return t.position.nodeAfter } return null } var nO = n(3195); var iO = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; iO.insert = "head"; iO.singleton = true; var oO = Dl()(nO.Z, iO); const rO = nO.Z.locals || {}; class sO extends Nl { constructor(t, e) { super(t); const n = this.bindTemplate; this.set("isCollapsed", false); this.set("label", ""); this.buttonView = this._createButtonView(); this.children = this.createCollection(); this.set("_collapsibleAriaLabelUid", undefined); if (e) { this.children.addMany(e) } this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-collapsible", n.if("isCollapsed", "ck-collapsible_collapsed")] }, children: [this.buttonView, { tag: "div", attributes: { class: ["ck", "ck-collapsible__children"], role: "region", hidden: n.if("isCollapsed", "hidden"), "aria-labelledby": n.to("_collapsibleAriaLabelUid") }, children: this.children }] }) } render() { super.render(); this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id } _createButtonView() { const t = new kd(this.locale); const e = t.bindTemplate; t.set({ withText: true, icon: Od }); t.extendTemplate({ attributes: { "aria-expanded": e.to("isOn", (t => String(t))) } }); t.bind("label").to(this); t.bind("isOn").to(this, "isCollapsed", (t => !t)); t.on("execute", (() => { this.isCollapsed = !this.isCollapsed })); return t } } var aO = n(7133); var cO = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; cO.insert = "head"; cO.singleton = true; var lO = Dl()(aO.Z, cO); const dO = aO.Z.locals || {}; class uO extends Nl { constructor(t, { enabledProperties: e, styleButtonViews: n, styleGridAriaLabel: i }) { super(t); this.stylesView = null; this.additionalPropertiesCollapsibleView = null; this.startIndexFieldView = null; this.reversedSwitchButtonView = null; this.focusTracker = new dl; this.keystrokes = new ul; this.focusables = new yl; const o = ["ck", "ck-list-properties"]; this.children = this.createCollection(); this.focusCycler = new Wd({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); if (e.styles) { this.stylesView = this._createStylesView(n, i); this.children.add(this.stylesView) } else { o.push("ck-list-properties_without-styles") } if (e.startIndex || e.reversed) { this._addNumberedListPropertyViews(e); o.push("ck-list-properties_with-numbered-properties") } this.setTemplate({ tag: "div", attributes: { class: o }, children: this.children }) } render() { super.render(); if (this.stylesView) { this.focusables.add(this.stylesView); this.focusTracker.add(this.stylesView.element); if (this.startIndexFieldView || this.reversedSwitchButtonView) { this.focusables.add(this.children.last.buttonView); this.focusTracker.add(this.children.last.buttonView.element) } for (const t of this.stylesView.children) { this.stylesView.focusTracker.add(t.element) } r({ keystrokeHandler: this.stylesView.keystrokes, focusTracker: this.stylesView.focusTracker, gridItems: this.stylesView.children, numberOfColumns: () => nc.window.getComputedStyle(this.stylesView.element).getPropertyValue("grid-template-columns").split(" ").length, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection }) } if (this.startIndexFieldView) { this.focusables.add(this.startIndexFieldView); this.focusTracker.add(this.startIndexFieldView.element); this.listenTo(this.startIndexFieldView.element, "selectstart", ((t, e) => { e.stopPropagation() }), { priority: "high" }); const t = t => t.stopPropagation(); this.keystrokes.set("arrowright", t); this.keystrokes.set("arrowleft", t); this.keystrokes.set("arrowup", t); this.keystrokes.set("arrowdown", t) } if (this.reversedSwitchButtonView) { this.focusables.add(this.reversedSwitchButtonView); this.focusTracker.add(this.reversedSwitchButtonView.element) } this.keystrokes.listenTo(this.element) } focus() { this.focusCycler.focusFirst() } focusLast() { this.focusCycler.focusLast() } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } _createStylesView(t, e) { const n = new Nl(this.locale); n.children = n.createCollection(); n.children.addMany(t); n.setTemplate({ tag: "div", attributes: { "aria-label": e, class: ["ck", "ck-list-styles-list"] }, children: n.children }); n.children.delegate("execute").to(this); n.focus = function () { this.children.first.focus() }; n.focusTracker = new dl; n.keystrokes = new ul; n.render(); n.keystrokes.listenTo(n.element); return n } _addNumberedListPropertyViews(t) { const e = this.locale.t; const n = []; if (t.startIndex) { this.startIndexFieldView = this._createStartIndexField(); n.push(this.startIndexFieldView) } if (t.reversed) { this.reversedSwitchButtonView = this._createReversedSwitchButton(); n.push(this.reversedSwitchButtonView) } if (t.styles) { this.additionalPropertiesCollapsibleView = new sO(this.locale, n); this.additionalPropertiesCollapsibleView.set({ label: e("List properties"), isCollapsed: true }); this.additionalPropertiesCollapsibleView.buttonView.bind("isEnabled").toMany(n, "isEnabled", ((...t) => t.some((t => t)))); this.additionalPropertiesCollapsibleView.buttonView.on("change:isEnabled", ((t, e, n) => { if (!n) { this.additionalPropertiesCollapsibleView.isCollapsed = true } })); this.children.add(this.additionalPropertiesCollapsibleView) } else { this.children.addMany(n) } } _createStartIndexField() { const t = this.locale.t; const e = new By(this.locale, Py); e.set({ label: t("Start at"), class: "ck-numbered-list-properties__start-index" }); e.fieldView.set({ min: 0, step: 1, value: 1, inputMode: "numeric" }); e.fieldView.on("input", (() => { const n = e.fieldView.element; const i = n.valueAsNumber; if (Number.isNaN(i)) { return } if (!n.checkValidity()) { e.errorText = t("Start index must be greater than 0.") } else { this.fire("listStart", { startIndex: i }) } })); return e } _createReversedSwitchButton() { const t = this.locale.t; const e = new Cd(this.locale); e.set({ withText: true, label: t("Reversed order"), class: "ck-numbered-list-properties__reversed-order" }); e.delegate("execute").to(this, "listReversed"); return e } } const hO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>'; const fO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>'; const gO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>'; const mO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>'; const pO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>'; const kO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>'; const bO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>'; const wO = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>'; const _O = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="m7.88 15 .532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>'; var AO = n(4553); var CO = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; CO.insert = "head"; CO.singleton = true; var vO = Dl()(AO.Z, CO); const yO = AO.Z.locals || {}; class xO extends Kd { static get pluginName() { return "ListPropertiesUI" } init() { const t = this.editor; const e = t.locale.t; const n = t.config.get("list.properties"); if (n.styles) { t.ui.componentFactory.add("bulletedList", EO({ editor: t, parentCommandName: "bulletedList", buttonLabel: e("Bulleted List"), buttonIcon: LL, styleGridAriaLabel: e("Bulleted list styles toolbar"), styleDefinitions: [{ label: e("Toggle the disc list style"), tooltip: e("Disc"), type: "disc", icon: hO }, { label: e("Toggle the circle list style"), tooltip: e("Circle"), type: "circle", icon: fO }, { label: e("Toggle the square list style"), tooltip: e("Square"), type: "square", icon: gO }] })) } if (n.styles || n.startIndex || n.reversed) { t.ui.componentFactory.add("numberedList", EO({ editor: t, parentCommandName: "numberedList", buttonLabel: e("Numbered List"), buttonIcon: PL, styleGridAriaLabel: e("Numbered list styles toolbar"), styleDefinitions: [{ label: e("Toggle the decimal list style"), tooltip: e("Decimal"), type: "decimal", icon: mO }, { label: e("Toggle the decimal with leading zero list style"), tooltip: e("Decimal with leading zero"), type: "decimal-leading-zero", icon: pO }, { label: e("Toggle the lower–roman list style"), tooltip: e("Lower–roman"), type: "lower-roman", icon: kO }, { label: e("Toggle the upper–roman list style"), tooltip: e("Upper-roman"), type: "upper-roman", icon: bO }, { label: e("Toggle the lower–latin list style"), tooltip: e("Lower-latin"), type: "lower-latin", icon: wO }, { label: e("Toggle the upper–latin list style"), tooltip: e("Upper-latin"), type: "upper-latin", icon: _O }] })) } } } function EO({ editor: t, parentCommandName: e, buttonLabel: n, buttonIcon: i, styleGridAriaLabel: o, styleDefinitions: r }) { const s = t.commands.get(e); return a => { const c = yv(a, Ud); const l = c.buttonView; c.bind("isEnabled").to(s); c.class = "ck-list-styles-dropdown"; l.on("execute", (() => { t.execute(e); t.editing.view.focus() })); l.set({ label: n, icon: i, tooltip: true, isToggleable: true }); l.bind("isOn").to(s, "value", (t => !!t)); c.once("change:isOpen", (() => { const n = IO({ editor: t, dropdownView: c, parentCommandName: e, styleGridAriaLabel: o, styleDefinitions: r }); c.panelView.children.add(n) })); c.on("execute", (() => { t.editing.view.focus() })); return c } } function DO({ editor: t, listStyleCommand: e, parentCommandName: n }) { const i = t.locale; const o = t.commands.get(n); return ({ label: n, type: r, icon: s, tooltip: a }) => { const c = new kd(i); c.set({ label: n, icon: s, tooltip: a }); e.on("change:value", (() => { c.isOn = e.value === r })); c.on("execute", (() => { if (o.value) { if (e.value !== r) { t.execute("listStyle", { type: r }) } else { t.execute("listStyle", { type: e.defaultType }) } } else { t.model.change((() => { t.execute("listStyle", { type: r }) })) } })); return c } } function IO({ editor: t, dropdownView: e, parentCommandName: n, styleDefinitions: i, styleGridAriaLabel: o }) { const r = t.locale; const s = t.config.get("list.properties"); let a = null; if (n != "numberedList") { s.startIndex = false; s.reversed = false } if (s.styles) { const e = t.commands.get("listStyle"); const o = DO({ editor: t, parentCommandName: n, listStyleCommand: e }); const r = typeof e.isStyleTypeSupported == "function" ? t => e.isStyleTypeSupported(t.type) : () => true; a = i.filter(r).map(o) } const c = new uO(r, { styleGridAriaLabel: o, enabledProperties: s, styleButtonViews: a }); if (s.styles) { Tv(e, (() => c.stylesView.children.find((t => t.isOn)))) } if (s.startIndex) { const e = t.commands.get("listStart"); c.startIndexFieldView.bind("isEnabled").to(e); c.startIndexFieldView.fieldView.bind("value").to(e); c.on("listStart", ((e, n) => t.execute("listStart", n))) } if (s.reversed) { const e = t.commands.get("listReversed"); c.reversedSwitchButtonView.bind("isEnabled").to(e); c.reversedSwitchButtonView.bind("isOn").to(e, "value", (t => !!t)); c.on("listReversed", (() => { const n = e.value; t.execute("listReversed", { reversed: !n }) })) } c.delegate("execute").to(e); return c } class TO extends Kd { static get requires() { return [UL, xO] } static get pluginName() { return "ListProperties" } } function MO(t, e) { const n = (n, i, o) => { if (!o.consumable.consume(i.item, n.name)) { return } const r = i.attributeNewValue; const s = o.writer; const a = o.mapper.toViewElement(i.item); const c = [...a.getChildren()].find((t => t.getCustomProperty("media-content"))); s.remove(c); const l = t.getMediaViewElement(s, r, e); s.insert(s.createPositionAt(a, 0), l) }; return t => { t.on("attribute:url:media", n) } } function SO(t, e, n) { e.setCustomProperty("media", true, t); return ND(t, e, { label: n }) } function NO(t) { const e = t.getSelectedElement(); if (e && BO(e)) { return e } return null } function BO(t) { return !!t.getCustomProperty("media") && SD(t) } function zO(t, e, n, i) { return t.createContainerElement("figure", { class: "media" }, [e.getMediaViewElement(t, n, i), t.createSlot()]) } function PO(t) { const e = t.getSelectedElement(); if (e && e.is("element", "media")) { return e } return null } function LO(t, e, n, i) { t.change((o => { const r = o.createElement("media", { url: e }); t.insertObject(r, n, null, { setSelection: "on", findOptimalPosition: i ? "auto" : undefined }) })) } class OO extends Jd { refresh() { const t = this.editor.model; const e = t.document.selection; const n = PO(e); this.value = n ? n.getAttribute("url") : undefined; this.isEnabled = jO(e) || RO(e, t) } execute(t) { const e = this.editor.model; const n = e.document.selection; const i = PO(n); if (i) { e.change((e => { e.setAttribute("url", t, i) })) } else { LO(e, t, n, true) } } } function RO(t, e) { const n = jD(t, e); let i = n.start.parent; if (i.isEmpty && !e.schema.isLimit(i)) { i = i.parent } return e.schema.checkChild(i, "media") } function jO(t) { const e = t.getSelectedElement(); return !!e && e.name === "media" } const VO = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>'; const FO = "0 0 64 42"; class HO { constructor(t, e) { const n = e.providers; const i = e.extraProviders || []; const o = new Set(e.removeProviders); const r = n.concat(i).filter((t => { const e = t.name; if (!e) { P("media-embed-no-provider-name", { provider: t }); return false } return !o.has(e) })); this.locale = t; this.providerDefinitions = r } hasMedia(t) { return !!this._getMedia(t) } getMediaViewElement(t, e, n) { return this._getMedia(e).getViewElement(t, n) } _getMedia(t) { if (!t) { return new UO(this.locale) } t = t.trim(); for (const e of this.providerDefinitions) { const n = e.html; const i = tl(e.url); for (const e of i) { const i = this._getUrlMatches(t, e); if (i) { return new UO(this.locale, t, i, n) } } } return null } _getUrlMatches(t, e) { let n = t.match(e); if (n) { return n } let i = t.replace(/^https?:\/\//, ""); n = i.match(e); if (n) { return n } i = i.replace(/^www\./, ""); n = i.match(e); if (n) { return n } return null } } class UO { constructor(t, e, n, i) { this.url = this._getValidUrl(e); this._locale = t; this._match = n; this._previewRenderer = i } getViewElement(t, e) { const n = {}; let i; if (e.renderForEditingView || e.renderMediaPreview && this.url && this._previewRenderer) { if (this.url) { n["data-oembed-url"] = this.url } if (e.renderForEditingView) { n.class = "ck-media__wrapper" } const o = this._getPreviewHtml(e); i = t.createRawElement("div", n, ((t, e) => { e.setContentOf(t, o) })) } else { if (this.url) { n.url = this.url } i = t.createEmptyElement(e.elementName, n) } t.setCustomProperty("media-content", true, i); return i } _getPreviewHtml(t) { if (this._previewRenderer) { return this._previewRenderer(this._match) } else { if (this.url && t.renderForEditingView) { return this._getPlaceholderHtml() } return "" } } _getPlaceholderHtml() { const t = new hd; const e = this._locale.t; t.content = VO; t.viewBox = FO; const n = new zl({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [t] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url, "data-cke-tooltip-text": e("Open media in new tab") }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }] }] }).render(); return n.outerHTML } _getValidUrl(t) { if (!t) { return null } if (t.match(/^https?/)) { return t } return "https://" + t } } var WO = n(952); var GO = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; GO.insert = "head"; GO.singleton = true; var qO = Dl()(WO.Z, GO); const YO = WO.Z.locals || {}; class $O extends Kd { static get pluginName() { return "MediaEmbedEditing" } constructor(t) { super(t); t.config.define("mediaEmbed", { elementName: "oembed", providers: [{ name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: t => { const e = t[1]; return '<div style="position: relative; padding-bottom: 100%; height: 0; ">' + `<iframe src="https://www.dailymotion.com/embed/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" width="480" height="270" allowfullscreen allow="autoplay">' + "</iframe>" + "</div>" } }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: t => { const e = t[1]; return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;">' + `<iframe src="https://open.spotify.com/embed/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allowtransparency="true" allow="encrypted-media">' + "</iframe>" + "</div>" } }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/], html: t => { const e = t[1]; const n = t[2]; return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://www.youtube.com/embed/${e}${n ? `?start=${n}` : ""}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>' + "</iframe>" + "</div>" } }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: t => { const e = t[1]; return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://player.vimeo.com/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>' + "</iframe>" + "</div>" } }, { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ }, { name: "twitter", url: /^twitter\.com/ }, { name: "googleMaps", url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/] }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }); this.registry = new HO(t.locale, t.config.get("mediaEmbed")) } init() { const t = this.editor; const e = t.model.schema; const n = t.t; const i = t.conversion; const o = t.config.get("mediaEmbed.previewsInData"); const r = t.config.get("mediaEmbed.elementName"); const s = this.registry; t.commands.add("mediaEmbed", new OO(t)); e.register("media", { inheritAllFrom: "$blockObject", allowAttributes: ["url"] }); i.for("dataDowncast").elementToStructure({ model: "media", view: (t, { writer: e }) => { const n = t.getAttribute("url"); return zO(e, s, n, { elementName: r, renderMediaPreview: !!n && o }) } }); i.for("dataDowncast").add(MO(s, { elementName: r, renderMediaPreview: o })); i.for("editingDowncast").elementToStructure({ model: "media", view: (t, { writer: e }) => { const i = t.getAttribute("url"); const o = zO(e, s, i, { elementName: r, renderForEditingView: true }); return SO(o, e, n("media widget")) } }); i.for("editingDowncast").add(MO(s, { elementName: r, renderForEditingView: true })); i.for("upcast").elementToElement({ view: t => ["oembed", r].includes(t.name) && t.getAttribute("url") ? { name: true } : null, model: (t, { writer: e }) => { const n = t.getAttribute("url"); if (s.hasMedia(n)) { return e.createElement("media", { url: n }) } return null } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": true } }, model: (t, { writer: e }) => { const n = t.getAttribute("data-oembed-url"); if (s.hasMedia(n)) { return e.createElement("media", { url: n }) } return null } }).add((t => { const e = (t, e, n) => { if (!n.consumable.consume(e.viewItem, { name: true, classes: "media" })) { return } const { modelRange: i, modelCursor: o } = n.convertChildren(e.viewItem, e.modelCursor); e.modelRange = i; e.modelCursor = o; const r = ll(i.getItems()); if (!r) { n.consumable.revert(e.viewItem, { name: true, classes: "media" }) } }; t.on("element:figure", e) })) } } const QO = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/; class KO extends Kd { static get requires() { return [iT, SE, _T] } static get pluginName() { return "AutoMediaEmbed" } constructor(t) { super(t); this._timeoutId = null; this._positionToInsert = null } init() { const t = this.editor; const e = t.model.document; const n = t.plugins.get("ClipboardPipeline"); this.listenTo(n, "inputTransformation", (() => { const t = e.selection.getFirstRange(); const n = g_.fromPosition(t.start); n.stickiness = "toPrevious"; const i = g_.fromPosition(t.end); i.stickiness = "toNext"; e.once("change:data", (() => { this._embedMediaBetweenPositions(n, i); n.detach(); i.detach() }), { priority: "high" }) })); const i = t.commands.get("undo"); i.on("execute", (() => { if (this._timeoutId) { nc.window.clearTimeout(this._timeoutId); this._positionToInsert.detach(); this._timeoutId = null; this._positionToInsert = null } }), { priority: "high" }) } _embedMediaBetweenPositions(t, e) { const n = this.editor; const i = n.plugins.get($O).registry; const o = new mk(t, e); const r = o.getWalker({ ignoreElementEnd: true }); let s = ""; for (const t of r) { if (t.item.is("$textProxy")) { s += t.item.data } } s = s.trim(); if (!s.match(QO)) { o.detach(); return } if (!i.hasMedia(s)) { o.detach(); return } const a = n.commands.get("mediaEmbed"); if (!a.isEnabled) { o.detach(); return } this._positionToInsert = g_.fromPosition(t); this._timeoutId = nc.window.setTimeout((() => { n.model.change((t => { this._timeoutId = null; t.remove(o); o.detach(); let e = null; if (this._positionToInsert.root.rootName !== "$graveyard") { e = this._positionToInsert } LO(n.model, s, e, false); this._positionToInsert.detach(); this._positionToInsert = null })); n.plugins.get(SE).requestUndoOnBackspace() }), 100) } } var ZO = n(3525); var JO = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; JO.insert = "head"; JO.singleton = true; var XO = Dl()(ZO.Z, JO); const tR = ZO.Z.locals || {}; class eR extends Nl { constructor(t, e) { super(e); const n = e.t; this.focusTracker = new dl; this.keystrokes = new ul; this.set("mediaURLInputValue", ""); this.urlInputView = this._createUrlInput(); this.saveButtonView = this._createButton(n("Save"), JC.check, "ck-button-save"); this.saveButtonView.type = "submit"; this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t => !!t)); this.cancelButtonView = this._createButton(n("Cancel"), JC.cancel, "ck-button-cancel", "cancel"); this._focusables = new yl; this._focusCycler = new Wd({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }); this._validators = t; this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.urlInputView, this.saveButtonView, this.cancelButtonView] }) } render() { super.render(); o({ view: this }); const t = [this.urlInputView, this.saveButtonView, this.cancelButtonView]; t.forEach((t => { this._focusables.add(t); this.focusTracker.add(t.element) })); this.keystrokes.listenTo(this.element); const e = t => t.stopPropagation(); this.keystrokes.set("arrowright", e); this.keystrokes.set("arrowleft", e); this.keystrokes.set("arrowup", e); this.keystrokes.set("arrowdown", e); this.listenTo(this.urlInputView.element, "selectstart", ((t, e) => { e.stopPropagation() }), { priority: "high" }) } destroy() { super.destroy(); this.focusTracker.destroy(); this.keystrokes.destroy() } focus() { this._focusCycler.focusFirst() } get url() { return this.urlInputView.fieldView.element.value.trim() } set url(t) { this.urlInputView.fieldView.element.value = t.trim() } isValid() { this.resetFormStatus(); for (const t of this._validators) { const e = t(this); if (e) { this.urlInputView.errorText = e; return false } } return true } resetFormStatus() { this.urlInputView.errorText = null; this.urlInputView.infoText = this._urlInputViewInfoDefault } _createUrlInput() { const t = this.locale.t; const e = new By(this.locale, zy); const n = e.fieldView; this._urlInputViewInfoDefault = t("Paste the media URL in the input."); this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster."); e.label = t("Media URL"); e.infoText = this._urlInputViewInfoDefault; n.on("input", (() => { e.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault; this.mediaURLInputValue = n.element.value.trim() })); return e } _createButton(t, e, n, i) { const o = new kd(this.locale); o.set({ label: t, icon: e, tooltip: true }); o.extendTemplate({ attributes: { class: n } }); if (i) { o.delegate("execute").to(this, i) } return o } } const nR = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>'; class iR extends Kd { static get requires() { return [$O] } static get pluginName() { return "MediaEmbedUI" } init() { const t = this.editor; const e = t.commands.get("mediaEmbed"); t.ui.componentFactory.add("mediaEmbed", (t => { const n = yv(t); this._setUpDropdown(n, e); return n })) } _setUpDropdown(t, n) { const i = this.editor; const o = i.t; const r = t.buttonView; const s = i.plugins.get($O).registry; t.once("change:isOpen", (() => { const o = new (e(eR))(oR(i.t, s), i.locale); t.panelView.children.add(o); r.on("open", (() => { o.disableCssTransitions(); o.url = n.value || ""; o.urlInputView.fieldView.select(); o.enableCssTransitions() }), { priority: "low" }); t.on("submit", (() => { if (o.isValid()) { i.execute("mediaEmbed", o.url); i.editing.view.focus() } })); t.on("change:isOpen", (() => o.resetFormStatus())); t.on("cancel", (() => { i.editing.view.focus() })); o.delegate("submit", "cancel").to(t); o.urlInputView.fieldView.bind("value").to(n, "value"); o.urlInputView.bind("isEnabled").to(n, "isEnabled") })); t.bind("isEnabled").to(n); r.set({ label: o("Insert media"), icon: nR, tooltip: true }) } } function oR(t, e) { return [e => { if (!e.url.length) { return t("The URL must not be empty.") } }, n => { if (!e.hasMedia(n.url)) { return t("This media URL is not supported.") } }] } var rR = n(5777); var sR = { injectType: "singletonStyleTag", attributes: { "data-cke": true } }; sR.insert = "head"; sR.singleton = true; var aR = Dl()(rR.Z, sR); const cR = rR.Z.locals || {}; class lR extends Kd { static get requires() { return [$O, iR, KO, bI] } static get pluginName() { return "MediaEmbed" } } class dR extends Kd { static get requires() { return [AI] } static get pluginName() { return "MediaEmbedToolbar" } afterInit() { const t = this.editor; const e = t.t; const n = t.plugins.get(AI); n.register("mediaEmbed", { ariaLabel: e("Media toolbar"), items: t.config.get("mediaEmbed.toolbar") || [], getRelatedElement: NO }) } } const uR = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>'; const hR = "removeFormat"; class fR extends Kd { static get pluginName() { return "RemoveFormatUI" } init() { const t = this.editor; const e = t.t; t.ui.componentFactory.add(hR, (n => { const i = t.commands.get(hR); const o = new kd(n); o.set({ label: e("Remove Format"), icon: uR, tooltip: true }); o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"); this.listenTo(o, "execute", (() => { t.execute(hR); t.editing.view.focus() })); return o })) } } class gR extends Jd { refresh() { const t = this.editor.model; this.isEnabled = !!ll(this._getFormattingItems(t.document.selection, t.schema)) } execute() { const t = this.editor.model; const e = t.schema; t.change((n => { for (const i of this._getFormattingItems(t.document.selection, e)) { if (i.is("selection")) { for (const t of this._getFormattingAttributes(i, e)) { n.removeSelectionAttribute(t) } } else { const t = n.createRangeOn(i); for (const o of this._getFormattingAttributes(i, e)) { n.removeAttribute(o, t) } } } })) } *_getFormattingItems(t, e) { const n = t => !!ll(this._getFormattingAttributes(t, e)); for (const i of t.getRanges()) { for (const t of i.getItems()) { if (!e.isBlock(t) && n(t)) { yield t } } } for (const e of t.getSelectedBlocks()) { if (n(e)) { yield e } } if (n(t)) { yield t } } *_getFormattingAttributes(t, e) { for (const [n] of t.getAttributes()) { const t = e.getAttributeProperties(n); if (t && t.isFormatting) { yield n } } } } class mR extends Kd { static get pluginName() { return "RemoveFormatEditing" } init() { const t = this.editor; t.commands.add("removeFormat", new gR(t)) } } class pR extends Kd { static get requires() { return [mR, fR] } static get pluginName() { return "RemoveFormat" } } function kR(t, e) { e = e || Xc(t); return `${t}:${e}` } function bR(t) { const [e, n] = t.split(":"); return { languageCode: e, textDirection: n } } class wR extends Jd { refresh() { const t = this.editor.model; const e = t.document; this.value = this._getValueFromFirstAllowedNode(); this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "language") } execute({ languageCode: t, textDirection: e } = {}) { const n = this.editor.model; const i = n.document; const o = i.selection; const r = t ? kR(t, e) : false; n.change((t => { if (o.isCollapsed) { if (r) { t.setSelectionAttribute("language", r) } else { t.removeSelectionAttribute("language") } } else { const e = n.schema.getValidRanges(o.getRanges(), "language"); for (const n of e) { if (r) { t.setAttribute("language", r, n) } else { t.removeAttribute("language", n) } } } })) } _getValueFromFirstAllowedNode() { const t = this.editor.model; const e = t.schema; const n = t.document.selection; if (n.isCollapsed) { return n.getAttribute("language") || false } for (const t of n.getRanges()) { for (const n of t.getItems()) { if (e.checkAttribute(n, "language")) { return n.getAttribute("language") || false } } } return false } } class _R extends Kd { static get pluginName() { return "TextPartLanguageEditing" } constructor(t) { super(t); t.config.define("language", { textPartLanguage: [{ title: "Arabic", languageCode: "ar" }, { title: "French", languageCode: "fr" }, { title: "Spanish", languageCode: "es" }] }) } init() { const t = this.editor; t.model.schema.extend("$text", { allowAttributes: "language" }); t.model.schema.setAttributeProperties("language", { copyOnEnter: true }); this._defineConverters(); t.commands.add("textPartLanguage", new wR(t)) } _defineConverters() { const t = this.editor.conversion; t.for("upcast").elementToAttribute({ model: { key: "language", value: t => { const e = t.getAttribute("lang"); const n = t.getAttribute("dir"); return kR(e, n) } }, view: { name: "span", attributes: { lang: /[\s\S]+/ } } }); t.for("downcast").attributeToElement({ model: "language", view: (t, { writer: e }, n) => { if (!t) { return } if (!n.item.is("$textProxy") && !n.item.is("documentSelection")) { return } const { languageCode: i, textDirection: o } = bR(t); return e.createAttributeElement("span", { lang: i, dir: o }) } }) } } class AR extends Kd { static get pluginName() { return "TextPartLanguageUI" } init() { const t = this.editor; const e = t.t; const n = t.config.get("language.textPartLanguage"); const i = e("Choose language"); const o = e("Remove language"); const r = e("Language"); t.ui.componentFactory.add("textPartLanguage", (e => { const s = new cl; const a = {}; const c = t.commands.get("textPartLanguage"); s.add({ type: "button", model: new Ry({ label: o, languageCode: false, withText: true }) }); s.add({ type: "separator" }); for (const t of n) { const e = { type: "button", model: new Ry({ label: t.title, languageCode: t.languageCode, textDirection: t.textDirection, withText: true }) }; const n = kR(t.languageCode, t.textDirection); e.model.bind("isOn").to(c, "value", (t => t === n)); s.add(e); a[n] = t.title } const l = yv(e); Dv(l, s); l.buttonView.set({ isOn: false, withText: true, tooltip: r }); l.extendTemplate({ attributes: { class: ["ck-text-fragment-language-dropdown"] } }); l.bind("isEnabled").to(c, "isEnabled"); l.buttonView.bind("label").to(c, "value", (t => t && a[t] || i)); this.listenTo(l, "execute", (e => { c.execute({ languageCode: e.source.languageCode, textDirection: e.source.textDirection }); t.editing.view.focus() })); return l })) } } class CR extends Kd { static get requires() { return [_R, AR] } static get pluginName() { return "TextPartLanguage" } } class vR extends Ox { } vR.builtinPlugins = [eE, dD, pD, AT, tM, kM, TM, gS, vS, MN, WN, CB, vB, mN, TB, PB, FB, BP, WP, RL, TO, lR, oM, pR, dT, SS, CR, bB]; vR.defaultConfig = { toolbar: { items: ["heading", "|", "bold", "italic", "alignment", "horizontalLine", "|", "imageInsert", "mediaEmbed", "|", "link", "blockQuote", "|", "indent", "outdent", "numberedList", "bulletedList", "|", "selectAll", "removeFormat", "findAndReplace", "|", "undo", "redo", "textPartLanguage"] }, language: "pt-br", image: { toolbar: ["imageTextAlternative", "toggleImageCaption", "imageStyle:alignLeft", "imageStyle:alignCenter", "imageStyle:alignRight", "linkImage"] } }; const yR = vR })(); i = i["default"]; return i })()));
//# sourceMappingURL=ckeditor.js.map